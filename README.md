# STNG
Compiler for fortran stencils using verified lifting

This repo contains the code for the STNG compiler.

**Note: This is still under active development. Please [sign up on our mailing list](https://mailman.cs.washington.edu/mailman/listinfo/stng-users) if you are interested
in our tool.**

## Description

STNG consists of the following components:
- a frontend parser that parses the input Fortran code, identifies potential stencils, 
and generates input for the synthesizer.
- a synthesizer that attempts to lift each of the identified stencil to a high-level summary
that can be re-targeted to execute on GPUs using [Halide](http://halide-lang.org).
- a backend that generates Halide code after a summary has been found.

The following describes how to use the various components in the compiler.


## Usage Instructions

1. Clone this repo and run `make` in `frontend`. Building the
frontend on your own machine requires installing [Rose](http://rosecompiler.org). If you don't
want to do that, an easier way is to build the docker image file with:
`docker build -f frontend/Dockerfile -t <optional tagname>` and then starts a container with
`docker run -ti <optional tagname> /bin/bash`, which would have built the frontend
for you in `/home/stng/stng/frontend/bin/translator`.

2. Run the frontend with the input Fortran file. This will generate a number of output files
in the output directory as specified by the `-out` flag.

3. TBD for running the synthesizer and the backend


## An End-to-end Example

### Frontend
Given this code (`simple.f90` in `frontend/tests/simple.f90`):
```fortran
SUBROUTINE simple(j, x_min, x_max)
INTEGER :: j
INTEGER :: x_max
INTEGER :: x_min
REAL(kind=8), DIMENSION(x_min:x_max) :: in, out

DO j = x_min, x_max
  out(j) = in(j)
END DO

END SUBROUTINE
```

Note that this benchmark consists of one stencil (namely the `DO...END DO` loop over 
the array `in`). The job of the frontend is to identify this stencil and translates
the stencil into a simpler intermediate representation (IR) that the synthesizer can
use to search for a high-level summary later on.

Running `frontend/bin/translator simple.f90 -out simple_out` generates the following
files in the `simple_out` directory:
```
simple_loop0.ir
simple_loop0.f90
simple.f90
simple_loop0_halideglue.cpp
simple_loop0_halideglue.h
simple_loop0_benchmark.f90
```

In general each identified stencil in file `foo` is labeled as `foo_loop0`, `foo_loop1`, etc.

Here's what each of the files contains:
- `simple_loop0.ir`: an internal IR representation of the stencil for the synthesizer and 
backend to process. 
- `simple_loop0.f90`: the original stencil code, extracted as a function on its own.
- `simple.f90`: a transformed version of the input file where the stencil is replaced
by a call to Halide (`simple_loop0_halideglue`), or the original version if the translation
failed (`simple_loop0` as defined in `simple_loop0.f90`).
- `simple_loop0_halideglue.{cpp, h}`: glue code to call the Halide runtime.
The Halide implementation of the stencil (`simple_loop0_halide` in `simple_loop0_halideglue.cpp`)
will be generated by the synthesizer and the backend.
- `simple_loop0_benchmark.f90`: code for doing timing measurements. This is for running
the integration tests and can be ignored otherwise.

### Finding summaries using sketch and z3

### Halide code generation


## Test Cases

- `frontend/tests` includes a number of small benchmark cases that you can play around with.

- `tests/integration` includes three benchmarks (Cloverleaf, NAS MG, stencilmark) that are used in our 
[PLDI paper](https://homes.cs.washington.edu/~akcheung/papers/pldi16.html). To run the frontend on 
those benchmarks, do the following:
  - `make clover_leaf_stencil` in `CloverLeaf_Serial`
  - `make stencil` in `stencilmark_fortran`
  - `make MG_stencil` in `NPB3.2-SER`
Doing so will generate a `stencil` directory containing the outputs from running the frontend
on these benchmarks.
