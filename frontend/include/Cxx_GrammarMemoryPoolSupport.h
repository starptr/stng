// MACHINE GENERATED SOURCE FILE --- DO NOT MODIFY! (Grammar.C) 


// generated file
/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNode_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNode* SgNode_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNode_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNode* SgNode_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNode* SgNode_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNode_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNode_clearMemoryPool ( );
void SgNode_extendMemoryPoolForFileIO ( );
unsigned long SgNode_initializeStorageClassArray( SgNodeStorageClass *storageArray );
void SgNode_resetValidFreepointers( );
unsigned long SgNode_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgSupport_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgSupport* SgSupport_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgSupport_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgSupport* SgSupport_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgSupport* SgSupport_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgSupport_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgSupport_clearMemoryPool ( );
void SgSupport_extendMemoryPoolForFileIO ( );
unsigned long SgSupport_initializeStorageClassArray( SgSupportStorageClass *storageArray );
void SgSupport_resetValidFreepointers( );
unsigned long SgSupport_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgModifier_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgModifier* SgModifier_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgModifier_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgModifier* SgModifier_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgModifier* SgModifier_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgModifier_clearMemoryPool ( );
void SgModifier_extendMemoryPoolForFileIO ( );
unsigned long SgModifier_initializeStorageClassArray( SgModifierStorageClass *storageArray );
void SgModifier_resetValidFreepointers( );
unsigned long SgModifier_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgModifierNodes_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgModifierNodes* SgModifierNodes_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgModifierNodes_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgModifierNodes* SgModifierNodes_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgModifierNodes* SgModifierNodes_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgModifierNodes_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgModifierNodes_clearMemoryPool ( );
void SgModifierNodes_extendMemoryPoolForFileIO ( );
unsigned long SgModifierNodes_initializeStorageClassArray( SgModifierNodesStorageClass *storageArray );
void SgModifierNodes_resetValidFreepointers( );
unsigned long SgModifierNodes_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgConstVolatileModifier_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgConstVolatileModifier* SgConstVolatileModifier_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgConstVolatileModifier_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgConstVolatileModifier* SgConstVolatileModifier_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgConstVolatileModifier* SgConstVolatileModifier_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgConstVolatileModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgConstVolatileModifier_clearMemoryPool ( );
void SgConstVolatileModifier_extendMemoryPoolForFileIO ( );
unsigned long SgConstVolatileModifier_initializeStorageClassArray( SgConstVolatileModifierStorageClass *storageArray );
void SgConstVolatileModifier_resetValidFreepointers( );
unsigned long SgConstVolatileModifier_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgStorageModifier_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgStorageModifier* SgStorageModifier_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgStorageModifier_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgStorageModifier* SgStorageModifier_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgStorageModifier* SgStorageModifier_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgStorageModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgStorageModifier_clearMemoryPool ( );
void SgStorageModifier_extendMemoryPoolForFileIO ( );
unsigned long SgStorageModifier_initializeStorageClassArray( SgStorageModifierStorageClass *storageArray );
void SgStorageModifier_resetValidFreepointers( );
unsigned long SgStorageModifier_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAccessModifier_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAccessModifier* SgAccessModifier_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAccessModifier_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAccessModifier* SgAccessModifier_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAccessModifier* SgAccessModifier_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAccessModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAccessModifier_clearMemoryPool ( );
void SgAccessModifier_extendMemoryPoolForFileIO ( );
unsigned long SgAccessModifier_initializeStorageClassArray( SgAccessModifierStorageClass *storageArray );
void SgAccessModifier_resetValidFreepointers( );
unsigned long SgAccessModifier_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFunctionModifier_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFunctionModifier* SgFunctionModifier_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFunctionModifier_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFunctionModifier* SgFunctionModifier_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFunctionModifier* SgFunctionModifier_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFunctionModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFunctionModifier_clearMemoryPool ( );
void SgFunctionModifier_extendMemoryPoolForFileIO ( );
unsigned long SgFunctionModifier_initializeStorageClassArray( SgFunctionModifierStorageClass *storageArray );
void SgFunctionModifier_resetValidFreepointers( );
unsigned long SgFunctionModifier_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUPC_AccessModifier_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUPC_AccessModifier* SgUPC_AccessModifier_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUPC_AccessModifier_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUPC_AccessModifier* SgUPC_AccessModifier_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUPC_AccessModifier* SgUPC_AccessModifier_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUPC_AccessModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUPC_AccessModifier_clearMemoryPool ( );
void SgUPC_AccessModifier_extendMemoryPoolForFileIO ( );
unsigned long SgUPC_AccessModifier_initializeStorageClassArray( SgUPC_AccessModifierStorageClass *storageArray );
void SgUPC_AccessModifier_resetValidFreepointers( );
unsigned long SgUPC_AccessModifier_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgSpecialFunctionModifier_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgSpecialFunctionModifier* SgSpecialFunctionModifier_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgSpecialFunctionModifier_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgSpecialFunctionModifier* SgSpecialFunctionModifier_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgSpecialFunctionModifier* SgSpecialFunctionModifier_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgSpecialFunctionModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgSpecialFunctionModifier_clearMemoryPool ( );
void SgSpecialFunctionModifier_extendMemoryPoolForFileIO ( );
unsigned long SgSpecialFunctionModifier_initializeStorageClassArray( SgSpecialFunctionModifierStorageClass *storageArray );
void SgSpecialFunctionModifier_resetValidFreepointers( );
unsigned long SgSpecialFunctionModifier_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgElaboratedTypeModifier_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgElaboratedTypeModifier* SgElaboratedTypeModifier_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgElaboratedTypeModifier_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgElaboratedTypeModifier* SgElaboratedTypeModifier_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgElaboratedTypeModifier* SgElaboratedTypeModifier_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgElaboratedTypeModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgElaboratedTypeModifier_clearMemoryPool ( );
void SgElaboratedTypeModifier_extendMemoryPoolForFileIO ( );
unsigned long SgElaboratedTypeModifier_initializeStorageClassArray( SgElaboratedTypeModifierStorageClass *storageArray );
void SgElaboratedTypeModifier_resetValidFreepointers( );
unsigned long SgElaboratedTypeModifier_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLinkageModifier_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLinkageModifier* SgLinkageModifier_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLinkageModifier_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLinkageModifier* SgLinkageModifier_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLinkageModifier* SgLinkageModifier_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLinkageModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLinkageModifier_clearMemoryPool ( );
void SgLinkageModifier_extendMemoryPoolForFileIO ( );
unsigned long SgLinkageModifier_initializeStorageClassArray( SgLinkageModifierStorageClass *storageArray );
void SgLinkageModifier_resetValidFreepointers( );
unsigned long SgLinkageModifier_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgBaseClassModifier_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgBaseClassModifier* SgBaseClassModifier_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgBaseClassModifier_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgBaseClassModifier* SgBaseClassModifier_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgBaseClassModifier* SgBaseClassModifier_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgBaseClassModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgBaseClassModifier_clearMemoryPool ( );
void SgBaseClassModifier_extendMemoryPoolForFileIO ( );
unsigned long SgBaseClassModifier_initializeStorageClassArray( SgBaseClassModifierStorageClass *storageArray );
void SgBaseClassModifier_resetValidFreepointers( );
unsigned long SgBaseClassModifier_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeModifier_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeModifier* SgTypeModifier_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeModifier_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeModifier* SgTypeModifier_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeModifier* SgTypeModifier_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeModifier_clearMemoryPool ( );
void SgTypeModifier_extendMemoryPoolForFileIO ( );
unsigned long SgTypeModifier_initializeStorageClassArray( SgTypeModifierStorageClass *storageArray );
void SgTypeModifier_resetValidFreepointers( );
unsigned long SgTypeModifier_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDeclarationModifier_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDeclarationModifier* SgDeclarationModifier_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDeclarationModifier_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDeclarationModifier* SgDeclarationModifier_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDeclarationModifier* SgDeclarationModifier_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDeclarationModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDeclarationModifier_clearMemoryPool ( );
void SgDeclarationModifier_extendMemoryPoolForFileIO ( );
unsigned long SgDeclarationModifier_initializeStorageClassArray( SgDeclarationModifierStorageClass *storageArray );
void SgDeclarationModifier_resetValidFreepointers( );
unsigned long SgDeclarationModifier_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOpenclAccessModeModifier_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOpenclAccessModeModifier* SgOpenclAccessModeModifier_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOpenclAccessModeModifier_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOpenclAccessModeModifier* SgOpenclAccessModeModifier_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOpenclAccessModeModifier* SgOpenclAccessModeModifier_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOpenclAccessModeModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOpenclAccessModeModifier_clearMemoryPool ( );
void SgOpenclAccessModeModifier_extendMemoryPoolForFileIO ( );
unsigned long SgOpenclAccessModeModifier_initializeStorageClassArray( SgOpenclAccessModeModifierStorageClass *storageArray );
void SgOpenclAccessModeModifier_resetValidFreepointers( );
unsigned long SgOpenclAccessModeModifier_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgName_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgName* SgName_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgName_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgName* SgName_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgName* SgName_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgName_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgName_clearMemoryPool ( );
void SgName_extendMemoryPoolForFileIO ( );
unsigned long SgName_initializeStorageClassArray( SgNameStorageClass *storageArray );
void SgName_resetValidFreepointers( );
unsigned long SgName_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgSymbolTable_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgSymbolTable* SgSymbolTable_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgSymbolTable_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgSymbolTable* SgSymbolTable_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgSymbolTable* SgSymbolTable_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgSymbolTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgSymbolTable_clearMemoryPool ( );
void SgSymbolTable_extendMemoryPoolForFileIO ( );
unsigned long SgSymbolTable_initializeStorageClassArray( SgSymbolTableStorageClass *storageArray );
void SgSymbolTable_resetValidFreepointers( );
unsigned long SgSymbolTable_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAttribute_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAttribute* SgAttribute_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAttribute_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAttribute* SgAttribute_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAttribute* SgAttribute_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAttribute_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAttribute_clearMemoryPool ( );
void SgAttribute_extendMemoryPoolForFileIO ( );
unsigned long SgAttribute_initializeStorageClassArray( SgAttributeStorageClass *storageArray );
void SgAttribute_resetValidFreepointers( );
unsigned long SgAttribute_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgPragma_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgPragma* SgPragma_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgPragma_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgPragma* SgPragma_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgPragma* SgPragma_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgPragma_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgPragma_clearMemoryPool ( );
void SgPragma_extendMemoryPoolForFileIO ( );
unsigned long SgPragma_initializeStorageClassArray( SgPragmaStorageClass *storageArray );
void SgPragma_resetValidFreepointers( );
unsigned long SgPragma_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgBitAttribute_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgBitAttribute* SgBitAttribute_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgBitAttribute_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgBitAttribute* SgBitAttribute_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgBitAttribute* SgBitAttribute_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgBitAttribute_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgBitAttribute_clearMemoryPool ( );
void SgBitAttribute_extendMemoryPoolForFileIO ( );
unsigned long SgBitAttribute_initializeStorageClassArray( SgBitAttributeStorageClass *storageArray );
void SgBitAttribute_resetValidFreepointers( );
unsigned long SgBitAttribute_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFuncDecl_attr_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFuncDecl_attr* SgFuncDecl_attr_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFuncDecl_attr_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFuncDecl_attr* SgFuncDecl_attr_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFuncDecl_attr* SgFuncDecl_attr_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFuncDecl_attr_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFuncDecl_attr_clearMemoryPool ( );
void SgFuncDecl_attr_extendMemoryPoolForFileIO ( );
unsigned long SgFuncDecl_attr_initializeStorageClassArray( SgFuncDecl_attrStorageClass *storageArray );
void SgFuncDecl_attr_resetValidFreepointers( );
unsigned long SgFuncDecl_attr_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgClassDecl_attr_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgClassDecl_attr* SgClassDecl_attr_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgClassDecl_attr_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgClassDecl_attr* SgClassDecl_attr_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgClassDecl_attr* SgClassDecl_attr_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgClassDecl_attr_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgClassDecl_attr_clearMemoryPool ( );
void SgClassDecl_attr_extendMemoryPoolForFileIO ( );
unsigned long SgClassDecl_attr_initializeStorageClassArray( SgClassDecl_attrStorageClass *storageArray );
void SgClassDecl_attr_resetValidFreepointers( );
unsigned long SgClassDecl_attr_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int Sg_File_Info_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern Sg_File_Info* Sg_File_Info_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > Sg_File_Info_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
Sg_File_Info* Sg_File_Info_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
Sg_File_Info* Sg_File_Info_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long Sg_File_Info_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void Sg_File_Info_clearMemoryPool ( );
void Sg_File_Info_extendMemoryPoolForFileIO ( );
unsigned long Sg_File_Info_initializeStorageClassArray( Sg_File_InfoStorageClass *storageArray );
void Sg_File_Info_resetValidFreepointers( );
unsigned long Sg_File_Info_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFile_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFile* SgFile_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFile_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFile* SgFile_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFile* SgFile_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFile_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFile_clearMemoryPool ( );
void SgFile_extendMemoryPoolForFileIO ( );
unsigned long SgFile_initializeStorageClassArray( SgFileStorageClass *storageArray );
void SgFile_resetValidFreepointers( );
unsigned long SgFile_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgSourceFile_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgSourceFile* SgSourceFile_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgSourceFile_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgSourceFile* SgSourceFile_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgSourceFile* SgSourceFile_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgSourceFile_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgSourceFile_clearMemoryPool ( );
void SgSourceFile_extendMemoryPoolForFileIO ( );
unsigned long SgSourceFile_initializeStorageClassArray( SgSourceFileStorageClass *storageArray );
void SgSourceFile_resetValidFreepointers( );
unsigned long SgSourceFile_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgBinaryComposite_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgBinaryComposite* SgBinaryComposite_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgBinaryComposite_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgBinaryComposite* SgBinaryComposite_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgBinaryComposite* SgBinaryComposite_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgBinaryComposite_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgBinaryComposite_clearMemoryPool ( );
void SgBinaryComposite_extendMemoryPoolForFileIO ( );
unsigned long SgBinaryComposite_initializeStorageClassArray( SgBinaryCompositeStorageClass *storageArray );
void SgBinaryComposite_resetValidFreepointers( );
unsigned long SgBinaryComposite_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUnknownFile_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUnknownFile* SgUnknownFile_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUnknownFile_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUnknownFile* SgUnknownFile_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUnknownFile* SgUnknownFile_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUnknownFile_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUnknownFile_clearMemoryPool ( );
void SgUnknownFile_extendMemoryPoolForFileIO ( );
unsigned long SgUnknownFile_initializeStorageClassArray( SgUnknownFileStorageClass *storageArray );
void SgUnknownFile_resetValidFreepointers( );
unsigned long SgUnknownFile_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgProject_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgProject* SgProject_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgProject_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgProject* SgProject_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgProject* SgProject_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgProject_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgProject_clearMemoryPool ( );
void SgProject_extendMemoryPoolForFileIO ( );
unsigned long SgProject_initializeStorageClassArray( SgProjectStorageClass *storageArray );
void SgProject_resetValidFreepointers( );
unsigned long SgProject_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOptions_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOptions* SgOptions_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOptions_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOptions* SgOptions_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOptions* SgOptions_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOptions_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOptions_clearMemoryPool ( );
void SgOptions_extendMemoryPoolForFileIO ( );
unsigned long SgOptions_initializeStorageClassArray( SgOptionsStorageClass *storageArray );
void SgOptions_resetValidFreepointers( );
unsigned long SgOptions_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUnparse_Info_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUnparse_Info* SgUnparse_Info_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUnparse_Info_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUnparse_Info* SgUnparse_Info_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUnparse_Info* SgUnparse_Info_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUnparse_Info_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUnparse_Info_clearMemoryPool ( );
void SgUnparse_Info_extendMemoryPoolForFileIO ( );
unsigned long SgUnparse_Info_initializeStorageClassArray( SgUnparse_InfoStorageClass *storageArray );
void SgUnparse_Info_resetValidFreepointers( );
unsigned long SgUnparse_Info_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgBaseClass_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgBaseClass* SgBaseClass_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgBaseClass_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgBaseClass* SgBaseClass_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgBaseClass* SgBaseClass_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgBaseClass_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgBaseClass_clearMemoryPool ( );
void SgBaseClass_extendMemoryPoolForFileIO ( );
unsigned long SgBaseClass_initializeStorageClassArray( SgBaseClassStorageClass *storageArray );
void SgBaseClass_resetValidFreepointers( );
unsigned long SgBaseClass_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgExpBaseClass_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgExpBaseClass* SgExpBaseClass_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgExpBaseClass_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgExpBaseClass* SgExpBaseClass_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgExpBaseClass* SgExpBaseClass_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgExpBaseClass_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgExpBaseClass_clearMemoryPool ( );
void SgExpBaseClass_extendMemoryPoolForFileIO ( );
unsigned long SgExpBaseClass_initializeStorageClassArray( SgExpBaseClassStorageClass *storageArray );
void SgExpBaseClass_resetValidFreepointers( );
unsigned long SgExpBaseClass_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypedefSeq_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypedefSeq* SgTypedefSeq_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypedefSeq_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypedefSeq* SgTypedefSeq_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypedefSeq* SgTypedefSeq_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypedefSeq_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypedefSeq_clearMemoryPool ( );
void SgTypedefSeq_extendMemoryPoolForFileIO ( );
unsigned long SgTypedefSeq_initializeStorageClassArray( SgTypedefSeqStorageClass *storageArray );
void SgTypedefSeq_resetValidFreepointers( );
unsigned long SgTypedefSeq_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateParameter_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateParameter* SgTemplateParameter_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateParameter_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateParameter* SgTemplateParameter_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateParameter* SgTemplateParameter_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateParameter_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateParameter_clearMemoryPool ( );
void SgTemplateParameter_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateParameter_initializeStorageClassArray( SgTemplateParameterStorageClass *storageArray );
void SgTemplateParameter_resetValidFreepointers( );
unsigned long SgTemplateParameter_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateArgument_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateArgument* SgTemplateArgument_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateArgument_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateArgument* SgTemplateArgument_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateArgument* SgTemplateArgument_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateArgument_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateArgument_clearMemoryPool ( );
void SgTemplateArgument_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateArgument_initializeStorageClassArray( SgTemplateArgumentStorageClass *storageArray );
void SgTemplateArgument_resetValidFreepointers( );
unsigned long SgTemplateArgument_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDirectory_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDirectory* SgDirectory_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDirectory_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDirectory* SgDirectory_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDirectory* SgDirectory_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDirectory_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDirectory_clearMemoryPool ( );
void SgDirectory_extendMemoryPoolForFileIO ( );
unsigned long SgDirectory_initializeStorageClassArray( SgDirectoryStorageClass *storageArray );
void SgDirectory_resetValidFreepointers( );
unsigned long SgDirectory_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFileList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFileList* SgFileList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFileList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFileList* SgFileList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFileList* SgFileList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFileList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFileList_clearMemoryPool ( );
void SgFileList_extendMemoryPoolForFileIO ( );
unsigned long SgFileList_initializeStorageClassArray( SgFileListStorageClass *storageArray );
void SgFileList_resetValidFreepointers( );
unsigned long SgFileList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDirectoryList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDirectoryList* SgDirectoryList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDirectoryList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDirectoryList* SgDirectoryList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDirectoryList* SgDirectoryList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDirectoryList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDirectoryList_clearMemoryPool ( );
void SgDirectoryList_extendMemoryPoolForFileIO ( );
unsigned long SgDirectoryList_initializeStorageClassArray( SgDirectoryListStorageClass *storageArray );
void SgDirectoryList_resetValidFreepointers( );
unsigned long SgDirectoryList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFunctionParameterTypeList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFunctionParameterTypeList* SgFunctionParameterTypeList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFunctionParameterTypeList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFunctionParameterTypeList* SgFunctionParameterTypeList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFunctionParameterTypeList* SgFunctionParameterTypeList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFunctionParameterTypeList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFunctionParameterTypeList_clearMemoryPool ( );
void SgFunctionParameterTypeList_extendMemoryPoolForFileIO ( );
unsigned long SgFunctionParameterTypeList_initializeStorageClassArray( SgFunctionParameterTypeListStorageClass *storageArray );
void SgFunctionParameterTypeList_resetValidFreepointers( );
unsigned long SgFunctionParameterTypeList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgQualifiedName_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgQualifiedName* SgQualifiedName_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgQualifiedName_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgQualifiedName* SgQualifiedName_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgQualifiedName* SgQualifiedName_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgQualifiedName_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgQualifiedName_clearMemoryPool ( );
void SgQualifiedName_extendMemoryPoolForFileIO ( );
unsigned long SgQualifiedName_initializeStorageClassArray( SgQualifiedNameStorageClass *storageArray );
void SgQualifiedName_resetValidFreepointers( );
unsigned long SgQualifiedName_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateArgumentList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateArgumentList* SgTemplateArgumentList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateArgumentList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateArgumentList* SgTemplateArgumentList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateArgumentList* SgTemplateArgumentList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateArgumentList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateArgumentList_clearMemoryPool ( );
void SgTemplateArgumentList_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateArgumentList_initializeStorageClassArray( SgTemplateArgumentListStorageClass *storageArray );
void SgTemplateArgumentList_resetValidFreepointers( );
unsigned long SgTemplateArgumentList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateParameterList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateParameterList* SgTemplateParameterList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateParameterList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateParameterList* SgTemplateParameterList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateParameterList* SgTemplateParameterList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateParameterList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateParameterList_clearMemoryPool ( );
void SgTemplateParameterList_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateParameterList_initializeStorageClassArray( SgTemplateParameterListStorageClass *storageArray );
void SgTemplateParameterList_resetValidFreepointers( );
unsigned long SgTemplateParameterList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgGraph_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgGraph* SgGraph_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgGraph_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgGraph* SgGraph_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgGraph* SgGraph_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgGraph_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgGraph_clearMemoryPool ( );
void SgGraph_extendMemoryPoolForFileIO ( );
unsigned long SgGraph_initializeStorageClassArray( SgGraphStorageClass *storageArray );
void SgGraph_resetValidFreepointers( );
unsigned long SgGraph_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIncidenceDirectedGraph_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIncidenceDirectedGraph* SgIncidenceDirectedGraph_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIncidenceDirectedGraph_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIncidenceDirectedGraph* SgIncidenceDirectedGraph_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIncidenceDirectedGraph* SgIncidenceDirectedGraph_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIncidenceDirectedGraph_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIncidenceDirectedGraph_clearMemoryPool ( );
void SgIncidenceDirectedGraph_extendMemoryPoolForFileIO ( );
unsigned long SgIncidenceDirectedGraph_initializeStorageClassArray( SgIncidenceDirectedGraphStorageClass *storageArray );
void SgIncidenceDirectedGraph_resetValidFreepointers( );
unsigned long SgIncidenceDirectedGraph_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgBidirectionalGraph_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgBidirectionalGraph* SgBidirectionalGraph_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgBidirectionalGraph_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgBidirectionalGraph* SgBidirectionalGraph_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgBidirectionalGraph* SgBidirectionalGraph_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgBidirectionalGraph_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgBidirectionalGraph_clearMemoryPool ( );
void SgBidirectionalGraph_extendMemoryPoolForFileIO ( );
unsigned long SgBidirectionalGraph_initializeStorageClassArray( SgBidirectionalGraphStorageClass *storageArray );
void SgBidirectionalGraph_resetValidFreepointers( );
unsigned long SgBidirectionalGraph_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgStringKeyedBidirectionalGraph_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgStringKeyedBidirectionalGraph* SgStringKeyedBidirectionalGraph_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgStringKeyedBidirectionalGraph_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgStringKeyedBidirectionalGraph* SgStringKeyedBidirectionalGraph_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgStringKeyedBidirectionalGraph* SgStringKeyedBidirectionalGraph_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgStringKeyedBidirectionalGraph_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgStringKeyedBidirectionalGraph_clearMemoryPool ( );
void SgStringKeyedBidirectionalGraph_extendMemoryPoolForFileIO ( );
unsigned long SgStringKeyedBidirectionalGraph_initializeStorageClassArray( SgStringKeyedBidirectionalGraphStorageClass *storageArray );
void SgStringKeyedBidirectionalGraph_resetValidFreepointers( );
unsigned long SgStringKeyedBidirectionalGraph_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIntKeyedBidirectionalGraph_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIntKeyedBidirectionalGraph* SgIntKeyedBidirectionalGraph_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIntKeyedBidirectionalGraph_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIntKeyedBidirectionalGraph* SgIntKeyedBidirectionalGraph_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIntKeyedBidirectionalGraph* SgIntKeyedBidirectionalGraph_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIntKeyedBidirectionalGraph_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIntKeyedBidirectionalGraph_clearMemoryPool ( );
void SgIntKeyedBidirectionalGraph_extendMemoryPoolForFileIO ( );
unsigned long SgIntKeyedBidirectionalGraph_initializeStorageClassArray( SgIntKeyedBidirectionalGraphStorageClass *storageArray );
void SgIntKeyedBidirectionalGraph_resetValidFreepointers( );
unsigned long SgIntKeyedBidirectionalGraph_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIncidenceUndirectedGraph_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIncidenceUndirectedGraph* SgIncidenceUndirectedGraph_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIncidenceUndirectedGraph_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIncidenceUndirectedGraph* SgIncidenceUndirectedGraph_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIncidenceUndirectedGraph* SgIncidenceUndirectedGraph_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIncidenceUndirectedGraph_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIncidenceUndirectedGraph_clearMemoryPool ( );
void SgIncidenceUndirectedGraph_extendMemoryPoolForFileIO ( );
unsigned long SgIncidenceUndirectedGraph_initializeStorageClassArray( SgIncidenceUndirectedGraphStorageClass *storageArray );
void SgIncidenceUndirectedGraph_resetValidFreepointers( );
unsigned long SgIncidenceUndirectedGraph_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgGraphNode_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgGraphNode* SgGraphNode_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgGraphNode_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgGraphNode* SgGraphNode_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgGraphNode* SgGraphNode_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgGraphNode_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgGraphNode_clearMemoryPool ( );
void SgGraphNode_extendMemoryPoolForFileIO ( );
unsigned long SgGraphNode_initializeStorageClassArray( SgGraphNodeStorageClass *storageArray );
void SgGraphNode_resetValidFreepointers( );
unsigned long SgGraphNode_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgGraphEdge_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgGraphEdge* SgGraphEdge_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgGraphEdge_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgGraphEdge* SgGraphEdge_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgGraphEdge* SgGraphEdge_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgGraphEdge_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgGraphEdge_clearMemoryPool ( );
void SgGraphEdge_extendMemoryPoolForFileIO ( );
unsigned long SgGraphEdge_initializeStorageClassArray( SgGraphEdgeStorageClass *storageArray );
void SgGraphEdge_resetValidFreepointers( );
unsigned long SgGraphEdge_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDirectedGraphEdge_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDirectedGraphEdge* SgDirectedGraphEdge_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDirectedGraphEdge_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDirectedGraphEdge* SgDirectedGraphEdge_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDirectedGraphEdge* SgDirectedGraphEdge_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDirectedGraphEdge_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDirectedGraphEdge_clearMemoryPool ( );
void SgDirectedGraphEdge_extendMemoryPoolForFileIO ( );
unsigned long SgDirectedGraphEdge_initializeStorageClassArray( SgDirectedGraphEdgeStorageClass *storageArray );
void SgDirectedGraphEdge_resetValidFreepointers( );
unsigned long SgDirectedGraphEdge_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUndirectedGraphEdge_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUndirectedGraphEdge* SgUndirectedGraphEdge_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUndirectedGraphEdge_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUndirectedGraphEdge* SgUndirectedGraphEdge_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUndirectedGraphEdge* SgUndirectedGraphEdge_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUndirectedGraphEdge_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUndirectedGraphEdge_clearMemoryPool ( );
void SgUndirectedGraphEdge_extendMemoryPoolForFileIO ( );
unsigned long SgUndirectedGraphEdge_initializeStorageClassArray( SgUndirectedGraphEdgeStorageClass *storageArray );
void SgUndirectedGraphEdge_resetValidFreepointers( );
unsigned long SgUndirectedGraphEdge_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgGraphNodeList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgGraphNodeList* SgGraphNodeList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgGraphNodeList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgGraphNodeList* SgGraphNodeList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgGraphNodeList* SgGraphNodeList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgGraphNodeList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgGraphNodeList_clearMemoryPool ( );
void SgGraphNodeList_extendMemoryPoolForFileIO ( );
unsigned long SgGraphNodeList_initializeStorageClassArray( SgGraphNodeListStorageClass *storageArray );
void SgGraphNodeList_resetValidFreepointers( );
unsigned long SgGraphNodeList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgGraphEdgeList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgGraphEdgeList* SgGraphEdgeList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgGraphEdgeList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgGraphEdgeList* SgGraphEdgeList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgGraphEdgeList* SgGraphEdgeList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgGraphEdgeList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgGraphEdgeList_clearMemoryPool ( );
void SgGraphEdgeList_extendMemoryPoolForFileIO ( );
unsigned long SgGraphEdgeList_initializeStorageClassArray( SgGraphEdgeListStorageClass *storageArray );
void SgGraphEdgeList_resetValidFreepointers( );
unsigned long SgGraphEdgeList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeTable_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeTable* SgTypeTable_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeTable_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeTable* SgTypeTable_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeTable* SgTypeTable_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeTable_clearMemoryPool ( );
void SgTypeTable_extendMemoryPoolForFileIO ( );
unsigned long SgTypeTable_initializeStorageClassArray( SgTypeTableStorageClass *storageArray );
void SgTypeTable_resetValidFreepointers( );
unsigned long SgTypeTable_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNameGroup_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNameGroup* SgNameGroup_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNameGroup_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNameGroup* SgNameGroup_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNameGroup* SgNameGroup_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNameGroup_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNameGroup_clearMemoryPool ( );
void SgNameGroup_extendMemoryPoolForFileIO ( );
unsigned long SgNameGroup_initializeStorageClassArray( SgNameGroupStorageClass *storageArray );
void SgNameGroup_resetValidFreepointers( );
unsigned long SgNameGroup_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDimensionObject_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDimensionObject* SgDimensionObject_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDimensionObject_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDimensionObject* SgDimensionObject_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDimensionObject* SgDimensionObject_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDimensionObject_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDimensionObject_clearMemoryPool ( );
void SgDimensionObject_extendMemoryPoolForFileIO ( );
unsigned long SgDimensionObject_initializeStorageClassArray( SgDimensionObjectStorageClass *storageArray );
void SgDimensionObject_resetValidFreepointers( );
unsigned long SgDimensionObject_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFormatItem_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFormatItem* SgFormatItem_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFormatItem_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFormatItem* SgFormatItem_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFormatItem* SgFormatItem_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFormatItem_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFormatItem_clearMemoryPool ( );
void SgFormatItem_extendMemoryPoolForFileIO ( );
unsigned long SgFormatItem_initializeStorageClassArray( SgFormatItemStorageClass *storageArray );
void SgFormatItem_resetValidFreepointers( );
unsigned long SgFormatItem_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFormatItemList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFormatItemList* SgFormatItemList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFormatItemList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFormatItemList* SgFormatItemList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFormatItemList* SgFormatItemList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFormatItemList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFormatItemList_clearMemoryPool ( );
void SgFormatItemList_extendMemoryPoolForFileIO ( );
unsigned long SgFormatItemList_initializeStorageClassArray( SgFormatItemListStorageClass *storageArray );
void SgFormatItemList_resetValidFreepointers( );
unsigned long SgFormatItemList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDataStatementGroup_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDataStatementGroup* SgDataStatementGroup_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDataStatementGroup_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDataStatementGroup* SgDataStatementGroup_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDataStatementGroup* SgDataStatementGroup_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDataStatementGroup_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDataStatementGroup_clearMemoryPool ( );
void SgDataStatementGroup_extendMemoryPoolForFileIO ( );
unsigned long SgDataStatementGroup_initializeStorageClassArray( SgDataStatementGroupStorageClass *storageArray );
void SgDataStatementGroup_resetValidFreepointers( );
unsigned long SgDataStatementGroup_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDataStatementObject_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDataStatementObject* SgDataStatementObject_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDataStatementObject_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDataStatementObject* SgDataStatementObject_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDataStatementObject* SgDataStatementObject_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDataStatementObject_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDataStatementObject_clearMemoryPool ( );
void SgDataStatementObject_extendMemoryPoolForFileIO ( );
unsigned long SgDataStatementObject_initializeStorageClassArray( SgDataStatementObjectStorageClass *storageArray );
void SgDataStatementObject_resetValidFreepointers( );
unsigned long SgDataStatementObject_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDataStatementValue_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDataStatementValue* SgDataStatementValue_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDataStatementValue_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDataStatementValue* SgDataStatementValue_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDataStatementValue* SgDataStatementValue_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDataStatementValue_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDataStatementValue_clearMemoryPool ( );
void SgDataStatementValue_extendMemoryPoolForFileIO ( );
unsigned long SgDataStatementValue_initializeStorageClassArray( SgDataStatementValueStorageClass *storageArray );
void SgDataStatementValue_resetValidFreepointers( );
unsigned long SgDataStatementValue_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgType* SgType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgType* SgType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgType* SgType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgType_clearMemoryPool ( );
void SgType_extendMemoryPoolForFileIO ( );
unsigned long SgType_initializeStorageClassArray( SgTypeStorageClass *storageArray );
void SgType_resetValidFreepointers( );
unsigned long SgType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeUnknown_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeUnknown* SgTypeUnknown_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeUnknown_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeUnknown* SgTypeUnknown_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeUnknown* SgTypeUnknown_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeUnknown_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeUnknown_clearMemoryPool ( );
void SgTypeUnknown_extendMemoryPoolForFileIO ( );
unsigned long SgTypeUnknown_initializeStorageClassArray( SgTypeUnknownStorageClass *storageArray );
void SgTypeUnknown_resetValidFreepointers( );
unsigned long SgTypeUnknown_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeChar_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeChar* SgTypeChar_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeChar_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeChar* SgTypeChar_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeChar* SgTypeChar_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeChar_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeChar_clearMemoryPool ( );
void SgTypeChar_extendMemoryPoolForFileIO ( );
unsigned long SgTypeChar_initializeStorageClassArray( SgTypeCharStorageClass *storageArray );
void SgTypeChar_resetValidFreepointers( );
unsigned long SgTypeChar_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeSignedChar_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeSignedChar* SgTypeSignedChar_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeSignedChar_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeSignedChar* SgTypeSignedChar_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeSignedChar* SgTypeSignedChar_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeSignedChar_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeSignedChar_clearMemoryPool ( );
void SgTypeSignedChar_extendMemoryPoolForFileIO ( );
unsigned long SgTypeSignedChar_initializeStorageClassArray( SgTypeSignedCharStorageClass *storageArray );
void SgTypeSignedChar_resetValidFreepointers( );
unsigned long SgTypeSignedChar_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeUnsignedChar_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeUnsignedChar* SgTypeUnsignedChar_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeUnsignedChar_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeUnsignedChar* SgTypeUnsignedChar_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeUnsignedChar* SgTypeUnsignedChar_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeUnsignedChar_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeUnsignedChar_clearMemoryPool ( );
void SgTypeUnsignedChar_extendMemoryPoolForFileIO ( );
unsigned long SgTypeUnsignedChar_initializeStorageClassArray( SgTypeUnsignedCharStorageClass *storageArray );
void SgTypeUnsignedChar_resetValidFreepointers( );
unsigned long SgTypeUnsignedChar_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeShort_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeShort* SgTypeShort_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeShort_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeShort* SgTypeShort_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeShort* SgTypeShort_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeShort_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeShort_clearMemoryPool ( );
void SgTypeShort_extendMemoryPoolForFileIO ( );
unsigned long SgTypeShort_initializeStorageClassArray( SgTypeShortStorageClass *storageArray );
void SgTypeShort_resetValidFreepointers( );
unsigned long SgTypeShort_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeSignedShort_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeSignedShort* SgTypeSignedShort_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeSignedShort_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeSignedShort* SgTypeSignedShort_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeSignedShort* SgTypeSignedShort_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeSignedShort_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeSignedShort_clearMemoryPool ( );
void SgTypeSignedShort_extendMemoryPoolForFileIO ( );
unsigned long SgTypeSignedShort_initializeStorageClassArray( SgTypeSignedShortStorageClass *storageArray );
void SgTypeSignedShort_resetValidFreepointers( );
unsigned long SgTypeSignedShort_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeUnsignedShort_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeUnsignedShort* SgTypeUnsignedShort_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeUnsignedShort_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeUnsignedShort* SgTypeUnsignedShort_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeUnsignedShort* SgTypeUnsignedShort_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeUnsignedShort_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeUnsignedShort_clearMemoryPool ( );
void SgTypeUnsignedShort_extendMemoryPoolForFileIO ( );
unsigned long SgTypeUnsignedShort_initializeStorageClassArray( SgTypeUnsignedShortStorageClass *storageArray );
void SgTypeUnsignedShort_resetValidFreepointers( );
unsigned long SgTypeUnsignedShort_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeInt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeInt* SgTypeInt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeInt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeInt* SgTypeInt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeInt* SgTypeInt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeInt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeInt_clearMemoryPool ( );
void SgTypeInt_extendMemoryPoolForFileIO ( );
unsigned long SgTypeInt_initializeStorageClassArray( SgTypeIntStorageClass *storageArray );
void SgTypeInt_resetValidFreepointers( );
unsigned long SgTypeInt_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeSignedInt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeSignedInt* SgTypeSignedInt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeSignedInt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeSignedInt* SgTypeSignedInt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeSignedInt* SgTypeSignedInt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeSignedInt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeSignedInt_clearMemoryPool ( );
void SgTypeSignedInt_extendMemoryPoolForFileIO ( );
unsigned long SgTypeSignedInt_initializeStorageClassArray( SgTypeSignedIntStorageClass *storageArray );
void SgTypeSignedInt_resetValidFreepointers( );
unsigned long SgTypeSignedInt_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeUnsignedInt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeUnsignedInt* SgTypeUnsignedInt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeUnsignedInt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeUnsignedInt* SgTypeUnsignedInt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeUnsignedInt* SgTypeUnsignedInt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeUnsignedInt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeUnsignedInt_clearMemoryPool ( );
void SgTypeUnsignedInt_extendMemoryPoolForFileIO ( );
unsigned long SgTypeUnsignedInt_initializeStorageClassArray( SgTypeUnsignedIntStorageClass *storageArray );
void SgTypeUnsignedInt_resetValidFreepointers( );
unsigned long SgTypeUnsignedInt_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeLong_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeLong* SgTypeLong_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeLong_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeLong* SgTypeLong_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeLong* SgTypeLong_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeLong_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeLong_clearMemoryPool ( );
void SgTypeLong_extendMemoryPoolForFileIO ( );
unsigned long SgTypeLong_initializeStorageClassArray( SgTypeLongStorageClass *storageArray );
void SgTypeLong_resetValidFreepointers( );
unsigned long SgTypeLong_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeSignedLong_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeSignedLong* SgTypeSignedLong_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeSignedLong_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeSignedLong* SgTypeSignedLong_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeSignedLong* SgTypeSignedLong_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeSignedLong_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeSignedLong_clearMemoryPool ( );
void SgTypeSignedLong_extendMemoryPoolForFileIO ( );
unsigned long SgTypeSignedLong_initializeStorageClassArray( SgTypeSignedLongStorageClass *storageArray );
void SgTypeSignedLong_resetValidFreepointers( );
unsigned long SgTypeSignedLong_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeUnsignedLong_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeUnsignedLong* SgTypeUnsignedLong_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeUnsignedLong_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeUnsignedLong* SgTypeUnsignedLong_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeUnsignedLong* SgTypeUnsignedLong_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeUnsignedLong_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeUnsignedLong_clearMemoryPool ( );
void SgTypeUnsignedLong_extendMemoryPoolForFileIO ( );
unsigned long SgTypeUnsignedLong_initializeStorageClassArray( SgTypeUnsignedLongStorageClass *storageArray );
void SgTypeUnsignedLong_resetValidFreepointers( );
unsigned long SgTypeUnsignedLong_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeVoid_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeVoid* SgTypeVoid_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeVoid_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeVoid* SgTypeVoid_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeVoid* SgTypeVoid_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeVoid_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeVoid_clearMemoryPool ( );
void SgTypeVoid_extendMemoryPoolForFileIO ( );
unsigned long SgTypeVoid_initializeStorageClassArray( SgTypeVoidStorageClass *storageArray );
void SgTypeVoid_resetValidFreepointers( );
unsigned long SgTypeVoid_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeGlobalVoid_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeGlobalVoid* SgTypeGlobalVoid_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeGlobalVoid_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeGlobalVoid* SgTypeGlobalVoid_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeGlobalVoid* SgTypeGlobalVoid_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeGlobalVoid_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeGlobalVoid_clearMemoryPool ( );
void SgTypeGlobalVoid_extendMemoryPoolForFileIO ( );
unsigned long SgTypeGlobalVoid_initializeStorageClassArray( SgTypeGlobalVoidStorageClass *storageArray );
void SgTypeGlobalVoid_resetValidFreepointers( );
unsigned long SgTypeGlobalVoid_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeWchar_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeWchar* SgTypeWchar_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeWchar_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeWchar* SgTypeWchar_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeWchar* SgTypeWchar_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeWchar_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeWchar_clearMemoryPool ( );
void SgTypeWchar_extendMemoryPoolForFileIO ( );
unsigned long SgTypeWchar_initializeStorageClassArray( SgTypeWcharStorageClass *storageArray );
void SgTypeWchar_resetValidFreepointers( );
unsigned long SgTypeWchar_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeFloat_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeFloat* SgTypeFloat_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeFloat_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeFloat* SgTypeFloat_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeFloat* SgTypeFloat_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeFloat_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeFloat_clearMemoryPool ( );
void SgTypeFloat_extendMemoryPoolForFileIO ( );
unsigned long SgTypeFloat_initializeStorageClassArray( SgTypeFloatStorageClass *storageArray );
void SgTypeFloat_resetValidFreepointers( );
unsigned long SgTypeFloat_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeDouble_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeDouble* SgTypeDouble_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeDouble_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeDouble* SgTypeDouble_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeDouble* SgTypeDouble_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeDouble_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeDouble_clearMemoryPool ( );
void SgTypeDouble_extendMemoryPoolForFileIO ( );
unsigned long SgTypeDouble_initializeStorageClassArray( SgTypeDoubleStorageClass *storageArray );
void SgTypeDouble_resetValidFreepointers( );
unsigned long SgTypeDouble_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeLongLong_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeLongLong* SgTypeLongLong_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeLongLong_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeLongLong* SgTypeLongLong_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeLongLong* SgTypeLongLong_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeLongLong_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeLongLong_clearMemoryPool ( );
void SgTypeLongLong_extendMemoryPoolForFileIO ( );
unsigned long SgTypeLongLong_initializeStorageClassArray( SgTypeLongLongStorageClass *storageArray );
void SgTypeLongLong_resetValidFreepointers( );
unsigned long SgTypeLongLong_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeSignedLongLong_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeSignedLongLong* SgTypeSignedLongLong_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeSignedLongLong_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeSignedLongLong* SgTypeSignedLongLong_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeSignedLongLong* SgTypeSignedLongLong_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeSignedLongLong_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeSignedLongLong_clearMemoryPool ( );
void SgTypeSignedLongLong_extendMemoryPoolForFileIO ( );
unsigned long SgTypeSignedLongLong_initializeStorageClassArray( SgTypeSignedLongLongStorageClass *storageArray );
void SgTypeSignedLongLong_resetValidFreepointers( );
unsigned long SgTypeSignedLongLong_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeUnsignedLongLong_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeUnsignedLongLong* SgTypeUnsignedLongLong_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeUnsignedLongLong_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeUnsignedLongLong* SgTypeUnsignedLongLong_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeUnsignedLongLong* SgTypeUnsignedLongLong_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeUnsignedLongLong_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeUnsignedLongLong_clearMemoryPool ( );
void SgTypeUnsignedLongLong_extendMemoryPoolForFileIO ( );
unsigned long SgTypeUnsignedLongLong_initializeStorageClassArray( SgTypeUnsignedLongLongStorageClass *storageArray );
void SgTypeUnsignedLongLong_resetValidFreepointers( );
unsigned long SgTypeUnsignedLongLong_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeLongDouble_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeLongDouble* SgTypeLongDouble_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeLongDouble_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeLongDouble* SgTypeLongDouble_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeLongDouble* SgTypeLongDouble_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeLongDouble_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeLongDouble_clearMemoryPool ( );
void SgTypeLongDouble_extendMemoryPoolForFileIO ( );
unsigned long SgTypeLongDouble_initializeStorageClassArray( SgTypeLongDoubleStorageClass *storageArray );
void SgTypeLongDouble_resetValidFreepointers( );
unsigned long SgTypeLongDouble_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeString_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeString* SgTypeString_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeString_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeString* SgTypeString_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeString* SgTypeString_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeString_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeString_clearMemoryPool ( );
void SgTypeString_extendMemoryPoolForFileIO ( );
unsigned long SgTypeString_initializeStorageClassArray( SgTypeStringStorageClass *storageArray );
void SgTypeString_resetValidFreepointers( );
unsigned long SgTypeString_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeBool_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeBool* SgTypeBool_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeBool_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeBool* SgTypeBool_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeBool* SgTypeBool_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeBool_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeBool_clearMemoryPool ( );
void SgTypeBool_extendMemoryPoolForFileIO ( );
unsigned long SgTypeBool_initializeStorageClassArray( SgTypeBoolStorageClass *storageArray );
void SgTypeBool_resetValidFreepointers( );
unsigned long SgTypeBool_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgPointerType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgPointerType* SgPointerType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgPointerType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgPointerType* SgPointerType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgPointerType* SgPointerType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgPointerType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgPointerType_clearMemoryPool ( );
void SgPointerType_extendMemoryPoolForFileIO ( );
unsigned long SgPointerType_initializeStorageClassArray( SgPointerTypeStorageClass *storageArray );
void SgPointerType_resetValidFreepointers( );
unsigned long SgPointerType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgPointerMemberType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgPointerMemberType* SgPointerMemberType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgPointerMemberType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgPointerMemberType* SgPointerMemberType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgPointerMemberType* SgPointerMemberType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgPointerMemberType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgPointerMemberType_clearMemoryPool ( );
void SgPointerMemberType_extendMemoryPoolForFileIO ( );
unsigned long SgPointerMemberType_initializeStorageClassArray( SgPointerMemberTypeStorageClass *storageArray );
void SgPointerMemberType_resetValidFreepointers( );
unsigned long SgPointerMemberType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgReferenceType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgReferenceType* SgReferenceType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgReferenceType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgReferenceType* SgReferenceType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgReferenceType* SgReferenceType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgReferenceType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgReferenceType_clearMemoryPool ( );
void SgReferenceType_extendMemoryPoolForFileIO ( );
unsigned long SgReferenceType_initializeStorageClassArray( SgReferenceTypeStorageClass *storageArray );
void SgReferenceType_resetValidFreepointers( );
unsigned long SgReferenceType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNamedType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNamedType* SgNamedType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNamedType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNamedType* SgNamedType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNamedType* SgNamedType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNamedType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNamedType_clearMemoryPool ( );
void SgNamedType_extendMemoryPoolForFileIO ( );
unsigned long SgNamedType_initializeStorageClassArray( SgNamedTypeStorageClass *storageArray );
void SgNamedType_resetValidFreepointers( );
unsigned long SgNamedType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgClassType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgClassType* SgClassType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgClassType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgClassType* SgClassType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgClassType* SgClassType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgClassType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgClassType_clearMemoryPool ( );
void SgClassType_extendMemoryPoolForFileIO ( );
unsigned long SgClassType_initializeStorageClassArray( SgClassTypeStorageClass *storageArray );
void SgClassType_resetValidFreepointers( );
unsigned long SgClassType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJavaParameterizedType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJavaParameterizedType* SgJavaParameterizedType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJavaParameterizedType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJavaParameterizedType* SgJavaParameterizedType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJavaParameterizedType* SgJavaParameterizedType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJavaParameterizedType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJavaParameterizedType_clearMemoryPool ( );
void SgJavaParameterizedType_extendMemoryPoolForFileIO ( );
unsigned long SgJavaParameterizedType_initializeStorageClassArray( SgJavaParameterizedTypeStorageClass *storageArray );
void SgJavaParameterizedType_resetValidFreepointers( );
unsigned long SgJavaParameterizedType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgEnumType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgEnumType* SgEnumType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgEnumType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgEnumType* SgEnumType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgEnumType* SgEnumType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgEnumType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgEnumType_clearMemoryPool ( );
void SgEnumType_extendMemoryPoolForFileIO ( );
unsigned long SgEnumType_initializeStorageClassArray( SgEnumTypeStorageClass *storageArray );
void SgEnumType_resetValidFreepointers( );
unsigned long SgEnumType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypedefType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypedefType* SgTypedefType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypedefType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypedefType* SgTypedefType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypedefType* SgTypedefType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypedefType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypedefType_clearMemoryPool ( );
void SgTypedefType_extendMemoryPoolForFileIO ( );
unsigned long SgTypedefType_initializeStorageClassArray( SgTypedefTypeStorageClass *storageArray );
void SgTypedefType_resetValidFreepointers( );
unsigned long SgTypedefType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgModifierType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgModifierType* SgModifierType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgModifierType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgModifierType* SgModifierType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgModifierType* SgModifierType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgModifierType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgModifierType_clearMemoryPool ( );
void SgModifierType_extendMemoryPoolForFileIO ( );
unsigned long SgModifierType_initializeStorageClassArray( SgModifierTypeStorageClass *storageArray );
void SgModifierType_resetValidFreepointers( );
unsigned long SgModifierType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFunctionType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFunctionType* SgFunctionType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFunctionType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFunctionType* SgFunctionType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFunctionType* SgFunctionType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFunctionType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFunctionType_clearMemoryPool ( );
void SgFunctionType_extendMemoryPoolForFileIO ( );
unsigned long SgFunctionType_initializeStorageClassArray( SgFunctionTypeStorageClass *storageArray );
void SgFunctionType_resetValidFreepointers( );
unsigned long SgFunctionType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgMemberFunctionType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgMemberFunctionType* SgMemberFunctionType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgMemberFunctionType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgMemberFunctionType* SgMemberFunctionType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgMemberFunctionType* SgMemberFunctionType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgMemberFunctionType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgMemberFunctionType_clearMemoryPool ( );
void SgMemberFunctionType_extendMemoryPoolForFileIO ( );
unsigned long SgMemberFunctionType_initializeStorageClassArray( SgMemberFunctionTypeStorageClass *storageArray );
void SgMemberFunctionType_resetValidFreepointers( );
unsigned long SgMemberFunctionType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgPartialFunctionType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgPartialFunctionType* SgPartialFunctionType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgPartialFunctionType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgPartialFunctionType* SgPartialFunctionType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgPartialFunctionType* SgPartialFunctionType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgPartialFunctionType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgPartialFunctionType_clearMemoryPool ( );
void SgPartialFunctionType_extendMemoryPoolForFileIO ( );
unsigned long SgPartialFunctionType_initializeStorageClassArray( SgPartialFunctionTypeStorageClass *storageArray );
void SgPartialFunctionType_resetValidFreepointers( );
unsigned long SgPartialFunctionType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgPartialFunctionModifierType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgPartialFunctionModifierType* SgPartialFunctionModifierType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgPartialFunctionModifierType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgPartialFunctionModifierType* SgPartialFunctionModifierType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgPartialFunctionModifierType* SgPartialFunctionModifierType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgPartialFunctionModifierType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgPartialFunctionModifierType_clearMemoryPool ( );
void SgPartialFunctionModifierType_extendMemoryPoolForFileIO ( );
unsigned long SgPartialFunctionModifierType_initializeStorageClassArray( SgPartialFunctionModifierTypeStorageClass *storageArray );
void SgPartialFunctionModifierType_resetValidFreepointers( );
unsigned long SgPartialFunctionModifierType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgArrayType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgArrayType* SgArrayType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgArrayType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgArrayType* SgArrayType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgArrayType* SgArrayType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgArrayType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgArrayType_clearMemoryPool ( );
void SgArrayType_extendMemoryPoolForFileIO ( );
unsigned long SgArrayType_initializeStorageClassArray( SgArrayTypeStorageClass *storageArray );
void SgArrayType_resetValidFreepointers( );
unsigned long SgArrayType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeEllipse_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeEllipse* SgTypeEllipse_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeEllipse_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeEllipse* SgTypeEllipse_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeEllipse* SgTypeEllipse_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeEllipse_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeEllipse_clearMemoryPool ( );
void SgTypeEllipse_extendMemoryPoolForFileIO ( );
unsigned long SgTypeEllipse_initializeStorageClassArray( SgTypeEllipseStorageClass *storageArray );
void SgTypeEllipse_resetValidFreepointers( );
unsigned long SgTypeEllipse_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateType* SgTemplateType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateType* SgTemplateType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateType* SgTemplateType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateType_clearMemoryPool ( );
void SgTemplateType_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateType_initializeStorageClassArray( SgTemplateTypeStorageClass *storageArray );
void SgTemplateType_resetValidFreepointers( );
unsigned long SgTemplateType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgQualifiedNameType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgQualifiedNameType* SgQualifiedNameType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgQualifiedNameType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgQualifiedNameType* SgQualifiedNameType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgQualifiedNameType* SgQualifiedNameType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgQualifiedNameType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgQualifiedNameType_clearMemoryPool ( );
void SgQualifiedNameType_extendMemoryPoolForFileIO ( );
unsigned long SgQualifiedNameType_initializeStorageClassArray( SgQualifiedNameTypeStorageClass *storageArray );
void SgQualifiedNameType_resetValidFreepointers( );
unsigned long SgQualifiedNameType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeComplex_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeComplex* SgTypeComplex_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeComplex_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeComplex* SgTypeComplex_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeComplex* SgTypeComplex_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeComplex_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeComplex_clearMemoryPool ( );
void SgTypeComplex_extendMemoryPoolForFileIO ( );
unsigned long SgTypeComplex_initializeStorageClassArray( SgTypeComplexStorageClass *storageArray );
void SgTypeComplex_resetValidFreepointers( );
unsigned long SgTypeComplex_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeImaginary_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeImaginary* SgTypeImaginary_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeImaginary_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeImaginary* SgTypeImaginary_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeImaginary* SgTypeImaginary_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeImaginary_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeImaginary_clearMemoryPool ( );
void SgTypeImaginary_extendMemoryPoolForFileIO ( );
unsigned long SgTypeImaginary_initializeStorageClassArray( SgTypeImaginaryStorageClass *storageArray );
void SgTypeImaginary_resetValidFreepointers( );
unsigned long SgTypeImaginary_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeDefault_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeDefault* SgTypeDefault_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeDefault_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeDefault* SgTypeDefault_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeDefault* SgTypeDefault_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeDefault_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeDefault_clearMemoryPool ( );
void SgTypeDefault_extendMemoryPoolForFileIO ( );
unsigned long SgTypeDefault_initializeStorageClassArray( SgTypeDefaultStorageClass *storageArray );
void SgTypeDefault_resetValidFreepointers( );
unsigned long SgTypeDefault_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeCAFTeam_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeCAFTeam* SgTypeCAFTeam_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeCAFTeam_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeCAFTeam* SgTypeCAFTeam_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeCAFTeam* SgTypeCAFTeam_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeCAFTeam_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeCAFTeam_clearMemoryPool ( );
void SgTypeCAFTeam_extendMemoryPoolForFileIO ( );
unsigned long SgTypeCAFTeam_initializeStorageClassArray( SgTypeCAFTeamStorageClass *storageArray );
void SgTypeCAFTeam_resetValidFreepointers( );
unsigned long SgTypeCAFTeam_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeCrayPointer_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeCrayPointer* SgTypeCrayPointer_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeCrayPointer_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeCrayPointer* SgTypeCrayPointer_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeCrayPointer* SgTypeCrayPointer_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeCrayPointer_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeCrayPointer_clearMemoryPool ( );
void SgTypeCrayPointer_extendMemoryPoolForFileIO ( );
unsigned long SgTypeCrayPointer_initializeStorageClassArray( SgTypeCrayPointerStorageClass *storageArray );
void SgTypeCrayPointer_resetValidFreepointers( );
unsigned long SgTypeCrayPointer_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeLabel_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeLabel* SgTypeLabel_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeLabel_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeLabel* SgTypeLabel_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeLabel* SgTypeLabel_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeLabel_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeLabel_clearMemoryPool ( );
void SgTypeLabel_extendMemoryPoolForFileIO ( );
unsigned long SgTypeLabel_initializeStorageClassArray( SgTypeLabelStorageClass *storageArray );
void SgTypeLabel_resetValidFreepointers( );
unsigned long SgTypeLabel_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLocatedNode_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLocatedNode* SgLocatedNode_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLocatedNode_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLocatedNode* SgLocatedNode_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLocatedNode* SgLocatedNode_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLocatedNode_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLocatedNode_clearMemoryPool ( );
void SgLocatedNode_extendMemoryPoolForFileIO ( );
unsigned long SgLocatedNode_initializeStorageClassArray( SgLocatedNodeStorageClass *storageArray );
void SgLocatedNode_resetValidFreepointers( );
unsigned long SgLocatedNode_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLocatedNodeSupport_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLocatedNodeSupport* SgLocatedNodeSupport_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLocatedNodeSupport_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLocatedNodeSupport* SgLocatedNodeSupport_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLocatedNodeSupport* SgLocatedNodeSupport_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLocatedNodeSupport_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLocatedNodeSupport_clearMemoryPool ( );
void SgLocatedNodeSupport_extendMemoryPoolForFileIO ( );
unsigned long SgLocatedNodeSupport_initializeStorageClassArray( SgLocatedNodeSupportStorageClass *storageArray );
void SgLocatedNodeSupport_resetValidFreepointers( );
unsigned long SgLocatedNodeSupport_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCommonBlockObject_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCommonBlockObject* SgCommonBlockObject_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCommonBlockObject_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCommonBlockObject* SgCommonBlockObject_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCommonBlockObject* SgCommonBlockObject_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCommonBlockObject_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCommonBlockObject_clearMemoryPool ( );
void SgCommonBlockObject_extendMemoryPoolForFileIO ( );
unsigned long SgCommonBlockObject_initializeStorageClassArray( SgCommonBlockObjectStorageClass *storageArray );
void SgCommonBlockObject_resetValidFreepointers( );
unsigned long SgCommonBlockObject_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgInitializedName_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgInitializedName* SgInitializedName_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgInitializedName_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgInitializedName* SgInitializedName_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgInitializedName* SgInitializedName_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgInitializedName_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgInitializedName_clearMemoryPool ( );
void SgInitializedName_extendMemoryPoolForFileIO ( );
unsigned long SgInitializedName_initializeStorageClassArray( SgInitializedNameStorageClass *storageArray );
void SgInitializedName_resetValidFreepointers( );
unsigned long SgInitializedName_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgInterfaceBody_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgInterfaceBody* SgInterfaceBody_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgInterfaceBody_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgInterfaceBody* SgInterfaceBody_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgInterfaceBody* SgInterfaceBody_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgInterfaceBody_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgInterfaceBody_clearMemoryPool ( );
void SgInterfaceBody_extendMemoryPoolForFileIO ( );
unsigned long SgInterfaceBody_initializeStorageClassArray( SgInterfaceBodyStorageClass *storageArray );
void SgInterfaceBody_resetValidFreepointers( );
unsigned long SgInterfaceBody_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgHeaderFileBody_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgHeaderFileBody* SgHeaderFileBody_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgHeaderFileBody_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgHeaderFileBody* SgHeaderFileBody_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgHeaderFileBody* SgHeaderFileBody_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgHeaderFileBody_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgHeaderFileBody_clearMemoryPool ( );
void SgHeaderFileBody_extendMemoryPoolForFileIO ( );
unsigned long SgHeaderFileBody_initializeStorageClassArray( SgHeaderFileBodyStorageClass *storageArray );
void SgHeaderFileBody_resetValidFreepointers( );
unsigned long SgHeaderFileBody_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgRenamePair_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgRenamePair* SgRenamePair_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgRenamePair_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgRenamePair* SgRenamePair_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgRenamePair* SgRenamePair_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgRenamePair_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgRenamePair_clearMemoryPool ( );
void SgRenamePair_extendMemoryPoolForFileIO ( );
unsigned long SgRenamePair_initializeStorageClassArray( SgRenamePairStorageClass *storageArray );
void SgRenamePair_resetValidFreepointers( );
unsigned long SgRenamePair_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpClause* SgOmpClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpClause* SgOmpClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpClause* SgOmpClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpClause_clearMemoryPool ( );
void SgOmpClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpClause_initializeStorageClassArray( SgOmpClauseStorageClass *storageArray );
void SgOmpClause_resetValidFreepointers( );
unsigned long SgOmpClause_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpOrderedClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpOrderedClause* SgOmpOrderedClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpOrderedClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpOrderedClause* SgOmpOrderedClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpOrderedClause* SgOmpOrderedClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpOrderedClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpOrderedClause_clearMemoryPool ( );
void SgOmpOrderedClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpOrderedClause_initializeStorageClassArray( SgOmpOrderedClauseStorageClass *storageArray );
void SgOmpOrderedClause_resetValidFreepointers( );
unsigned long SgOmpOrderedClause_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpNowaitClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpNowaitClause* SgOmpNowaitClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpNowaitClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpNowaitClause* SgOmpNowaitClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpNowaitClause* SgOmpNowaitClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpNowaitClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpNowaitClause_clearMemoryPool ( );
void SgOmpNowaitClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpNowaitClause_initializeStorageClassArray( SgOmpNowaitClauseStorageClass *storageArray );
void SgOmpNowaitClause_resetValidFreepointers( );
unsigned long SgOmpNowaitClause_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpUntiedClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpUntiedClause* SgOmpUntiedClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpUntiedClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpUntiedClause* SgOmpUntiedClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpUntiedClause* SgOmpUntiedClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpUntiedClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpUntiedClause_clearMemoryPool ( );
void SgOmpUntiedClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpUntiedClause_initializeStorageClassArray( SgOmpUntiedClauseStorageClass *storageArray );
void SgOmpUntiedClause_resetValidFreepointers( );
unsigned long SgOmpUntiedClause_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpDefaultClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpDefaultClause* SgOmpDefaultClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpDefaultClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpDefaultClause* SgOmpDefaultClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpDefaultClause* SgOmpDefaultClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpDefaultClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpDefaultClause_clearMemoryPool ( );
void SgOmpDefaultClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpDefaultClause_initializeStorageClassArray( SgOmpDefaultClauseStorageClass *storageArray );
void SgOmpDefaultClause_resetValidFreepointers( );
unsigned long SgOmpDefaultClause_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpExpressionClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpExpressionClause* SgOmpExpressionClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpExpressionClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpExpressionClause* SgOmpExpressionClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpExpressionClause* SgOmpExpressionClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpExpressionClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpExpressionClause_clearMemoryPool ( );
void SgOmpExpressionClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpExpressionClause_initializeStorageClassArray( SgOmpExpressionClauseStorageClass *storageArray );
void SgOmpExpressionClause_resetValidFreepointers( );
unsigned long SgOmpExpressionClause_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpCollapseClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpCollapseClause* SgOmpCollapseClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpCollapseClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpCollapseClause* SgOmpCollapseClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpCollapseClause* SgOmpCollapseClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpCollapseClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpCollapseClause_clearMemoryPool ( );
void SgOmpCollapseClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpCollapseClause_initializeStorageClassArray( SgOmpCollapseClauseStorageClass *storageArray );
void SgOmpCollapseClause_resetValidFreepointers( );
unsigned long SgOmpCollapseClause_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpIfClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpIfClause* SgOmpIfClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpIfClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpIfClause* SgOmpIfClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpIfClause* SgOmpIfClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpIfClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpIfClause_clearMemoryPool ( );
void SgOmpIfClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpIfClause_initializeStorageClassArray( SgOmpIfClauseStorageClass *storageArray );
void SgOmpIfClause_resetValidFreepointers( );
unsigned long SgOmpIfClause_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpNumThreadsClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpNumThreadsClause* SgOmpNumThreadsClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpNumThreadsClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpNumThreadsClause* SgOmpNumThreadsClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpNumThreadsClause* SgOmpNumThreadsClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpNumThreadsClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpNumThreadsClause_clearMemoryPool ( );
void SgOmpNumThreadsClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpNumThreadsClause_initializeStorageClassArray( SgOmpNumThreadsClauseStorageClass *storageArray );
void SgOmpNumThreadsClause_resetValidFreepointers( );
unsigned long SgOmpNumThreadsClause_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpVariablesClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpVariablesClause* SgOmpVariablesClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpVariablesClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpVariablesClause* SgOmpVariablesClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpVariablesClause* SgOmpVariablesClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpVariablesClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpVariablesClause_clearMemoryPool ( );
void SgOmpVariablesClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpVariablesClause_initializeStorageClassArray( SgOmpVariablesClauseStorageClass *storageArray );
void SgOmpVariablesClause_resetValidFreepointers( );
unsigned long SgOmpVariablesClause_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpCopyprivateClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpCopyprivateClause* SgOmpCopyprivateClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpCopyprivateClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpCopyprivateClause* SgOmpCopyprivateClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpCopyprivateClause* SgOmpCopyprivateClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpCopyprivateClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpCopyprivateClause_clearMemoryPool ( );
void SgOmpCopyprivateClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpCopyprivateClause_initializeStorageClassArray( SgOmpCopyprivateClauseStorageClass *storageArray );
void SgOmpCopyprivateClause_resetValidFreepointers( );
unsigned long SgOmpCopyprivateClause_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpPrivateClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpPrivateClause* SgOmpPrivateClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpPrivateClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpPrivateClause* SgOmpPrivateClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpPrivateClause* SgOmpPrivateClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpPrivateClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpPrivateClause_clearMemoryPool ( );
void SgOmpPrivateClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpPrivateClause_initializeStorageClassArray( SgOmpPrivateClauseStorageClass *storageArray );
void SgOmpPrivateClause_resetValidFreepointers( );
unsigned long SgOmpPrivateClause_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpFirstprivateClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpFirstprivateClause* SgOmpFirstprivateClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpFirstprivateClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpFirstprivateClause* SgOmpFirstprivateClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpFirstprivateClause* SgOmpFirstprivateClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpFirstprivateClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpFirstprivateClause_clearMemoryPool ( );
void SgOmpFirstprivateClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpFirstprivateClause_initializeStorageClassArray( SgOmpFirstprivateClauseStorageClass *storageArray );
void SgOmpFirstprivateClause_resetValidFreepointers( );
unsigned long SgOmpFirstprivateClause_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpSharedClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpSharedClause* SgOmpSharedClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpSharedClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpSharedClause* SgOmpSharedClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpSharedClause* SgOmpSharedClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpSharedClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpSharedClause_clearMemoryPool ( );
void SgOmpSharedClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpSharedClause_initializeStorageClassArray( SgOmpSharedClauseStorageClass *storageArray );
void SgOmpSharedClause_resetValidFreepointers( );
unsigned long SgOmpSharedClause_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpCopyinClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpCopyinClause* SgOmpCopyinClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpCopyinClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpCopyinClause* SgOmpCopyinClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpCopyinClause* SgOmpCopyinClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpCopyinClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpCopyinClause_clearMemoryPool ( );
void SgOmpCopyinClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpCopyinClause_initializeStorageClassArray( SgOmpCopyinClauseStorageClass *storageArray );
void SgOmpCopyinClause_resetValidFreepointers( );
unsigned long SgOmpCopyinClause_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpLastprivateClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpLastprivateClause* SgOmpLastprivateClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpLastprivateClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpLastprivateClause* SgOmpLastprivateClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpLastprivateClause* SgOmpLastprivateClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpLastprivateClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpLastprivateClause_clearMemoryPool ( );
void SgOmpLastprivateClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpLastprivateClause_initializeStorageClassArray( SgOmpLastprivateClauseStorageClass *storageArray );
void SgOmpLastprivateClause_resetValidFreepointers( );
unsigned long SgOmpLastprivateClause_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpReductionClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpReductionClause* SgOmpReductionClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpReductionClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpReductionClause* SgOmpReductionClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpReductionClause* SgOmpReductionClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpReductionClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpReductionClause_clearMemoryPool ( );
void SgOmpReductionClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpReductionClause_initializeStorageClassArray( SgOmpReductionClauseStorageClass *storageArray );
void SgOmpReductionClause_resetValidFreepointers( );
unsigned long SgOmpReductionClause_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpScheduleClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpScheduleClause* SgOmpScheduleClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpScheduleClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpScheduleClause* SgOmpScheduleClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpScheduleClause* SgOmpScheduleClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpScheduleClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpScheduleClause_clearMemoryPool ( );
void SgOmpScheduleClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpScheduleClause_initializeStorageClassArray( SgOmpScheduleClauseStorageClass *storageArray );
void SgOmpScheduleClause_resetValidFreepointers( );
unsigned long SgOmpScheduleClause_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgStatement* SgStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgStatement* SgStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgStatement* SgStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgStatement_clearMemoryPool ( );
void SgStatement_extendMemoryPoolForFileIO ( );
unsigned long SgStatement_initializeStorageClassArray( SgStatementStorageClass *storageArray );
void SgStatement_resetValidFreepointers( );
unsigned long SgStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgScopeStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgScopeStatement* SgScopeStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgScopeStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgScopeStatement* SgScopeStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgScopeStatement* SgScopeStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgScopeStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgScopeStatement_clearMemoryPool ( );
void SgScopeStatement_extendMemoryPoolForFileIO ( );
unsigned long SgScopeStatement_initializeStorageClassArray( SgScopeStatementStorageClass *storageArray );
void SgScopeStatement_resetValidFreepointers( );
unsigned long SgScopeStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgGlobal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgGlobal* SgGlobal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgGlobal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgGlobal* SgGlobal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgGlobal* SgGlobal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgGlobal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgGlobal_clearMemoryPool ( );
void SgGlobal_extendMemoryPoolForFileIO ( );
unsigned long SgGlobal_initializeStorageClassArray( SgGlobalStorageClass *storageArray );
void SgGlobal_resetValidFreepointers( );
unsigned long SgGlobal_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgBasicBlock_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgBasicBlock* SgBasicBlock_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgBasicBlock_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgBasicBlock* SgBasicBlock_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgBasicBlock* SgBasicBlock_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgBasicBlock_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgBasicBlock_clearMemoryPool ( );
void SgBasicBlock_extendMemoryPoolForFileIO ( );
unsigned long SgBasicBlock_initializeStorageClassArray( SgBasicBlockStorageClass *storageArray );
void SgBasicBlock_resetValidFreepointers( );
unsigned long SgBasicBlock_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIfStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIfStmt* SgIfStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIfStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIfStmt* SgIfStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIfStmt* SgIfStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIfStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIfStmt_clearMemoryPool ( );
void SgIfStmt_extendMemoryPoolForFileIO ( );
unsigned long SgIfStmt_initializeStorageClassArray( SgIfStmtStorageClass *storageArray );
void SgIfStmt_resetValidFreepointers( );
unsigned long SgIfStmt_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgForStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgForStatement* SgForStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgForStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgForStatement* SgForStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgForStatement* SgForStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgForStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgForStatement_clearMemoryPool ( );
void SgForStatement_extendMemoryPoolForFileIO ( );
unsigned long SgForStatement_initializeStorageClassArray( SgForStatementStorageClass *storageArray );
void SgForStatement_resetValidFreepointers( );
unsigned long SgForStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFunctionDefinition_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFunctionDefinition* SgFunctionDefinition_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFunctionDefinition_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFunctionDefinition* SgFunctionDefinition_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFunctionDefinition* SgFunctionDefinition_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFunctionDefinition_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFunctionDefinition_clearMemoryPool ( );
void SgFunctionDefinition_extendMemoryPoolForFileIO ( );
unsigned long SgFunctionDefinition_initializeStorageClassArray( SgFunctionDefinitionStorageClass *storageArray );
void SgFunctionDefinition_resetValidFreepointers( );
unsigned long SgFunctionDefinition_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateFunctionDefinition_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateFunctionDefinition* SgTemplateFunctionDefinition_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateFunctionDefinition_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateFunctionDefinition* SgTemplateFunctionDefinition_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateFunctionDefinition* SgTemplateFunctionDefinition_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateFunctionDefinition_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateFunctionDefinition_clearMemoryPool ( );
void SgTemplateFunctionDefinition_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateFunctionDefinition_initializeStorageClassArray( SgTemplateFunctionDefinitionStorageClass *storageArray );
void SgTemplateFunctionDefinition_resetValidFreepointers( );
unsigned long SgTemplateFunctionDefinition_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgClassDefinition_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgClassDefinition* SgClassDefinition_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgClassDefinition_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgClassDefinition* SgClassDefinition_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgClassDefinition* SgClassDefinition_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgClassDefinition_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgClassDefinition_clearMemoryPool ( );
void SgClassDefinition_extendMemoryPoolForFileIO ( );
unsigned long SgClassDefinition_initializeStorageClassArray( SgClassDefinitionStorageClass *storageArray );
void SgClassDefinition_resetValidFreepointers( );
unsigned long SgClassDefinition_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateInstantiationDefn_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateInstantiationDefn* SgTemplateInstantiationDefn_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateInstantiationDefn_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateInstantiationDefn* SgTemplateInstantiationDefn_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateInstantiationDefn* SgTemplateInstantiationDefn_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateInstantiationDefn_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateInstantiationDefn_clearMemoryPool ( );
void SgTemplateInstantiationDefn_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateInstantiationDefn_initializeStorageClassArray( SgTemplateInstantiationDefnStorageClass *storageArray );
void SgTemplateInstantiationDefn_resetValidFreepointers( );
unsigned long SgTemplateInstantiationDefn_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateClassDefinition_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateClassDefinition* SgTemplateClassDefinition_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateClassDefinition_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateClassDefinition* SgTemplateClassDefinition_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateClassDefinition* SgTemplateClassDefinition_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateClassDefinition_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateClassDefinition_clearMemoryPool ( );
void SgTemplateClassDefinition_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateClassDefinition_initializeStorageClassArray( SgTemplateClassDefinitionStorageClass *storageArray );
void SgTemplateClassDefinition_resetValidFreepointers( );
unsigned long SgTemplateClassDefinition_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgWhileStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgWhileStmt* SgWhileStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgWhileStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgWhileStmt* SgWhileStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgWhileStmt* SgWhileStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgWhileStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgWhileStmt_clearMemoryPool ( );
void SgWhileStmt_extendMemoryPoolForFileIO ( );
unsigned long SgWhileStmt_initializeStorageClassArray( SgWhileStmtStorageClass *storageArray );
void SgWhileStmt_resetValidFreepointers( );
unsigned long SgWhileStmt_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDoWhileStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDoWhileStmt* SgDoWhileStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDoWhileStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDoWhileStmt* SgDoWhileStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDoWhileStmt* SgDoWhileStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDoWhileStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDoWhileStmt_clearMemoryPool ( );
void SgDoWhileStmt_extendMemoryPoolForFileIO ( );
unsigned long SgDoWhileStmt_initializeStorageClassArray( SgDoWhileStmtStorageClass *storageArray );
void SgDoWhileStmt_resetValidFreepointers( );
unsigned long SgDoWhileStmt_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgSwitchStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgSwitchStatement* SgSwitchStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgSwitchStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgSwitchStatement* SgSwitchStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgSwitchStatement* SgSwitchStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgSwitchStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgSwitchStatement_clearMemoryPool ( );
void SgSwitchStatement_extendMemoryPoolForFileIO ( );
unsigned long SgSwitchStatement_initializeStorageClassArray( SgSwitchStatementStorageClass *storageArray );
void SgSwitchStatement_resetValidFreepointers( );
unsigned long SgSwitchStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCatchOptionStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCatchOptionStmt* SgCatchOptionStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCatchOptionStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCatchOptionStmt* SgCatchOptionStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCatchOptionStmt* SgCatchOptionStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCatchOptionStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCatchOptionStmt_clearMemoryPool ( );
void SgCatchOptionStmt_extendMemoryPoolForFileIO ( );
unsigned long SgCatchOptionStmt_initializeStorageClassArray( SgCatchOptionStmtStorageClass *storageArray );
void SgCatchOptionStmt_resetValidFreepointers( );
unsigned long SgCatchOptionStmt_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNamespaceDefinitionStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNamespaceDefinitionStatement* SgNamespaceDefinitionStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNamespaceDefinitionStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNamespaceDefinitionStatement* SgNamespaceDefinitionStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNamespaceDefinitionStatement* SgNamespaceDefinitionStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNamespaceDefinitionStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNamespaceDefinitionStatement_clearMemoryPool ( );
void SgNamespaceDefinitionStatement_extendMemoryPoolForFileIO ( );
unsigned long SgNamespaceDefinitionStatement_initializeStorageClassArray( SgNamespaceDefinitionStatementStorageClass *storageArray );
void SgNamespaceDefinitionStatement_resetValidFreepointers( );
unsigned long SgNamespaceDefinitionStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgBlockDataStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgBlockDataStatement* SgBlockDataStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgBlockDataStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgBlockDataStatement* SgBlockDataStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgBlockDataStatement* SgBlockDataStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgBlockDataStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgBlockDataStatement_clearMemoryPool ( );
void SgBlockDataStatement_extendMemoryPoolForFileIO ( );
unsigned long SgBlockDataStatement_initializeStorageClassArray( SgBlockDataStatementStorageClass *storageArray );
void SgBlockDataStatement_resetValidFreepointers( );
unsigned long SgBlockDataStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAssociateStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAssociateStatement* SgAssociateStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAssociateStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAssociateStatement* SgAssociateStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAssociateStatement* SgAssociateStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAssociateStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAssociateStatement_clearMemoryPool ( );
void SgAssociateStatement_extendMemoryPoolForFileIO ( );
unsigned long SgAssociateStatement_initializeStorageClassArray( SgAssociateStatementStorageClass *storageArray );
void SgAssociateStatement_resetValidFreepointers( );
unsigned long SgAssociateStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFortranDo_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFortranDo* SgFortranDo_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFortranDo_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFortranDo* SgFortranDo_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFortranDo* SgFortranDo_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFortranDo_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFortranDo_clearMemoryPool ( );
void SgFortranDo_extendMemoryPoolForFileIO ( );
unsigned long SgFortranDo_initializeStorageClassArray( SgFortranDoStorageClass *storageArray );
void SgFortranDo_resetValidFreepointers( );
unsigned long SgFortranDo_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFortranNonblockedDo_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFortranNonblockedDo* SgFortranNonblockedDo_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFortranNonblockedDo_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFortranNonblockedDo* SgFortranNonblockedDo_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFortranNonblockedDo* SgFortranNonblockedDo_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFortranNonblockedDo_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFortranNonblockedDo_clearMemoryPool ( );
void SgFortranNonblockedDo_extendMemoryPoolForFileIO ( );
unsigned long SgFortranNonblockedDo_initializeStorageClassArray( SgFortranNonblockedDoStorageClass *storageArray );
void SgFortranNonblockedDo_resetValidFreepointers( );
unsigned long SgFortranNonblockedDo_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgForAllStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgForAllStatement* SgForAllStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgForAllStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgForAllStatement* SgForAllStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgForAllStatement* SgForAllStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgForAllStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgForAllStatement_clearMemoryPool ( );
void SgForAllStatement_extendMemoryPoolForFileIO ( );
unsigned long SgForAllStatement_initializeStorageClassArray( SgForAllStatementStorageClass *storageArray );
void SgForAllStatement_resetValidFreepointers( );
unsigned long SgForAllStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUpcForAllStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUpcForAllStatement* SgUpcForAllStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUpcForAllStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUpcForAllStatement* SgUpcForAllStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUpcForAllStatement* SgUpcForAllStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUpcForAllStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUpcForAllStatement_clearMemoryPool ( );
void SgUpcForAllStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUpcForAllStatement_initializeStorageClassArray( SgUpcForAllStatementStorageClass *storageArray );
void SgUpcForAllStatement_resetValidFreepointers( );
unsigned long SgUpcForAllStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCAFWithTeamStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCAFWithTeamStatement* SgCAFWithTeamStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCAFWithTeamStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCAFWithTeamStatement* SgCAFWithTeamStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCAFWithTeamStatement* SgCAFWithTeamStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCAFWithTeamStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCAFWithTeamStatement_clearMemoryPool ( );
void SgCAFWithTeamStatement_extendMemoryPoolForFileIO ( );
unsigned long SgCAFWithTeamStatement_initializeStorageClassArray( SgCAFWithTeamStatementStorageClass *storageArray );
void SgCAFWithTeamStatement_resetValidFreepointers( );
unsigned long SgCAFWithTeamStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJavaForEachStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJavaForEachStatement* SgJavaForEachStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJavaForEachStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJavaForEachStatement* SgJavaForEachStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJavaForEachStatement* SgJavaForEachStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJavaForEachStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJavaForEachStatement_clearMemoryPool ( );
void SgJavaForEachStatement_extendMemoryPoolForFileIO ( );
unsigned long SgJavaForEachStatement_initializeStorageClassArray( SgJavaForEachStatementStorageClass *storageArray );
void SgJavaForEachStatement_resetValidFreepointers( );
unsigned long SgJavaForEachStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJavaLabelStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJavaLabelStatement* SgJavaLabelStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJavaLabelStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJavaLabelStatement* SgJavaLabelStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJavaLabelStatement* SgJavaLabelStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJavaLabelStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJavaLabelStatement_clearMemoryPool ( );
void SgJavaLabelStatement_extendMemoryPoolForFileIO ( );
unsigned long SgJavaLabelStatement_initializeStorageClassArray( SgJavaLabelStatementStorageClass *storageArray );
void SgJavaLabelStatement_resetValidFreepointers( );
unsigned long SgJavaLabelStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFunctionTypeTable_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFunctionTypeTable* SgFunctionTypeTable_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFunctionTypeTable_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFunctionTypeTable* SgFunctionTypeTable_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFunctionTypeTable* SgFunctionTypeTable_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFunctionTypeTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFunctionTypeTable_clearMemoryPool ( );
void SgFunctionTypeTable_extendMemoryPoolForFileIO ( );
unsigned long SgFunctionTypeTable_initializeStorageClassArray( SgFunctionTypeTableStorageClass *storageArray );
void SgFunctionTypeTable_resetValidFreepointers( );
unsigned long SgFunctionTypeTable_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDeclarationStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDeclarationStatement* SgDeclarationStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDeclarationStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDeclarationStatement* SgDeclarationStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDeclarationStatement* SgDeclarationStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDeclarationStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDeclarationStatement_clearMemoryPool ( );
void SgDeclarationStatement_extendMemoryPoolForFileIO ( );
unsigned long SgDeclarationStatement_initializeStorageClassArray( SgDeclarationStatementStorageClass *storageArray );
void SgDeclarationStatement_resetValidFreepointers( );
unsigned long SgDeclarationStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFunctionParameterList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFunctionParameterList* SgFunctionParameterList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFunctionParameterList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFunctionParameterList* SgFunctionParameterList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFunctionParameterList* SgFunctionParameterList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFunctionParameterList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFunctionParameterList_clearMemoryPool ( );
void SgFunctionParameterList_extendMemoryPoolForFileIO ( );
unsigned long SgFunctionParameterList_initializeStorageClassArray( SgFunctionParameterListStorageClass *storageArray );
void SgFunctionParameterList_resetValidFreepointers( );
unsigned long SgFunctionParameterList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgVariableDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgVariableDeclaration* SgVariableDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgVariableDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgVariableDeclaration* SgVariableDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgVariableDeclaration* SgVariableDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgVariableDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgVariableDeclaration_clearMemoryPool ( );
void SgVariableDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgVariableDeclaration_initializeStorageClassArray( SgVariableDeclarationStorageClass *storageArray );
void SgVariableDeclaration_resetValidFreepointers( );
unsigned long SgVariableDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgVariableDefinition_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgVariableDefinition* SgVariableDefinition_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgVariableDefinition_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgVariableDefinition* SgVariableDefinition_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgVariableDefinition* SgVariableDefinition_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgVariableDefinition_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgVariableDefinition_clearMemoryPool ( );
void SgVariableDefinition_extendMemoryPoolForFileIO ( );
unsigned long SgVariableDefinition_initializeStorageClassArray( SgVariableDefinitionStorageClass *storageArray );
void SgVariableDefinition_resetValidFreepointers( );
unsigned long SgVariableDefinition_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgClinkageDeclarationStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgClinkageDeclarationStatement* SgClinkageDeclarationStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgClinkageDeclarationStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgClinkageDeclarationStatement* SgClinkageDeclarationStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgClinkageDeclarationStatement* SgClinkageDeclarationStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgClinkageDeclarationStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgClinkageDeclarationStatement_clearMemoryPool ( );
void SgClinkageDeclarationStatement_extendMemoryPoolForFileIO ( );
unsigned long SgClinkageDeclarationStatement_initializeStorageClassArray( SgClinkageDeclarationStatementStorageClass *storageArray );
void SgClinkageDeclarationStatement_resetValidFreepointers( );
unsigned long SgClinkageDeclarationStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgClinkageStartStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgClinkageStartStatement* SgClinkageStartStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgClinkageStartStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgClinkageStartStatement* SgClinkageStartStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgClinkageStartStatement* SgClinkageStartStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgClinkageStartStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgClinkageStartStatement_clearMemoryPool ( );
void SgClinkageStartStatement_extendMemoryPoolForFileIO ( );
unsigned long SgClinkageStartStatement_initializeStorageClassArray( SgClinkageStartStatementStorageClass *storageArray );
void SgClinkageStartStatement_resetValidFreepointers( );
unsigned long SgClinkageStartStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgClinkageEndStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgClinkageEndStatement* SgClinkageEndStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgClinkageEndStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgClinkageEndStatement* SgClinkageEndStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgClinkageEndStatement* SgClinkageEndStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgClinkageEndStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgClinkageEndStatement_clearMemoryPool ( );
void SgClinkageEndStatement_extendMemoryPoolForFileIO ( );
unsigned long SgClinkageEndStatement_initializeStorageClassArray( SgClinkageEndStatementStorageClass *storageArray );
void SgClinkageEndStatement_resetValidFreepointers( );
unsigned long SgClinkageEndStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgEnumDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgEnumDeclaration* SgEnumDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgEnumDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgEnumDeclaration* SgEnumDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgEnumDeclaration* SgEnumDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgEnumDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgEnumDeclaration_clearMemoryPool ( );
void SgEnumDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgEnumDeclaration_initializeStorageClassArray( SgEnumDeclarationStorageClass *storageArray );
void SgEnumDeclaration_resetValidFreepointers( );
unsigned long SgEnumDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmStmt* SgAsmStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmStmt* SgAsmStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmStmt* SgAsmStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmStmt_clearMemoryPool ( );
void SgAsmStmt_extendMemoryPoolForFileIO ( );
unsigned long SgAsmStmt_initializeStorageClassArray( SgAsmStmtStorageClass *storageArray );
void SgAsmStmt_resetValidFreepointers( );
unsigned long SgAsmStmt_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAttributeSpecificationStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAttributeSpecificationStatement* SgAttributeSpecificationStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAttributeSpecificationStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAttributeSpecificationStatement* SgAttributeSpecificationStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAttributeSpecificationStatement* SgAttributeSpecificationStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAttributeSpecificationStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAttributeSpecificationStatement_clearMemoryPool ( );
void SgAttributeSpecificationStatement_extendMemoryPoolForFileIO ( );
unsigned long SgAttributeSpecificationStatement_initializeStorageClassArray( SgAttributeSpecificationStatementStorageClass *storageArray );
void SgAttributeSpecificationStatement_resetValidFreepointers( );
unsigned long SgAttributeSpecificationStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFormatStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFormatStatement* SgFormatStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFormatStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFormatStatement* SgFormatStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFormatStatement* SgFormatStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFormatStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFormatStatement_clearMemoryPool ( );
void SgFormatStatement_extendMemoryPoolForFileIO ( );
unsigned long SgFormatStatement_initializeStorageClassArray( SgFormatStatementStorageClass *storageArray );
void SgFormatStatement_resetValidFreepointers( );
unsigned long SgFormatStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateDeclaration* SgTemplateDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateDeclaration* SgTemplateDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateDeclaration* SgTemplateDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateDeclaration_clearMemoryPool ( );
void SgTemplateDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateDeclaration_initializeStorageClassArray( SgTemplateDeclarationStorageClass *storageArray );
void SgTemplateDeclaration_resetValidFreepointers( );
unsigned long SgTemplateDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateClassDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateClassDeclaration* SgTemplateClassDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateClassDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateClassDeclaration* SgTemplateClassDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateClassDeclaration* SgTemplateClassDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateClassDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateClassDeclaration_clearMemoryPool ( );
void SgTemplateClassDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateClassDeclaration_initializeStorageClassArray( SgTemplateClassDeclarationStorageClass *storageArray );
void SgTemplateClassDeclaration_resetValidFreepointers( );
unsigned long SgTemplateClassDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateFunctionDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateFunctionDeclaration* SgTemplateFunctionDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateFunctionDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateFunctionDeclaration* SgTemplateFunctionDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateFunctionDeclaration* SgTemplateFunctionDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateFunctionDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateFunctionDeclaration_clearMemoryPool ( );
void SgTemplateFunctionDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateFunctionDeclaration_initializeStorageClassArray( SgTemplateFunctionDeclarationStorageClass *storageArray );
void SgTemplateFunctionDeclaration_resetValidFreepointers( );
unsigned long SgTemplateFunctionDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateMemberFunctionDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateMemberFunctionDeclaration* SgTemplateMemberFunctionDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateMemberFunctionDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateMemberFunctionDeclaration* SgTemplateMemberFunctionDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateMemberFunctionDeclaration* SgTemplateMemberFunctionDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateMemberFunctionDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateMemberFunctionDeclaration_clearMemoryPool ( );
void SgTemplateMemberFunctionDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateMemberFunctionDeclaration_initializeStorageClassArray( SgTemplateMemberFunctionDeclarationStorageClass *storageArray );
void SgTemplateMemberFunctionDeclaration_resetValidFreepointers( );
unsigned long SgTemplateMemberFunctionDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateInstantiationDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateInstantiationDirectiveStatement* SgTemplateInstantiationDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateInstantiationDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateInstantiationDirectiveStatement* SgTemplateInstantiationDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateInstantiationDirectiveStatement* SgTemplateInstantiationDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateInstantiationDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateInstantiationDirectiveStatement_clearMemoryPool ( );
void SgTemplateInstantiationDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateInstantiationDirectiveStatement_initializeStorageClassArray( SgTemplateInstantiationDirectiveStatementStorageClass *storageArray );
void SgTemplateInstantiationDirectiveStatement_resetValidFreepointers( );
unsigned long SgTemplateInstantiationDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUseStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUseStatement* SgUseStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUseStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUseStatement* SgUseStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUseStatement* SgUseStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUseStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUseStatement_clearMemoryPool ( );
void SgUseStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUseStatement_initializeStorageClassArray( SgUseStatementStorageClass *storageArray );
void SgUseStatement_resetValidFreepointers( );
unsigned long SgUseStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgParameterStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgParameterStatement* SgParameterStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgParameterStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgParameterStatement* SgParameterStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgParameterStatement* SgParameterStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgParameterStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgParameterStatement_clearMemoryPool ( );
void SgParameterStatement_extendMemoryPoolForFileIO ( );
unsigned long SgParameterStatement_initializeStorageClassArray( SgParameterStatementStorageClass *storageArray );
void SgParameterStatement_resetValidFreepointers( );
unsigned long SgParameterStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNamespaceDeclarationStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNamespaceDeclarationStatement* SgNamespaceDeclarationStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNamespaceDeclarationStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNamespaceDeclarationStatement* SgNamespaceDeclarationStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNamespaceDeclarationStatement* SgNamespaceDeclarationStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNamespaceDeclarationStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNamespaceDeclarationStatement_clearMemoryPool ( );
void SgNamespaceDeclarationStatement_extendMemoryPoolForFileIO ( );
unsigned long SgNamespaceDeclarationStatement_initializeStorageClassArray( SgNamespaceDeclarationStatementStorageClass *storageArray );
void SgNamespaceDeclarationStatement_resetValidFreepointers( );
unsigned long SgNamespaceDeclarationStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgEquivalenceStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgEquivalenceStatement* SgEquivalenceStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgEquivalenceStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgEquivalenceStatement* SgEquivalenceStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgEquivalenceStatement* SgEquivalenceStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgEquivalenceStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgEquivalenceStatement_clearMemoryPool ( );
void SgEquivalenceStatement_extendMemoryPoolForFileIO ( );
unsigned long SgEquivalenceStatement_initializeStorageClassArray( SgEquivalenceStatementStorageClass *storageArray );
void SgEquivalenceStatement_resetValidFreepointers( );
unsigned long SgEquivalenceStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgInterfaceStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgInterfaceStatement* SgInterfaceStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgInterfaceStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgInterfaceStatement* SgInterfaceStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgInterfaceStatement* SgInterfaceStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgInterfaceStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgInterfaceStatement_clearMemoryPool ( );
void SgInterfaceStatement_extendMemoryPoolForFileIO ( );
unsigned long SgInterfaceStatement_initializeStorageClassArray( SgInterfaceStatementStorageClass *storageArray );
void SgInterfaceStatement_resetValidFreepointers( );
unsigned long SgInterfaceStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNamespaceAliasDeclarationStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNamespaceAliasDeclarationStatement* SgNamespaceAliasDeclarationStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNamespaceAliasDeclarationStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNamespaceAliasDeclarationStatement* SgNamespaceAliasDeclarationStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNamespaceAliasDeclarationStatement* SgNamespaceAliasDeclarationStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNamespaceAliasDeclarationStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNamespaceAliasDeclarationStatement_clearMemoryPool ( );
void SgNamespaceAliasDeclarationStatement_extendMemoryPoolForFileIO ( );
unsigned long SgNamespaceAliasDeclarationStatement_initializeStorageClassArray( SgNamespaceAliasDeclarationStatementStorageClass *storageArray );
void SgNamespaceAliasDeclarationStatement_resetValidFreepointers( );
unsigned long SgNamespaceAliasDeclarationStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCommonBlock_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCommonBlock* SgCommonBlock_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCommonBlock_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCommonBlock* SgCommonBlock_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCommonBlock* SgCommonBlock_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCommonBlock_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCommonBlock_clearMemoryPool ( );
void SgCommonBlock_extendMemoryPoolForFileIO ( );
unsigned long SgCommonBlock_initializeStorageClassArray( SgCommonBlockStorageClass *storageArray );
void SgCommonBlock_resetValidFreepointers( );
unsigned long SgCommonBlock_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypedefDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypedefDeclaration* SgTypedefDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypedefDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypedefDeclaration* SgTypedefDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypedefDeclaration* SgTypedefDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypedefDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypedefDeclaration_clearMemoryPool ( );
void SgTypedefDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgTypedefDeclaration_initializeStorageClassArray( SgTypedefDeclarationStorageClass *storageArray );
void SgTypedefDeclaration_resetValidFreepointers( );
unsigned long SgTypedefDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgStatementFunctionStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgStatementFunctionStatement* SgStatementFunctionStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgStatementFunctionStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgStatementFunctionStatement* SgStatementFunctionStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgStatementFunctionStatement* SgStatementFunctionStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgStatementFunctionStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgStatementFunctionStatement_clearMemoryPool ( );
void SgStatementFunctionStatement_extendMemoryPoolForFileIO ( );
unsigned long SgStatementFunctionStatement_initializeStorageClassArray( SgStatementFunctionStatementStorageClass *storageArray );
void SgStatementFunctionStatement_resetValidFreepointers( );
unsigned long SgStatementFunctionStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCtorInitializerList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCtorInitializerList* SgCtorInitializerList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCtorInitializerList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCtorInitializerList* SgCtorInitializerList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCtorInitializerList* SgCtorInitializerList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCtorInitializerList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCtorInitializerList_clearMemoryPool ( );
void SgCtorInitializerList_extendMemoryPoolForFileIO ( );
unsigned long SgCtorInitializerList_initializeStorageClassArray( SgCtorInitializerListStorageClass *storageArray );
void SgCtorInitializerList_resetValidFreepointers( );
unsigned long SgCtorInitializerList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgPragmaDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgPragmaDeclaration* SgPragmaDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgPragmaDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgPragmaDeclaration* SgPragmaDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgPragmaDeclaration* SgPragmaDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgPragmaDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgPragmaDeclaration_clearMemoryPool ( );
void SgPragmaDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgPragmaDeclaration_initializeStorageClassArray( SgPragmaDeclarationStorageClass *storageArray );
void SgPragmaDeclaration_resetValidFreepointers( );
unsigned long SgPragmaDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUsingDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUsingDirectiveStatement* SgUsingDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUsingDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUsingDirectiveStatement* SgUsingDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUsingDirectiveStatement* SgUsingDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUsingDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUsingDirectiveStatement_clearMemoryPool ( );
void SgUsingDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUsingDirectiveStatement_initializeStorageClassArray( SgUsingDirectiveStatementStorageClass *storageArray );
void SgUsingDirectiveStatement_resetValidFreepointers( );
unsigned long SgUsingDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgClassDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgClassDeclaration* SgClassDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgClassDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgClassDeclaration* SgClassDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgClassDeclaration* SgClassDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgClassDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgClassDeclaration_clearMemoryPool ( );
void SgClassDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgClassDeclaration_initializeStorageClassArray( SgClassDeclarationStorageClass *storageArray );
void SgClassDeclaration_resetValidFreepointers( );
unsigned long SgClassDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateInstantiationDecl_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateInstantiationDecl* SgTemplateInstantiationDecl_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateInstantiationDecl_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateInstantiationDecl* SgTemplateInstantiationDecl_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateInstantiationDecl* SgTemplateInstantiationDecl_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateInstantiationDecl_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateInstantiationDecl_clearMemoryPool ( );
void SgTemplateInstantiationDecl_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateInstantiationDecl_initializeStorageClassArray( SgTemplateInstantiationDeclStorageClass *storageArray );
void SgTemplateInstantiationDecl_resetValidFreepointers( );
unsigned long SgTemplateInstantiationDecl_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDerivedTypeStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDerivedTypeStatement* SgDerivedTypeStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDerivedTypeStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDerivedTypeStatement* SgDerivedTypeStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDerivedTypeStatement* SgDerivedTypeStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDerivedTypeStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDerivedTypeStatement_clearMemoryPool ( );
void SgDerivedTypeStatement_extendMemoryPoolForFileIO ( );
unsigned long SgDerivedTypeStatement_initializeStorageClassArray( SgDerivedTypeStatementStorageClass *storageArray );
void SgDerivedTypeStatement_resetValidFreepointers( );
unsigned long SgDerivedTypeStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgModuleStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgModuleStatement* SgModuleStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgModuleStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgModuleStatement* SgModuleStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgModuleStatement* SgModuleStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgModuleStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgModuleStatement_clearMemoryPool ( );
void SgModuleStatement_extendMemoryPoolForFileIO ( );
unsigned long SgModuleStatement_initializeStorageClassArray( SgModuleStatementStorageClass *storageArray );
void SgModuleStatement_resetValidFreepointers( );
unsigned long SgModuleStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgImplicitStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgImplicitStatement* SgImplicitStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgImplicitStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgImplicitStatement* SgImplicitStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgImplicitStatement* SgImplicitStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgImplicitStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgImplicitStatement_clearMemoryPool ( );
void SgImplicitStatement_extendMemoryPoolForFileIO ( );
unsigned long SgImplicitStatement_initializeStorageClassArray( SgImplicitStatementStorageClass *storageArray );
void SgImplicitStatement_resetValidFreepointers( );
unsigned long SgImplicitStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUsingDeclarationStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUsingDeclarationStatement* SgUsingDeclarationStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUsingDeclarationStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUsingDeclarationStatement* SgUsingDeclarationStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUsingDeclarationStatement* SgUsingDeclarationStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUsingDeclarationStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUsingDeclarationStatement_clearMemoryPool ( );
void SgUsingDeclarationStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUsingDeclarationStatement_initializeStorageClassArray( SgUsingDeclarationStatementStorageClass *storageArray );
void SgUsingDeclarationStatement_resetValidFreepointers( );
unsigned long SgUsingDeclarationStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNamelistStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNamelistStatement* SgNamelistStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNamelistStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNamelistStatement* SgNamelistStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNamelistStatement* SgNamelistStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNamelistStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNamelistStatement_clearMemoryPool ( );
void SgNamelistStatement_extendMemoryPoolForFileIO ( );
unsigned long SgNamelistStatement_initializeStorageClassArray( SgNamelistStatementStorageClass *storageArray );
void SgNamelistStatement_resetValidFreepointers( );
unsigned long SgNamelistStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgImportStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgImportStatement* SgImportStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgImportStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgImportStatement* SgImportStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgImportStatement* SgImportStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgImportStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgImportStatement_clearMemoryPool ( );
void SgImportStatement_extendMemoryPoolForFileIO ( );
unsigned long SgImportStatement_initializeStorageClassArray( SgImportStatementStorageClass *storageArray );
void SgImportStatement_resetValidFreepointers( );
unsigned long SgImportStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFunctionDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFunctionDeclaration* SgFunctionDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFunctionDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFunctionDeclaration* SgFunctionDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFunctionDeclaration* SgFunctionDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFunctionDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFunctionDeclaration_clearMemoryPool ( );
void SgFunctionDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgFunctionDeclaration_initializeStorageClassArray( SgFunctionDeclarationStorageClass *storageArray );
void SgFunctionDeclaration_resetValidFreepointers( );
unsigned long SgFunctionDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgMemberFunctionDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgMemberFunctionDeclaration* SgMemberFunctionDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgMemberFunctionDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgMemberFunctionDeclaration* SgMemberFunctionDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgMemberFunctionDeclaration* SgMemberFunctionDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgMemberFunctionDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgMemberFunctionDeclaration_clearMemoryPool ( );
void SgMemberFunctionDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgMemberFunctionDeclaration_initializeStorageClassArray( SgMemberFunctionDeclarationStorageClass *storageArray );
void SgMemberFunctionDeclaration_resetValidFreepointers( );
unsigned long SgMemberFunctionDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateInstantiationMemberFunctionDecl_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateInstantiationMemberFunctionDecl* SgTemplateInstantiationMemberFunctionDecl_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateInstantiationMemberFunctionDecl_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateInstantiationMemberFunctionDecl* SgTemplateInstantiationMemberFunctionDecl_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateInstantiationMemberFunctionDecl* SgTemplateInstantiationMemberFunctionDecl_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateInstantiationMemberFunctionDecl_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateInstantiationMemberFunctionDecl_clearMemoryPool ( );
void SgTemplateInstantiationMemberFunctionDecl_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateInstantiationMemberFunctionDecl_initializeStorageClassArray( SgTemplateInstantiationMemberFunctionDeclStorageClass *storageArray );
void SgTemplateInstantiationMemberFunctionDecl_resetValidFreepointers( );
unsigned long SgTemplateInstantiationMemberFunctionDecl_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateInstantiationFunctionDecl_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateInstantiationFunctionDecl* SgTemplateInstantiationFunctionDecl_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateInstantiationFunctionDecl_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateInstantiationFunctionDecl* SgTemplateInstantiationFunctionDecl_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateInstantiationFunctionDecl* SgTemplateInstantiationFunctionDecl_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateInstantiationFunctionDecl_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateInstantiationFunctionDecl_clearMemoryPool ( );
void SgTemplateInstantiationFunctionDecl_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateInstantiationFunctionDecl_initializeStorageClassArray( SgTemplateInstantiationFunctionDeclStorageClass *storageArray );
void SgTemplateInstantiationFunctionDecl_resetValidFreepointers( );
unsigned long SgTemplateInstantiationFunctionDecl_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgProgramHeaderStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgProgramHeaderStatement* SgProgramHeaderStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgProgramHeaderStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgProgramHeaderStatement* SgProgramHeaderStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgProgramHeaderStatement* SgProgramHeaderStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgProgramHeaderStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgProgramHeaderStatement_clearMemoryPool ( );
void SgProgramHeaderStatement_extendMemoryPoolForFileIO ( );
unsigned long SgProgramHeaderStatement_initializeStorageClassArray( SgProgramHeaderStatementStorageClass *storageArray );
void SgProgramHeaderStatement_resetValidFreepointers( );
unsigned long SgProgramHeaderStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgProcedureHeaderStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgProcedureHeaderStatement* SgProcedureHeaderStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgProcedureHeaderStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgProcedureHeaderStatement* SgProcedureHeaderStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgProcedureHeaderStatement* SgProcedureHeaderStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgProcedureHeaderStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgProcedureHeaderStatement_clearMemoryPool ( );
void SgProcedureHeaderStatement_extendMemoryPoolForFileIO ( );
unsigned long SgProcedureHeaderStatement_initializeStorageClassArray( SgProcedureHeaderStatementStorageClass *storageArray );
void SgProcedureHeaderStatement_resetValidFreepointers( );
unsigned long SgProcedureHeaderStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgEntryStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgEntryStatement* SgEntryStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgEntryStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgEntryStatement* SgEntryStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgEntryStatement* SgEntryStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgEntryStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgEntryStatement_clearMemoryPool ( );
void SgEntryStatement_extendMemoryPoolForFileIO ( );
unsigned long SgEntryStatement_initializeStorageClassArray( SgEntryStatementStorageClass *storageArray );
void SgEntryStatement_resetValidFreepointers( );
unsigned long SgEntryStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgContainsStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgContainsStatement* SgContainsStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgContainsStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgContainsStatement* SgContainsStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgContainsStatement* SgContainsStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgContainsStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgContainsStatement_clearMemoryPool ( );
void SgContainsStatement_extendMemoryPoolForFileIO ( );
unsigned long SgContainsStatement_initializeStorageClassArray( SgContainsStatementStorageClass *storageArray );
void SgContainsStatement_resetValidFreepointers( );
unsigned long SgContainsStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgC_PreprocessorDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgC_PreprocessorDirectiveStatement* SgC_PreprocessorDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgC_PreprocessorDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgC_PreprocessorDirectiveStatement* SgC_PreprocessorDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgC_PreprocessorDirectiveStatement* SgC_PreprocessorDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgC_PreprocessorDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgC_PreprocessorDirectiveStatement_clearMemoryPool ( );
void SgC_PreprocessorDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgC_PreprocessorDirectiveStatement_initializeStorageClassArray( SgC_PreprocessorDirectiveStatementStorageClass *storageArray );
void SgC_PreprocessorDirectiveStatement_resetValidFreepointers( );
unsigned long SgC_PreprocessorDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIncludeDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIncludeDirectiveStatement* SgIncludeDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIncludeDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIncludeDirectiveStatement* SgIncludeDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIncludeDirectiveStatement* SgIncludeDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIncludeDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIncludeDirectiveStatement_clearMemoryPool ( );
void SgIncludeDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgIncludeDirectiveStatement_initializeStorageClassArray( SgIncludeDirectiveStatementStorageClass *storageArray );
void SgIncludeDirectiveStatement_resetValidFreepointers( );
unsigned long SgIncludeDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDefineDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDefineDirectiveStatement* SgDefineDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDefineDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDefineDirectiveStatement* SgDefineDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDefineDirectiveStatement* SgDefineDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDefineDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDefineDirectiveStatement_clearMemoryPool ( );
void SgDefineDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgDefineDirectiveStatement_initializeStorageClassArray( SgDefineDirectiveStatementStorageClass *storageArray );
void SgDefineDirectiveStatement_resetValidFreepointers( );
unsigned long SgDefineDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUndefDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUndefDirectiveStatement* SgUndefDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUndefDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUndefDirectiveStatement* SgUndefDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUndefDirectiveStatement* SgUndefDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUndefDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUndefDirectiveStatement_clearMemoryPool ( );
void SgUndefDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUndefDirectiveStatement_initializeStorageClassArray( SgUndefDirectiveStatementStorageClass *storageArray );
void SgUndefDirectiveStatement_resetValidFreepointers( );
unsigned long SgUndefDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIfdefDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIfdefDirectiveStatement* SgIfdefDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIfdefDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIfdefDirectiveStatement* SgIfdefDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIfdefDirectiveStatement* SgIfdefDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIfdefDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIfdefDirectiveStatement_clearMemoryPool ( );
void SgIfdefDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgIfdefDirectiveStatement_initializeStorageClassArray( SgIfdefDirectiveStatementStorageClass *storageArray );
void SgIfdefDirectiveStatement_resetValidFreepointers( );
unsigned long SgIfdefDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIfndefDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIfndefDirectiveStatement* SgIfndefDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIfndefDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIfndefDirectiveStatement* SgIfndefDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIfndefDirectiveStatement* SgIfndefDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIfndefDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIfndefDirectiveStatement_clearMemoryPool ( );
void SgIfndefDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgIfndefDirectiveStatement_initializeStorageClassArray( SgIfndefDirectiveStatementStorageClass *storageArray );
void SgIfndefDirectiveStatement_resetValidFreepointers( );
unsigned long SgIfndefDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIfDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIfDirectiveStatement* SgIfDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIfDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIfDirectiveStatement* SgIfDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIfDirectiveStatement* SgIfDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIfDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIfDirectiveStatement_clearMemoryPool ( );
void SgIfDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgIfDirectiveStatement_initializeStorageClassArray( SgIfDirectiveStatementStorageClass *storageArray );
void SgIfDirectiveStatement_resetValidFreepointers( );
unsigned long SgIfDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDeadIfDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDeadIfDirectiveStatement* SgDeadIfDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDeadIfDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDeadIfDirectiveStatement* SgDeadIfDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDeadIfDirectiveStatement* SgDeadIfDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDeadIfDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDeadIfDirectiveStatement_clearMemoryPool ( );
void SgDeadIfDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgDeadIfDirectiveStatement_initializeStorageClassArray( SgDeadIfDirectiveStatementStorageClass *storageArray );
void SgDeadIfDirectiveStatement_resetValidFreepointers( );
unsigned long SgDeadIfDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgElseDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgElseDirectiveStatement* SgElseDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgElseDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgElseDirectiveStatement* SgElseDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgElseDirectiveStatement* SgElseDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgElseDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgElseDirectiveStatement_clearMemoryPool ( );
void SgElseDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgElseDirectiveStatement_initializeStorageClassArray( SgElseDirectiveStatementStorageClass *storageArray );
void SgElseDirectiveStatement_resetValidFreepointers( );
unsigned long SgElseDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgElseifDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgElseifDirectiveStatement* SgElseifDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgElseifDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgElseifDirectiveStatement* SgElseifDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgElseifDirectiveStatement* SgElseifDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgElseifDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgElseifDirectiveStatement_clearMemoryPool ( );
void SgElseifDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgElseifDirectiveStatement_initializeStorageClassArray( SgElseifDirectiveStatementStorageClass *storageArray );
void SgElseifDirectiveStatement_resetValidFreepointers( );
unsigned long SgElseifDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgEndifDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgEndifDirectiveStatement* SgEndifDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgEndifDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgEndifDirectiveStatement* SgEndifDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgEndifDirectiveStatement* SgEndifDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgEndifDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgEndifDirectiveStatement_clearMemoryPool ( );
void SgEndifDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgEndifDirectiveStatement_initializeStorageClassArray( SgEndifDirectiveStatementStorageClass *storageArray );
void SgEndifDirectiveStatement_resetValidFreepointers( );
unsigned long SgEndifDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLineDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLineDirectiveStatement* SgLineDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLineDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLineDirectiveStatement* SgLineDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLineDirectiveStatement* SgLineDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLineDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLineDirectiveStatement_clearMemoryPool ( );
void SgLineDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgLineDirectiveStatement_initializeStorageClassArray( SgLineDirectiveStatementStorageClass *storageArray );
void SgLineDirectiveStatement_resetValidFreepointers( );
unsigned long SgLineDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgWarningDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgWarningDirectiveStatement* SgWarningDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgWarningDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgWarningDirectiveStatement* SgWarningDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgWarningDirectiveStatement* SgWarningDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgWarningDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgWarningDirectiveStatement_clearMemoryPool ( );
void SgWarningDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgWarningDirectiveStatement_initializeStorageClassArray( SgWarningDirectiveStatementStorageClass *storageArray );
void SgWarningDirectiveStatement_resetValidFreepointers( );
unsigned long SgWarningDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgErrorDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgErrorDirectiveStatement* SgErrorDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgErrorDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgErrorDirectiveStatement* SgErrorDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgErrorDirectiveStatement* SgErrorDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgErrorDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgErrorDirectiveStatement_clearMemoryPool ( );
void SgErrorDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgErrorDirectiveStatement_initializeStorageClassArray( SgErrorDirectiveStatementStorageClass *storageArray );
void SgErrorDirectiveStatement_resetValidFreepointers( );
unsigned long SgErrorDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgEmptyDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgEmptyDirectiveStatement* SgEmptyDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgEmptyDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgEmptyDirectiveStatement* SgEmptyDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgEmptyDirectiveStatement* SgEmptyDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgEmptyDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgEmptyDirectiveStatement_clearMemoryPool ( );
void SgEmptyDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgEmptyDirectiveStatement_initializeStorageClassArray( SgEmptyDirectiveStatementStorageClass *storageArray );
void SgEmptyDirectiveStatement_resetValidFreepointers( );
unsigned long SgEmptyDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIncludeNextDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIncludeNextDirectiveStatement* SgIncludeNextDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIncludeNextDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIncludeNextDirectiveStatement* SgIncludeNextDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIncludeNextDirectiveStatement* SgIncludeNextDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIncludeNextDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIncludeNextDirectiveStatement_clearMemoryPool ( );
void SgIncludeNextDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgIncludeNextDirectiveStatement_initializeStorageClassArray( SgIncludeNextDirectiveStatementStorageClass *storageArray );
void SgIncludeNextDirectiveStatement_resetValidFreepointers( );
unsigned long SgIncludeNextDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIdentDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIdentDirectiveStatement* SgIdentDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIdentDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIdentDirectiveStatement* SgIdentDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIdentDirectiveStatement* SgIdentDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIdentDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIdentDirectiveStatement_clearMemoryPool ( );
void SgIdentDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgIdentDirectiveStatement_initializeStorageClassArray( SgIdentDirectiveStatementStorageClass *storageArray );
void SgIdentDirectiveStatement_resetValidFreepointers( );
unsigned long SgIdentDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLinemarkerDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLinemarkerDirectiveStatement* SgLinemarkerDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLinemarkerDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLinemarkerDirectiveStatement* SgLinemarkerDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLinemarkerDirectiveStatement* SgLinemarkerDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLinemarkerDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLinemarkerDirectiveStatement_clearMemoryPool ( );
void SgLinemarkerDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgLinemarkerDirectiveStatement_initializeStorageClassArray( SgLinemarkerDirectiveStatementStorageClass *storageArray );
void SgLinemarkerDirectiveStatement_resetValidFreepointers( );
unsigned long SgLinemarkerDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpThreadprivateStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpThreadprivateStatement* SgOmpThreadprivateStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpThreadprivateStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpThreadprivateStatement* SgOmpThreadprivateStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpThreadprivateStatement* SgOmpThreadprivateStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpThreadprivateStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpThreadprivateStatement_clearMemoryPool ( );
void SgOmpThreadprivateStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpThreadprivateStatement_initializeStorageClassArray( SgOmpThreadprivateStatementStorageClass *storageArray );
void SgOmpThreadprivateStatement_resetValidFreepointers( );
unsigned long SgOmpThreadprivateStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFortranIncludeLine_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFortranIncludeLine* SgFortranIncludeLine_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFortranIncludeLine_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFortranIncludeLine* SgFortranIncludeLine_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFortranIncludeLine* SgFortranIncludeLine_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFortranIncludeLine_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFortranIncludeLine_clearMemoryPool ( );
void SgFortranIncludeLine_extendMemoryPoolForFileIO ( );
unsigned long SgFortranIncludeLine_initializeStorageClassArray( SgFortranIncludeLineStorageClass *storageArray );
void SgFortranIncludeLine_resetValidFreepointers( );
unsigned long SgFortranIncludeLine_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJavaImportStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJavaImportStatement* SgJavaImportStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJavaImportStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJavaImportStatement* SgJavaImportStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJavaImportStatement* SgJavaImportStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJavaImportStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJavaImportStatement_clearMemoryPool ( );
void SgJavaImportStatement_extendMemoryPoolForFileIO ( );
unsigned long SgJavaImportStatement_initializeStorageClassArray( SgJavaImportStatementStorageClass *storageArray );
void SgJavaImportStatement_resetValidFreepointers( );
unsigned long SgJavaImportStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgStmtDeclarationStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgStmtDeclarationStatement* SgStmtDeclarationStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgStmtDeclarationStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgStmtDeclarationStatement* SgStmtDeclarationStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgStmtDeclarationStatement* SgStmtDeclarationStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgStmtDeclarationStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgStmtDeclarationStatement_clearMemoryPool ( );
void SgStmtDeclarationStatement_extendMemoryPoolForFileIO ( );
unsigned long SgStmtDeclarationStatement_initializeStorageClassArray( SgStmtDeclarationStatementStorageClass *storageArray );
void SgStmtDeclarationStatement_resetValidFreepointers( );
unsigned long SgStmtDeclarationStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgExprStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgExprStatement* SgExprStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgExprStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgExprStatement* SgExprStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgExprStatement* SgExprStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgExprStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgExprStatement_clearMemoryPool ( );
void SgExprStatement_extendMemoryPoolForFileIO ( );
unsigned long SgExprStatement_initializeStorageClassArray( SgExprStatementStorageClass *storageArray );
void SgExprStatement_resetValidFreepointers( );
unsigned long SgExprStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLabelStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLabelStatement* SgLabelStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLabelStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLabelStatement* SgLabelStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLabelStatement* SgLabelStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLabelStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLabelStatement_clearMemoryPool ( );
void SgLabelStatement_extendMemoryPoolForFileIO ( );
unsigned long SgLabelStatement_initializeStorageClassArray( SgLabelStatementStorageClass *storageArray );
void SgLabelStatement_resetValidFreepointers( );
unsigned long SgLabelStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCaseOptionStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCaseOptionStmt* SgCaseOptionStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCaseOptionStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCaseOptionStmt* SgCaseOptionStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCaseOptionStmt* SgCaseOptionStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCaseOptionStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCaseOptionStmt_clearMemoryPool ( );
void SgCaseOptionStmt_extendMemoryPoolForFileIO ( );
unsigned long SgCaseOptionStmt_initializeStorageClassArray( SgCaseOptionStmtStorageClass *storageArray );
void SgCaseOptionStmt_resetValidFreepointers( );
unsigned long SgCaseOptionStmt_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTryStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTryStmt* SgTryStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTryStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTryStmt* SgTryStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTryStmt* SgTryStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTryStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTryStmt_clearMemoryPool ( );
void SgTryStmt_extendMemoryPoolForFileIO ( );
unsigned long SgTryStmt_initializeStorageClassArray( SgTryStmtStorageClass *storageArray );
void SgTryStmt_resetValidFreepointers( );
unsigned long SgTryStmt_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDefaultOptionStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDefaultOptionStmt* SgDefaultOptionStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDefaultOptionStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDefaultOptionStmt* SgDefaultOptionStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDefaultOptionStmt* SgDefaultOptionStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDefaultOptionStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDefaultOptionStmt_clearMemoryPool ( );
void SgDefaultOptionStmt_extendMemoryPoolForFileIO ( );
unsigned long SgDefaultOptionStmt_initializeStorageClassArray( SgDefaultOptionStmtStorageClass *storageArray );
void SgDefaultOptionStmt_resetValidFreepointers( );
unsigned long SgDefaultOptionStmt_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgBreakStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgBreakStmt* SgBreakStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgBreakStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgBreakStmt* SgBreakStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgBreakStmt* SgBreakStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgBreakStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgBreakStmt_clearMemoryPool ( );
void SgBreakStmt_extendMemoryPoolForFileIO ( );
unsigned long SgBreakStmt_initializeStorageClassArray( SgBreakStmtStorageClass *storageArray );
void SgBreakStmt_resetValidFreepointers( );
unsigned long SgBreakStmt_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgContinueStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgContinueStmt* SgContinueStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgContinueStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgContinueStmt* SgContinueStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgContinueStmt* SgContinueStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgContinueStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgContinueStmt_clearMemoryPool ( );
void SgContinueStmt_extendMemoryPoolForFileIO ( );
unsigned long SgContinueStmt_initializeStorageClassArray( SgContinueStmtStorageClass *storageArray );
void SgContinueStmt_resetValidFreepointers( );
unsigned long SgContinueStmt_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgReturnStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgReturnStmt* SgReturnStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgReturnStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgReturnStmt* SgReturnStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgReturnStmt* SgReturnStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgReturnStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgReturnStmt_clearMemoryPool ( );
void SgReturnStmt_extendMemoryPoolForFileIO ( );
unsigned long SgReturnStmt_initializeStorageClassArray( SgReturnStmtStorageClass *storageArray );
void SgReturnStmt_resetValidFreepointers( );
unsigned long SgReturnStmt_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgGotoStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgGotoStatement* SgGotoStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgGotoStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgGotoStatement* SgGotoStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgGotoStatement* SgGotoStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgGotoStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgGotoStatement_clearMemoryPool ( );
void SgGotoStatement_extendMemoryPoolForFileIO ( );
unsigned long SgGotoStatement_initializeStorageClassArray( SgGotoStatementStorageClass *storageArray );
void SgGotoStatement_resetValidFreepointers( );
unsigned long SgGotoStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgSpawnStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgSpawnStmt* SgSpawnStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgSpawnStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgSpawnStmt* SgSpawnStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgSpawnStmt* SgSpawnStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgSpawnStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgSpawnStmt_clearMemoryPool ( );
void SgSpawnStmt_extendMemoryPoolForFileIO ( );
unsigned long SgSpawnStmt_initializeStorageClassArray( SgSpawnStmtStorageClass *storageArray );
void SgSpawnStmt_resetValidFreepointers( );
unsigned long SgSpawnStmt_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNullStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNullStatement* SgNullStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNullStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNullStatement* SgNullStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNullStatement* SgNullStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNullStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNullStatement_clearMemoryPool ( );
void SgNullStatement_extendMemoryPoolForFileIO ( );
unsigned long SgNullStatement_initializeStorageClassArray( SgNullStatementStorageClass *storageArray );
void SgNullStatement_resetValidFreepointers( );
unsigned long SgNullStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgVariantStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgVariantStatement* SgVariantStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgVariantStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgVariantStatement* SgVariantStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgVariantStatement* SgVariantStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgVariantStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgVariantStatement_clearMemoryPool ( );
void SgVariantStatement_extendMemoryPoolForFileIO ( );
unsigned long SgVariantStatement_initializeStorageClassArray( SgVariantStatementStorageClass *storageArray );
void SgVariantStatement_resetValidFreepointers( );
unsigned long SgVariantStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgForInitStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgForInitStatement* SgForInitStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgForInitStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgForInitStatement* SgForInitStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgForInitStatement* SgForInitStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgForInitStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgForInitStatement_clearMemoryPool ( );
void SgForInitStatement_extendMemoryPoolForFileIO ( );
unsigned long SgForInitStatement_initializeStorageClassArray( SgForInitStatementStorageClass *storageArray );
void SgForInitStatement_resetValidFreepointers( );
unsigned long SgForInitStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCatchStatementSeq_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCatchStatementSeq* SgCatchStatementSeq_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCatchStatementSeq_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCatchStatementSeq* SgCatchStatementSeq_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCatchStatementSeq* SgCatchStatementSeq_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCatchStatementSeq_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCatchStatementSeq_clearMemoryPool ( );
void SgCatchStatementSeq_extendMemoryPoolForFileIO ( );
unsigned long SgCatchStatementSeq_initializeStorageClassArray( SgCatchStatementSeqStorageClass *storageArray );
void SgCatchStatementSeq_resetValidFreepointers( );
unsigned long SgCatchStatementSeq_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgStopOrPauseStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgStopOrPauseStatement* SgStopOrPauseStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgStopOrPauseStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgStopOrPauseStatement* SgStopOrPauseStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgStopOrPauseStatement* SgStopOrPauseStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgStopOrPauseStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgStopOrPauseStatement_clearMemoryPool ( );
void SgStopOrPauseStatement_extendMemoryPoolForFileIO ( );
unsigned long SgStopOrPauseStatement_initializeStorageClassArray( SgStopOrPauseStatementStorageClass *storageArray );
void SgStopOrPauseStatement_resetValidFreepointers( );
unsigned long SgStopOrPauseStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIOStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIOStatement* SgIOStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIOStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIOStatement* SgIOStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIOStatement* SgIOStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIOStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIOStatement_clearMemoryPool ( );
void SgIOStatement_extendMemoryPoolForFileIO ( );
unsigned long SgIOStatement_initializeStorageClassArray( SgIOStatementStorageClass *storageArray );
void SgIOStatement_resetValidFreepointers( );
unsigned long SgIOStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgPrintStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgPrintStatement* SgPrintStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgPrintStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgPrintStatement* SgPrintStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgPrintStatement* SgPrintStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgPrintStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgPrintStatement_clearMemoryPool ( );
void SgPrintStatement_extendMemoryPoolForFileIO ( );
unsigned long SgPrintStatement_initializeStorageClassArray( SgPrintStatementStorageClass *storageArray );
void SgPrintStatement_resetValidFreepointers( );
unsigned long SgPrintStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgReadStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgReadStatement* SgReadStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgReadStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgReadStatement* SgReadStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgReadStatement* SgReadStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgReadStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgReadStatement_clearMemoryPool ( );
void SgReadStatement_extendMemoryPoolForFileIO ( );
unsigned long SgReadStatement_initializeStorageClassArray( SgReadStatementStorageClass *storageArray );
void SgReadStatement_resetValidFreepointers( );
unsigned long SgReadStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgWriteStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgWriteStatement* SgWriteStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgWriteStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgWriteStatement* SgWriteStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgWriteStatement* SgWriteStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgWriteStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgWriteStatement_clearMemoryPool ( );
void SgWriteStatement_extendMemoryPoolForFileIO ( );
unsigned long SgWriteStatement_initializeStorageClassArray( SgWriteStatementStorageClass *storageArray );
void SgWriteStatement_resetValidFreepointers( );
unsigned long SgWriteStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOpenStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOpenStatement* SgOpenStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOpenStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOpenStatement* SgOpenStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOpenStatement* SgOpenStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOpenStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOpenStatement_clearMemoryPool ( );
void SgOpenStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOpenStatement_initializeStorageClassArray( SgOpenStatementStorageClass *storageArray );
void SgOpenStatement_resetValidFreepointers( );
unsigned long SgOpenStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCloseStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCloseStatement* SgCloseStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCloseStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCloseStatement* SgCloseStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCloseStatement* SgCloseStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCloseStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCloseStatement_clearMemoryPool ( );
void SgCloseStatement_extendMemoryPoolForFileIO ( );
unsigned long SgCloseStatement_initializeStorageClassArray( SgCloseStatementStorageClass *storageArray );
void SgCloseStatement_resetValidFreepointers( );
unsigned long SgCloseStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgInquireStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgInquireStatement* SgInquireStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgInquireStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgInquireStatement* SgInquireStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgInquireStatement* SgInquireStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgInquireStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgInquireStatement_clearMemoryPool ( );
void SgInquireStatement_extendMemoryPoolForFileIO ( );
unsigned long SgInquireStatement_initializeStorageClassArray( SgInquireStatementStorageClass *storageArray );
void SgInquireStatement_resetValidFreepointers( );
unsigned long SgInquireStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFlushStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFlushStatement* SgFlushStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFlushStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFlushStatement* SgFlushStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFlushStatement* SgFlushStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFlushStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFlushStatement_clearMemoryPool ( );
void SgFlushStatement_extendMemoryPoolForFileIO ( );
unsigned long SgFlushStatement_initializeStorageClassArray( SgFlushStatementStorageClass *storageArray );
void SgFlushStatement_resetValidFreepointers( );
unsigned long SgFlushStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgBackspaceStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgBackspaceStatement* SgBackspaceStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgBackspaceStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgBackspaceStatement* SgBackspaceStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgBackspaceStatement* SgBackspaceStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgBackspaceStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgBackspaceStatement_clearMemoryPool ( );
void SgBackspaceStatement_extendMemoryPoolForFileIO ( );
unsigned long SgBackspaceStatement_initializeStorageClassArray( SgBackspaceStatementStorageClass *storageArray );
void SgBackspaceStatement_resetValidFreepointers( );
unsigned long SgBackspaceStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgRewindStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgRewindStatement* SgRewindStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgRewindStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgRewindStatement* SgRewindStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgRewindStatement* SgRewindStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgRewindStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgRewindStatement_clearMemoryPool ( );
void SgRewindStatement_extendMemoryPoolForFileIO ( );
unsigned long SgRewindStatement_initializeStorageClassArray( SgRewindStatementStorageClass *storageArray );
void SgRewindStatement_resetValidFreepointers( );
unsigned long SgRewindStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgEndfileStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgEndfileStatement* SgEndfileStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgEndfileStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgEndfileStatement* SgEndfileStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgEndfileStatement* SgEndfileStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgEndfileStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgEndfileStatement_clearMemoryPool ( );
void SgEndfileStatement_extendMemoryPoolForFileIO ( );
unsigned long SgEndfileStatement_initializeStorageClassArray( SgEndfileStatementStorageClass *storageArray );
void SgEndfileStatement_resetValidFreepointers( );
unsigned long SgEndfileStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgWaitStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgWaitStatement* SgWaitStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgWaitStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgWaitStatement* SgWaitStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgWaitStatement* SgWaitStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgWaitStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgWaitStatement_clearMemoryPool ( );
void SgWaitStatement_extendMemoryPoolForFileIO ( );
unsigned long SgWaitStatement_initializeStorageClassArray( SgWaitStatementStorageClass *storageArray );
void SgWaitStatement_resetValidFreepointers( );
unsigned long SgWaitStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgWhereStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgWhereStatement* SgWhereStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgWhereStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgWhereStatement* SgWhereStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgWhereStatement* SgWhereStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgWhereStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgWhereStatement_clearMemoryPool ( );
void SgWhereStatement_extendMemoryPoolForFileIO ( );
unsigned long SgWhereStatement_initializeStorageClassArray( SgWhereStatementStorageClass *storageArray );
void SgWhereStatement_resetValidFreepointers( );
unsigned long SgWhereStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgElseWhereStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgElseWhereStatement* SgElseWhereStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgElseWhereStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgElseWhereStatement* SgElseWhereStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgElseWhereStatement* SgElseWhereStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgElseWhereStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgElseWhereStatement_clearMemoryPool ( );
void SgElseWhereStatement_extendMemoryPoolForFileIO ( );
unsigned long SgElseWhereStatement_initializeStorageClassArray( SgElseWhereStatementStorageClass *storageArray );
void SgElseWhereStatement_resetValidFreepointers( );
unsigned long SgElseWhereStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNullifyStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNullifyStatement* SgNullifyStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNullifyStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNullifyStatement* SgNullifyStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNullifyStatement* SgNullifyStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNullifyStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNullifyStatement_clearMemoryPool ( );
void SgNullifyStatement_extendMemoryPoolForFileIO ( );
unsigned long SgNullifyStatement_initializeStorageClassArray( SgNullifyStatementStorageClass *storageArray );
void SgNullifyStatement_resetValidFreepointers( );
unsigned long SgNullifyStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgArithmeticIfStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgArithmeticIfStatement* SgArithmeticIfStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgArithmeticIfStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgArithmeticIfStatement* SgArithmeticIfStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgArithmeticIfStatement* SgArithmeticIfStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgArithmeticIfStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgArithmeticIfStatement_clearMemoryPool ( );
void SgArithmeticIfStatement_extendMemoryPoolForFileIO ( );
unsigned long SgArithmeticIfStatement_initializeStorageClassArray( SgArithmeticIfStatementStorageClass *storageArray );
void SgArithmeticIfStatement_resetValidFreepointers( );
unsigned long SgArithmeticIfStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAssignStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAssignStatement* SgAssignStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAssignStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAssignStatement* SgAssignStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAssignStatement* SgAssignStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAssignStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAssignStatement_clearMemoryPool ( );
void SgAssignStatement_extendMemoryPoolForFileIO ( );
unsigned long SgAssignStatement_initializeStorageClassArray( SgAssignStatementStorageClass *storageArray );
void SgAssignStatement_resetValidFreepointers( );
unsigned long SgAssignStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgComputedGotoStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgComputedGotoStatement* SgComputedGotoStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgComputedGotoStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgComputedGotoStatement* SgComputedGotoStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgComputedGotoStatement* SgComputedGotoStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgComputedGotoStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgComputedGotoStatement_clearMemoryPool ( );
void SgComputedGotoStatement_extendMemoryPoolForFileIO ( );
unsigned long SgComputedGotoStatement_initializeStorageClassArray( SgComputedGotoStatementStorageClass *storageArray );
void SgComputedGotoStatement_resetValidFreepointers( );
unsigned long SgComputedGotoStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAssignedGotoStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAssignedGotoStatement* SgAssignedGotoStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAssignedGotoStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAssignedGotoStatement* SgAssignedGotoStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAssignedGotoStatement* SgAssignedGotoStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAssignedGotoStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAssignedGotoStatement_clearMemoryPool ( );
void SgAssignedGotoStatement_extendMemoryPoolForFileIO ( );
unsigned long SgAssignedGotoStatement_initializeStorageClassArray( SgAssignedGotoStatementStorageClass *storageArray );
void SgAssignedGotoStatement_resetValidFreepointers( );
unsigned long SgAssignedGotoStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAllocateStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAllocateStatement* SgAllocateStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAllocateStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAllocateStatement* SgAllocateStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAllocateStatement* SgAllocateStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAllocateStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAllocateStatement_clearMemoryPool ( );
void SgAllocateStatement_extendMemoryPoolForFileIO ( );
unsigned long SgAllocateStatement_initializeStorageClassArray( SgAllocateStatementStorageClass *storageArray );
void SgAllocateStatement_resetValidFreepointers( );
unsigned long SgAllocateStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDeallocateStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDeallocateStatement* SgDeallocateStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDeallocateStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDeallocateStatement* SgDeallocateStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDeallocateStatement* SgDeallocateStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDeallocateStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDeallocateStatement_clearMemoryPool ( );
void SgDeallocateStatement_extendMemoryPoolForFileIO ( );
unsigned long SgDeallocateStatement_initializeStorageClassArray( SgDeallocateStatementStorageClass *storageArray );
void SgDeallocateStatement_resetValidFreepointers( );
unsigned long SgDeallocateStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUpcNotifyStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUpcNotifyStatement* SgUpcNotifyStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUpcNotifyStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUpcNotifyStatement* SgUpcNotifyStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUpcNotifyStatement* SgUpcNotifyStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUpcNotifyStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUpcNotifyStatement_clearMemoryPool ( );
void SgUpcNotifyStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUpcNotifyStatement_initializeStorageClassArray( SgUpcNotifyStatementStorageClass *storageArray );
void SgUpcNotifyStatement_resetValidFreepointers( );
unsigned long SgUpcNotifyStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUpcWaitStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUpcWaitStatement* SgUpcWaitStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUpcWaitStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUpcWaitStatement* SgUpcWaitStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUpcWaitStatement* SgUpcWaitStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUpcWaitStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUpcWaitStatement_clearMemoryPool ( );
void SgUpcWaitStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUpcWaitStatement_initializeStorageClassArray( SgUpcWaitStatementStorageClass *storageArray );
void SgUpcWaitStatement_resetValidFreepointers( );
unsigned long SgUpcWaitStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUpcBarrierStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUpcBarrierStatement* SgUpcBarrierStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUpcBarrierStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUpcBarrierStatement* SgUpcBarrierStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUpcBarrierStatement* SgUpcBarrierStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUpcBarrierStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUpcBarrierStatement_clearMemoryPool ( );
void SgUpcBarrierStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUpcBarrierStatement_initializeStorageClassArray( SgUpcBarrierStatementStorageClass *storageArray );
void SgUpcBarrierStatement_resetValidFreepointers( );
unsigned long SgUpcBarrierStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUpcFenceStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUpcFenceStatement* SgUpcFenceStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUpcFenceStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUpcFenceStatement* SgUpcFenceStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUpcFenceStatement* SgUpcFenceStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUpcFenceStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUpcFenceStatement_clearMemoryPool ( );
void SgUpcFenceStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUpcFenceStatement_initializeStorageClassArray( SgUpcFenceStatementStorageClass *storageArray );
void SgUpcFenceStatement_resetValidFreepointers( );
unsigned long SgUpcFenceStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpBarrierStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpBarrierStatement* SgOmpBarrierStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpBarrierStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpBarrierStatement* SgOmpBarrierStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpBarrierStatement* SgOmpBarrierStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpBarrierStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpBarrierStatement_clearMemoryPool ( );
void SgOmpBarrierStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpBarrierStatement_initializeStorageClassArray( SgOmpBarrierStatementStorageClass *storageArray );
void SgOmpBarrierStatement_resetValidFreepointers( );
unsigned long SgOmpBarrierStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpTaskwaitStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpTaskwaitStatement* SgOmpTaskwaitStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpTaskwaitStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpTaskwaitStatement* SgOmpTaskwaitStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpTaskwaitStatement* SgOmpTaskwaitStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpTaskwaitStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpTaskwaitStatement_clearMemoryPool ( );
void SgOmpTaskwaitStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpTaskwaitStatement_initializeStorageClassArray( SgOmpTaskwaitStatementStorageClass *storageArray );
void SgOmpTaskwaitStatement_resetValidFreepointers( );
unsigned long SgOmpTaskwaitStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpFlushStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpFlushStatement* SgOmpFlushStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpFlushStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpFlushStatement* SgOmpFlushStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpFlushStatement* SgOmpFlushStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpFlushStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpFlushStatement_clearMemoryPool ( );
void SgOmpFlushStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpFlushStatement_initializeStorageClassArray( SgOmpFlushStatementStorageClass *storageArray );
void SgOmpFlushStatement_resetValidFreepointers( );
unsigned long SgOmpFlushStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpBodyStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpBodyStatement* SgOmpBodyStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpBodyStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpBodyStatement* SgOmpBodyStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpBodyStatement* SgOmpBodyStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpBodyStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpBodyStatement_clearMemoryPool ( );
void SgOmpBodyStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpBodyStatement_initializeStorageClassArray( SgOmpBodyStatementStorageClass *storageArray );
void SgOmpBodyStatement_resetValidFreepointers( );
unsigned long SgOmpBodyStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpAtomicStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpAtomicStatement* SgOmpAtomicStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpAtomicStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpAtomicStatement* SgOmpAtomicStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpAtomicStatement* SgOmpAtomicStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpAtomicStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpAtomicStatement_clearMemoryPool ( );
void SgOmpAtomicStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpAtomicStatement_initializeStorageClassArray( SgOmpAtomicStatementStorageClass *storageArray );
void SgOmpAtomicStatement_resetValidFreepointers( );
unsigned long SgOmpAtomicStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpMasterStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpMasterStatement* SgOmpMasterStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpMasterStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpMasterStatement* SgOmpMasterStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpMasterStatement* SgOmpMasterStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpMasterStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpMasterStatement_clearMemoryPool ( );
void SgOmpMasterStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpMasterStatement_initializeStorageClassArray( SgOmpMasterStatementStorageClass *storageArray );
void SgOmpMasterStatement_resetValidFreepointers( );
unsigned long SgOmpMasterStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpOrderedStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpOrderedStatement* SgOmpOrderedStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpOrderedStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpOrderedStatement* SgOmpOrderedStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpOrderedStatement* SgOmpOrderedStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpOrderedStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpOrderedStatement_clearMemoryPool ( );
void SgOmpOrderedStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpOrderedStatement_initializeStorageClassArray( SgOmpOrderedStatementStorageClass *storageArray );
void SgOmpOrderedStatement_resetValidFreepointers( );
unsigned long SgOmpOrderedStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpCriticalStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpCriticalStatement* SgOmpCriticalStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpCriticalStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpCriticalStatement* SgOmpCriticalStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpCriticalStatement* SgOmpCriticalStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpCriticalStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpCriticalStatement_clearMemoryPool ( );
void SgOmpCriticalStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpCriticalStatement_initializeStorageClassArray( SgOmpCriticalStatementStorageClass *storageArray );
void SgOmpCriticalStatement_resetValidFreepointers( );
unsigned long SgOmpCriticalStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpSectionStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpSectionStatement* SgOmpSectionStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpSectionStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpSectionStatement* SgOmpSectionStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpSectionStatement* SgOmpSectionStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpSectionStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpSectionStatement_clearMemoryPool ( );
void SgOmpSectionStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpSectionStatement_initializeStorageClassArray( SgOmpSectionStatementStorageClass *storageArray );
void SgOmpSectionStatement_resetValidFreepointers( );
unsigned long SgOmpSectionStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpWorkshareStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpWorkshareStatement* SgOmpWorkshareStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpWorkshareStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpWorkshareStatement* SgOmpWorkshareStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpWorkshareStatement* SgOmpWorkshareStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpWorkshareStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpWorkshareStatement_clearMemoryPool ( );
void SgOmpWorkshareStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpWorkshareStatement_initializeStorageClassArray( SgOmpWorkshareStatementStorageClass *storageArray );
void SgOmpWorkshareStatement_resetValidFreepointers( );
unsigned long SgOmpWorkshareStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpClauseBodyStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpClauseBodyStatement* SgOmpClauseBodyStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpClauseBodyStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpClauseBodyStatement* SgOmpClauseBodyStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpClauseBodyStatement* SgOmpClauseBodyStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpClauseBodyStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpClauseBodyStatement_clearMemoryPool ( );
void SgOmpClauseBodyStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpClauseBodyStatement_initializeStorageClassArray( SgOmpClauseBodyStatementStorageClass *storageArray );
void SgOmpClauseBodyStatement_resetValidFreepointers( );
unsigned long SgOmpClauseBodyStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpParallelStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpParallelStatement* SgOmpParallelStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpParallelStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpParallelStatement* SgOmpParallelStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpParallelStatement* SgOmpParallelStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpParallelStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpParallelStatement_clearMemoryPool ( );
void SgOmpParallelStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpParallelStatement_initializeStorageClassArray( SgOmpParallelStatementStorageClass *storageArray );
void SgOmpParallelStatement_resetValidFreepointers( );
unsigned long SgOmpParallelStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpSingleStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpSingleStatement* SgOmpSingleStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpSingleStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpSingleStatement* SgOmpSingleStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpSingleStatement* SgOmpSingleStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpSingleStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpSingleStatement_clearMemoryPool ( );
void SgOmpSingleStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpSingleStatement_initializeStorageClassArray( SgOmpSingleStatementStorageClass *storageArray );
void SgOmpSingleStatement_resetValidFreepointers( );
unsigned long SgOmpSingleStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpTaskStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpTaskStatement* SgOmpTaskStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpTaskStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpTaskStatement* SgOmpTaskStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpTaskStatement* SgOmpTaskStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpTaskStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpTaskStatement_clearMemoryPool ( );
void SgOmpTaskStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpTaskStatement_initializeStorageClassArray( SgOmpTaskStatementStorageClass *storageArray );
void SgOmpTaskStatement_resetValidFreepointers( );
unsigned long SgOmpTaskStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpForStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpForStatement* SgOmpForStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpForStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpForStatement* SgOmpForStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpForStatement* SgOmpForStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpForStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpForStatement_clearMemoryPool ( );
void SgOmpForStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpForStatement_initializeStorageClassArray( SgOmpForStatementStorageClass *storageArray );
void SgOmpForStatement_resetValidFreepointers( );
unsigned long SgOmpForStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpDoStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpDoStatement* SgOmpDoStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpDoStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpDoStatement* SgOmpDoStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpDoStatement* SgOmpDoStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpDoStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpDoStatement_clearMemoryPool ( );
void SgOmpDoStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpDoStatement_initializeStorageClassArray( SgOmpDoStatementStorageClass *storageArray );
void SgOmpDoStatement_resetValidFreepointers( );
unsigned long SgOmpDoStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpSectionsStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpSectionsStatement* SgOmpSectionsStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpSectionsStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpSectionsStatement* SgOmpSectionsStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpSectionsStatement* SgOmpSectionsStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpSectionsStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpSectionsStatement_clearMemoryPool ( );
void SgOmpSectionsStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpSectionsStatement_initializeStorageClassArray( SgOmpSectionsStatementStorageClass *storageArray );
void SgOmpSectionsStatement_resetValidFreepointers( );
unsigned long SgOmpSectionsStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgSequenceStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgSequenceStatement* SgSequenceStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgSequenceStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgSequenceStatement* SgSequenceStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgSequenceStatement* SgSequenceStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgSequenceStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgSequenceStatement_clearMemoryPool ( );
void SgSequenceStatement_extendMemoryPoolForFileIO ( );
unsigned long SgSequenceStatement_initializeStorageClassArray( SgSequenceStatementStorageClass *storageArray );
void SgSequenceStatement_resetValidFreepointers( );
unsigned long SgSequenceStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgWithStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgWithStatement* SgWithStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgWithStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgWithStatement* SgWithStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgWithStatement* SgWithStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgWithStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgWithStatement_clearMemoryPool ( );
void SgWithStatement_extendMemoryPoolForFileIO ( );
unsigned long SgWithStatement_initializeStorageClassArray( SgWithStatementStorageClass *storageArray );
void SgWithStatement_resetValidFreepointers( );
unsigned long SgWithStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgPythonPrintStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgPythonPrintStmt* SgPythonPrintStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgPythonPrintStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgPythonPrintStmt* SgPythonPrintStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgPythonPrintStmt* SgPythonPrintStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgPythonPrintStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgPythonPrintStmt_clearMemoryPool ( );
void SgPythonPrintStmt_extendMemoryPoolForFileIO ( );
unsigned long SgPythonPrintStmt_initializeStorageClassArray( SgPythonPrintStmtStorageClass *storageArray );
void SgPythonPrintStmt_resetValidFreepointers( );
unsigned long SgPythonPrintStmt_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgPassStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgPassStatement* SgPassStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgPassStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgPassStatement* SgPassStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgPassStatement* SgPassStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgPassStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgPassStatement_clearMemoryPool ( );
void SgPassStatement_extendMemoryPoolForFileIO ( );
unsigned long SgPassStatement_initializeStorageClassArray( SgPassStatementStorageClass *storageArray );
void SgPassStatement_resetValidFreepointers( );
unsigned long SgPassStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAssertStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAssertStmt* SgAssertStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAssertStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAssertStmt* SgAssertStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAssertStmt* SgAssertStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAssertStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAssertStmt_clearMemoryPool ( );
void SgAssertStmt_extendMemoryPoolForFileIO ( );
unsigned long SgAssertStmt_initializeStorageClassArray( SgAssertStmtStorageClass *storageArray );
void SgAssertStmt_resetValidFreepointers( );
unsigned long SgAssertStmt_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgExecStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgExecStatement* SgExecStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgExecStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgExecStatement* SgExecStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgExecStatement* SgExecStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgExecStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgExecStatement_clearMemoryPool ( );
void SgExecStatement_extendMemoryPoolForFileIO ( );
unsigned long SgExecStatement_initializeStorageClassArray( SgExecStatementStorageClass *storageArray );
void SgExecStatement_resetValidFreepointers( );
unsigned long SgExecStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgPythonGlobalStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgPythonGlobalStmt* SgPythonGlobalStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgPythonGlobalStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgPythonGlobalStmt* SgPythonGlobalStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgPythonGlobalStmt* SgPythonGlobalStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgPythonGlobalStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgPythonGlobalStmt_clearMemoryPool ( );
void SgPythonGlobalStmt_extendMemoryPoolForFileIO ( );
unsigned long SgPythonGlobalStmt_initializeStorageClassArray( SgPythonGlobalStmtStorageClass *storageArray );
void SgPythonGlobalStmt_resetValidFreepointers( );
unsigned long SgPythonGlobalStmt_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJavaThrowStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJavaThrowStatement* SgJavaThrowStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJavaThrowStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJavaThrowStatement* SgJavaThrowStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJavaThrowStatement* SgJavaThrowStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJavaThrowStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJavaThrowStatement_clearMemoryPool ( );
void SgJavaThrowStatement_extendMemoryPoolForFileIO ( );
unsigned long SgJavaThrowStatement_initializeStorageClassArray( SgJavaThrowStatementStorageClass *storageArray );
void SgJavaThrowStatement_resetValidFreepointers( );
unsigned long SgJavaThrowStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJavaSynchronizedStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJavaSynchronizedStatement* SgJavaSynchronizedStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJavaSynchronizedStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJavaSynchronizedStatement* SgJavaSynchronizedStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJavaSynchronizedStatement* SgJavaSynchronizedStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJavaSynchronizedStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJavaSynchronizedStatement_clearMemoryPool ( );
void SgJavaSynchronizedStatement_extendMemoryPoolForFileIO ( );
unsigned long SgJavaSynchronizedStatement_initializeStorageClassArray( SgJavaSynchronizedStatementStorageClass *storageArray );
void SgJavaSynchronizedStatement_resetValidFreepointers( );
unsigned long SgJavaSynchronizedStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgExpression* SgExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgExpression* SgExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgExpression* SgExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgExpression_clearMemoryPool ( );
void SgExpression_extendMemoryPoolForFileIO ( );
unsigned long SgExpression_initializeStorageClassArray( SgExpressionStorageClass *storageArray );
void SgExpression_resetValidFreepointers( );
unsigned long SgExpression_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUnaryOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUnaryOp* SgUnaryOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUnaryOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUnaryOp* SgUnaryOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUnaryOp* SgUnaryOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUnaryOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUnaryOp_clearMemoryPool ( );
void SgUnaryOp_extendMemoryPoolForFileIO ( );
unsigned long SgUnaryOp_initializeStorageClassArray( SgUnaryOpStorageClass *storageArray );
void SgUnaryOp_resetValidFreepointers( );
unsigned long SgUnaryOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgExpressionRoot_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgExpressionRoot* SgExpressionRoot_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgExpressionRoot_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgExpressionRoot* SgExpressionRoot_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgExpressionRoot* SgExpressionRoot_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgExpressionRoot_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgExpressionRoot_clearMemoryPool ( );
void SgExpressionRoot_extendMemoryPoolForFileIO ( );
unsigned long SgExpressionRoot_initializeStorageClassArray( SgExpressionRootStorageClass *storageArray );
void SgExpressionRoot_resetValidFreepointers( );
unsigned long SgExpressionRoot_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgMinusOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgMinusOp* SgMinusOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgMinusOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgMinusOp* SgMinusOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgMinusOp* SgMinusOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgMinusOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgMinusOp_clearMemoryPool ( );
void SgMinusOp_extendMemoryPoolForFileIO ( );
unsigned long SgMinusOp_initializeStorageClassArray( SgMinusOpStorageClass *storageArray );
void SgMinusOp_resetValidFreepointers( );
unsigned long SgMinusOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUnaryAddOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUnaryAddOp* SgUnaryAddOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUnaryAddOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUnaryAddOp* SgUnaryAddOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUnaryAddOp* SgUnaryAddOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUnaryAddOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUnaryAddOp_clearMemoryPool ( );
void SgUnaryAddOp_extendMemoryPoolForFileIO ( );
unsigned long SgUnaryAddOp_initializeStorageClassArray( SgUnaryAddOpStorageClass *storageArray );
void SgUnaryAddOp_resetValidFreepointers( );
unsigned long SgUnaryAddOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNotOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNotOp* SgNotOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNotOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNotOp* SgNotOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNotOp* SgNotOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNotOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNotOp_clearMemoryPool ( );
void SgNotOp_extendMemoryPoolForFileIO ( );
unsigned long SgNotOp_initializeStorageClassArray( SgNotOpStorageClass *storageArray );
void SgNotOp_resetValidFreepointers( );
unsigned long SgNotOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgPointerDerefExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgPointerDerefExp* SgPointerDerefExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgPointerDerefExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgPointerDerefExp* SgPointerDerefExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgPointerDerefExp* SgPointerDerefExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgPointerDerefExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgPointerDerefExp_clearMemoryPool ( );
void SgPointerDerefExp_extendMemoryPoolForFileIO ( );
unsigned long SgPointerDerefExp_initializeStorageClassArray( SgPointerDerefExpStorageClass *storageArray );
void SgPointerDerefExp_resetValidFreepointers( );
unsigned long SgPointerDerefExp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAddressOfOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAddressOfOp* SgAddressOfOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAddressOfOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAddressOfOp* SgAddressOfOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAddressOfOp* SgAddressOfOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAddressOfOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAddressOfOp_clearMemoryPool ( );
void SgAddressOfOp_extendMemoryPoolForFileIO ( );
unsigned long SgAddressOfOp_initializeStorageClassArray( SgAddressOfOpStorageClass *storageArray );
void SgAddressOfOp_resetValidFreepointers( );
unsigned long SgAddressOfOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgMinusMinusOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgMinusMinusOp* SgMinusMinusOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgMinusMinusOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgMinusMinusOp* SgMinusMinusOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgMinusMinusOp* SgMinusMinusOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgMinusMinusOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgMinusMinusOp_clearMemoryPool ( );
void SgMinusMinusOp_extendMemoryPoolForFileIO ( );
unsigned long SgMinusMinusOp_initializeStorageClassArray( SgMinusMinusOpStorageClass *storageArray );
void SgMinusMinusOp_resetValidFreepointers( );
unsigned long SgMinusMinusOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgPlusPlusOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgPlusPlusOp* SgPlusPlusOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgPlusPlusOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgPlusPlusOp* SgPlusPlusOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgPlusPlusOp* SgPlusPlusOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgPlusPlusOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgPlusPlusOp_clearMemoryPool ( );
void SgPlusPlusOp_extendMemoryPoolForFileIO ( );
unsigned long SgPlusPlusOp_initializeStorageClassArray( SgPlusPlusOpStorageClass *storageArray );
void SgPlusPlusOp_resetValidFreepointers( );
unsigned long SgPlusPlusOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgBitComplementOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgBitComplementOp* SgBitComplementOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgBitComplementOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgBitComplementOp* SgBitComplementOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgBitComplementOp* SgBitComplementOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgBitComplementOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgBitComplementOp_clearMemoryPool ( );
void SgBitComplementOp_extendMemoryPoolForFileIO ( );
unsigned long SgBitComplementOp_initializeStorageClassArray( SgBitComplementOpStorageClass *storageArray );
void SgBitComplementOp_resetValidFreepointers( );
unsigned long SgBitComplementOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCastExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCastExp* SgCastExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCastExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCastExp* SgCastExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCastExp* SgCastExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCastExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCastExp_clearMemoryPool ( );
void SgCastExp_extendMemoryPoolForFileIO ( );
unsigned long SgCastExp_initializeStorageClassArray( SgCastExpStorageClass *storageArray );
void SgCastExp_resetValidFreepointers( );
unsigned long SgCastExp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgThrowOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgThrowOp* SgThrowOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgThrowOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgThrowOp* SgThrowOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgThrowOp* SgThrowOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgThrowOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgThrowOp_clearMemoryPool ( );
void SgThrowOp_extendMemoryPoolForFileIO ( );
unsigned long SgThrowOp_initializeStorageClassArray( SgThrowOpStorageClass *storageArray );
void SgThrowOp_resetValidFreepointers( );
unsigned long SgThrowOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgRealPartOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgRealPartOp* SgRealPartOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgRealPartOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgRealPartOp* SgRealPartOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgRealPartOp* SgRealPartOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgRealPartOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgRealPartOp_clearMemoryPool ( );
void SgRealPartOp_extendMemoryPoolForFileIO ( );
unsigned long SgRealPartOp_initializeStorageClassArray( SgRealPartOpStorageClass *storageArray );
void SgRealPartOp_resetValidFreepointers( );
unsigned long SgRealPartOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgImagPartOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgImagPartOp* SgImagPartOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgImagPartOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgImagPartOp* SgImagPartOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgImagPartOp* SgImagPartOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgImagPartOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgImagPartOp_clearMemoryPool ( );
void SgImagPartOp_extendMemoryPoolForFileIO ( );
unsigned long SgImagPartOp_initializeStorageClassArray( SgImagPartOpStorageClass *storageArray );
void SgImagPartOp_resetValidFreepointers( );
unsigned long SgImagPartOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgConjugateOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgConjugateOp* SgConjugateOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgConjugateOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgConjugateOp* SgConjugateOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgConjugateOp* SgConjugateOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgConjugateOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgConjugateOp_clearMemoryPool ( );
void SgConjugateOp_extendMemoryPoolForFileIO ( );
unsigned long SgConjugateOp_initializeStorageClassArray( SgConjugateOpStorageClass *storageArray );
void SgConjugateOp_resetValidFreepointers( );
unsigned long SgConjugateOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUserDefinedUnaryOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUserDefinedUnaryOp* SgUserDefinedUnaryOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUserDefinedUnaryOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUserDefinedUnaryOp* SgUserDefinedUnaryOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUserDefinedUnaryOp* SgUserDefinedUnaryOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUserDefinedUnaryOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUserDefinedUnaryOp_clearMemoryPool ( );
void SgUserDefinedUnaryOp_extendMemoryPoolForFileIO ( );
unsigned long SgUserDefinedUnaryOp_initializeStorageClassArray( SgUserDefinedUnaryOpStorageClass *storageArray );
void SgUserDefinedUnaryOp_resetValidFreepointers( );
unsigned long SgUserDefinedUnaryOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgBinaryOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgBinaryOp* SgBinaryOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgBinaryOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgBinaryOp* SgBinaryOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgBinaryOp* SgBinaryOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgBinaryOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgBinaryOp_clearMemoryPool ( );
void SgBinaryOp_extendMemoryPoolForFileIO ( );
unsigned long SgBinaryOp_initializeStorageClassArray( SgBinaryOpStorageClass *storageArray );
void SgBinaryOp_resetValidFreepointers( );
unsigned long SgBinaryOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgArrowExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgArrowExp* SgArrowExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgArrowExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgArrowExp* SgArrowExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgArrowExp* SgArrowExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgArrowExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgArrowExp_clearMemoryPool ( );
void SgArrowExp_extendMemoryPoolForFileIO ( );
unsigned long SgArrowExp_initializeStorageClassArray( SgArrowExpStorageClass *storageArray );
void SgArrowExp_resetValidFreepointers( );
unsigned long SgArrowExp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDotExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDotExp* SgDotExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDotExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDotExp* SgDotExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDotExp* SgDotExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDotExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDotExp_clearMemoryPool ( );
void SgDotExp_extendMemoryPoolForFileIO ( );
unsigned long SgDotExp_initializeStorageClassArray( SgDotExpStorageClass *storageArray );
void SgDotExp_resetValidFreepointers( );
unsigned long SgDotExp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDotStarOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDotStarOp* SgDotStarOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDotStarOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDotStarOp* SgDotStarOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDotStarOp* SgDotStarOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDotStarOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDotStarOp_clearMemoryPool ( );
void SgDotStarOp_extendMemoryPoolForFileIO ( );
unsigned long SgDotStarOp_initializeStorageClassArray( SgDotStarOpStorageClass *storageArray );
void SgDotStarOp_resetValidFreepointers( );
unsigned long SgDotStarOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgArrowStarOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgArrowStarOp* SgArrowStarOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgArrowStarOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgArrowStarOp* SgArrowStarOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgArrowStarOp* SgArrowStarOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgArrowStarOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgArrowStarOp_clearMemoryPool ( );
void SgArrowStarOp_extendMemoryPoolForFileIO ( );
unsigned long SgArrowStarOp_initializeStorageClassArray( SgArrowStarOpStorageClass *storageArray );
void SgArrowStarOp_resetValidFreepointers( );
unsigned long SgArrowStarOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgEqualityOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgEqualityOp* SgEqualityOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgEqualityOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgEqualityOp* SgEqualityOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgEqualityOp* SgEqualityOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgEqualityOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgEqualityOp_clearMemoryPool ( );
void SgEqualityOp_extendMemoryPoolForFileIO ( );
unsigned long SgEqualityOp_initializeStorageClassArray( SgEqualityOpStorageClass *storageArray );
void SgEqualityOp_resetValidFreepointers( );
unsigned long SgEqualityOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLessThanOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLessThanOp* SgLessThanOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLessThanOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLessThanOp* SgLessThanOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLessThanOp* SgLessThanOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLessThanOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLessThanOp_clearMemoryPool ( );
void SgLessThanOp_extendMemoryPoolForFileIO ( );
unsigned long SgLessThanOp_initializeStorageClassArray( SgLessThanOpStorageClass *storageArray );
void SgLessThanOp_resetValidFreepointers( );
unsigned long SgLessThanOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgGreaterThanOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgGreaterThanOp* SgGreaterThanOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgGreaterThanOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgGreaterThanOp* SgGreaterThanOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgGreaterThanOp* SgGreaterThanOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgGreaterThanOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgGreaterThanOp_clearMemoryPool ( );
void SgGreaterThanOp_extendMemoryPoolForFileIO ( );
unsigned long SgGreaterThanOp_initializeStorageClassArray( SgGreaterThanOpStorageClass *storageArray );
void SgGreaterThanOp_resetValidFreepointers( );
unsigned long SgGreaterThanOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNotEqualOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNotEqualOp* SgNotEqualOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNotEqualOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNotEqualOp* SgNotEqualOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNotEqualOp* SgNotEqualOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNotEqualOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNotEqualOp_clearMemoryPool ( );
void SgNotEqualOp_extendMemoryPoolForFileIO ( );
unsigned long SgNotEqualOp_initializeStorageClassArray( SgNotEqualOpStorageClass *storageArray );
void SgNotEqualOp_resetValidFreepointers( );
unsigned long SgNotEqualOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLessOrEqualOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLessOrEqualOp* SgLessOrEqualOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLessOrEqualOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLessOrEqualOp* SgLessOrEqualOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLessOrEqualOp* SgLessOrEqualOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLessOrEqualOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLessOrEqualOp_clearMemoryPool ( );
void SgLessOrEqualOp_extendMemoryPoolForFileIO ( );
unsigned long SgLessOrEqualOp_initializeStorageClassArray( SgLessOrEqualOpStorageClass *storageArray );
void SgLessOrEqualOp_resetValidFreepointers( );
unsigned long SgLessOrEqualOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgGreaterOrEqualOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgGreaterOrEqualOp* SgGreaterOrEqualOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgGreaterOrEqualOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgGreaterOrEqualOp* SgGreaterOrEqualOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgGreaterOrEqualOp* SgGreaterOrEqualOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgGreaterOrEqualOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgGreaterOrEqualOp_clearMemoryPool ( );
void SgGreaterOrEqualOp_extendMemoryPoolForFileIO ( );
unsigned long SgGreaterOrEqualOp_initializeStorageClassArray( SgGreaterOrEqualOpStorageClass *storageArray );
void SgGreaterOrEqualOp_resetValidFreepointers( );
unsigned long SgGreaterOrEqualOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAddOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAddOp* SgAddOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAddOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAddOp* SgAddOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAddOp* SgAddOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAddOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAddOp_clearMemoryPool ( );
void SgAddOp_extendMemoryPoolForFileIO ( );
unsigned long SgAddOp_initializeStorageClassArray( SgAddOpStorageClass *storageArray );
void SgAddOp_resetValidFreepointers( );
unsigned long SgAddOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgSubtractOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgSubtractOp* SgSubtractOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgSubtractOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgSubtractOp* SgSubtractOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgSubtractOp* SgSubtractOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgSubtractOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgSubtractOp_clearMemoryPool ( );
void SgSubtractOp_extendMemoryPoolForFileIO ( );
unsigned long SgSubtractOp_initializeStorageClassArray( SgSubtractOpStorageClass *storageArray );
void SgSubtractOp_resetValidFreepointers( );
unsigned long SgSubtractOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgMultiplyOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgMultiplyOp* SgMultiplyOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgMultiplyOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgMultiplyOp* SgMultiplyOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgMultiplyOp* SgMultiplyOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgMultiplyOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgMultiplyOp_clearMemoryPool ( );
void SgMultiplyOp_extendMemoryPoolForFileIO ( );
unsigned long SgMultiplyOp_initializeStorageClassArray( SgMultiplyOpStorageClass *storageArray );
void SgMultiplyOp_resetValidFreepointers( );
unsigned long SgMultiplyOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDivideOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDivideOp* SgDivideOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDivideOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDivideOp* SgDivideOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDivideOp* SgDivideOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDivideOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDivideOp_clearMemoryPool ( );
void SgDivideOp_extendMemoryPoolForFileIO ( );
unsigned long SgDivideOp_initializeStorageClassArray( SgDivideOpStorageClass *storageArray );
void SgDivideOp_resetValidFreepointers( );
unsigned long SgDivideOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIntegerDivideOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIntegerDivideOp* SgIntegerDivideOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIntegerDivideOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIntegerDivideOp* SgIntegerDivideOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIntegerDivideOp* SgIntegerDivideOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIntegerDivideOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIntegerDivideOp_clearMemoryPool ( );
void SgIntegerDivideOp_extendMemoryPoolForFileIO ( );
unsigned long SgIntegerDivideOp_initializeStorageClassArray( SgIntegerDivideOpStorageClass *storageArray );
void SgIntegerDivideOp_resetValidFreepointers( );
unsigned long SgIntegerDivideOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgModOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgModOp* SgModOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgModOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgModOp* SgModOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgModOp* SgModOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgModOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgModOp_clearMemoryPool ( );
void SgModOp_extendMemoryPoolForFileIO ( );
unsigned long SgModOp_initializeStorageClassArray( SgModOpStorageClass *storageArray );
void SgModOp_resetValidFreepointers( );
unsigned long SgModOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAndOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAndOp* SgAndOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAndOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAndOp* SgAndOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAndOp* SgAndOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAndOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAndOp_clearMemoryPool ( );
void SgAndOp_extendMemoryPoolForFileIO ( );
unsigned long SgAndOp_initializeStorageClassArray( SgAndOpStorageClass *storageArray );
void SgAndOp_resetValidFreepointers( );
unsigned long SgAndOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOrOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOrOp* SgOrOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOrOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOrOp* SgOrOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOrOp* SgOrOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOrOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOrOp_clearMemoryPool ( );
void SgOrOp_extendMemoryPoolForFileIO ( );
unsigned long SgOrOp_initializeStorageClassArray( SgOrOpStorageClass *storageArray );
void SgOrOp_resetValidFreepointers( );
unsigned long SgOrOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgBitXorOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgBitXorOp* SgBitXorOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgBitXorOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgBitXorOp* SgBitXorOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgBitXorOp* SgBitXorOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgBitXorOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgBitXorOp_clearMemoryPool ( );
void SgBitXorOp_extendMemoryPoolForFileIO ( );
unsigned long SgBitXorOp_initializeStorageClassArray( SgBitXorOpStorageClass *storageArray );
void SgBitXorOp_resetValidFreepointers( );
unsigned long SgBitXorOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgBitAndOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgBitAndOp* SgBitAndOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgBitAndOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgBitAndOp* SgBitAndOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgBitAndOp* SgBitAndOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgBitAndOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgBitAndOp_clearMemoryPool ( );
void SgBitAndOp_extendMemoryPoolForFileIO ( );
unsigned long SgBitAndOp_initializeStorageClassArray( SgBitAndOpStorageClass *storageArray );
void SgBitAndOp_resetValidFreepointers( );
unsigned long SgBitAndOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgBitOrOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgBitOrOp* SgBitOrOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgBitOrOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgBitOrOp* SgBitOrOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgBitOrOp* SgBitOrOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgBitOrOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgBitOrOp_clearMemoryPool ( );
void SgBitOrOp_extendMemoryPoolForFileIO ( );
unsigned long SgBitOrOp_initializeStorageClassArray( SgBitOrOpStorageClass *storageArray );
void SgBitOrOp_resetValidFreepointers( );
unsigned long SgBitOrOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCommaOpExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCommaOpExp* SgCommaOpExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCommaOpExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCommaOpExp* SgCommaOpExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCommaOpExp* SgCommaOpExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCommaOpExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCommaOpExp_clearMemoryPool ( );
void SgCommaOpExp_extendMemoryPoolForFileIO ( );
unsigned long SgCommaOpExp_initializeStorageClassArray( SgCommaOpExpStorageClass *storageArray );
void SgCommaOpExp_resetValidFreepointers( );
unsigned long SgCommaOpExp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLshiftOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLshiftOp* SgLshiftOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLshiftOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLshiftOp* SgLshiftOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLshiftOp* SgLshiftOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLshiftOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLshiftOp_clearMemoryPool ( );
void SgLshiftOp_extendMemoryPoolForFileIO ( );
unsigned long SgLshiftOp_initializeStorageClassArray( SgLshiftOpStorageClass *storageArray );
void SgLshiftOp_resetValidFreepointers( );
unsigned long SgLshiftOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgRshiftOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgRshiftOp* SgRshiftOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgRshiftOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgRshiftOp* SgRshiftOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgRshiftOp* SgRshiftOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgRshiftOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgRshiftOp_clearMemoryPool ( );
void SgRshiftOp_extendMemoryPoolForFileIO ( );
unsigned long SgRshiftOp_initializeStorageClassArray( SgRshiftOpStorageClass *storageArray );
void SgRshiftOp_resetValidFreepointers( );
unsigned long SgRshiftOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgPntrArrRefExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgPntrArrRefExp* SgPntrArrRefExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgPntrArrRefExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgPntrArrRefExp* SgPntrArrRefExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgPntrArrRefExp* SgPntrArrRefExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgPntrArrRefExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgPntrArrRefExp_clearMemoryPool ( );
void SgPntrArrRefExp_extendMemoryPoolForFileIO ( );
unsigned long SgPntrArrRefExp_initializeStorageClassArray( SgPntrArrRefExpStorageClass *storageArray );
void SgPntrArrRefExp_resetValidFreepointers( );
unsigned long SgPntrArrRefExp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgScopeOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgScopeOp* SgScopeOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgScopeOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgScopeOp* SgScopeOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgScopeOp* SgScopeOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgScopeOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgScopeOp_clearMemoryPool ( );
void SgScopeOp_extendMemoryPoolForFileIO ( );
unsigned long SgScopeOp_initializeStorageClassArray( SgScopeOpStorageClass *storageArray );
void SgScopeOp_resetValidFreepointers( );
unsigned long SgScopeOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAssignOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAssignOp* SgAssignOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAssignOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAssignOp* SgAssignOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAssignOp* SgAssignOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAssignOp_clearMemoryPool ( );
void SgAssignOp_extendMemoryPoolForFileIO ( );
unsigned long SgAssignOp_initializeStorageClassArray( SgAssignOpStorageClass *storageArray );
void SgAssignOp_resetValidFreepointers( );
unsigned long SgAssignOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgExponentiationOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgExponentiationOp* SgExponentiationOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgExponentiationOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgExponentiationOp* SgExponentiationOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgExponentiationOp* SgExponentiationOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgExponentiationOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgExponentiationOp_clearMemoryPool ( );
void SgExponentiationOp_extendMemoryPoolForFileIO ( );
unsigned long SgExponentiationOp_initializeStorageClassArray( SgExponentiationOpStorageClass *storageArray );
void SgExponentiationOp_resetValidFreepointers( );
unsigned long SgExponentiationOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJavaUnsignedRshiftOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJavaUnsignedRshiftOp* SgJavaUnsignedRshiftOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJavaUnsignedRshiftOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJavaUnsignedRshiftOp* SgJavaUnsignedRshiftOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJavaUnsignedRshiftOp* SgJavaUnsignedRshiftOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJavaUnsignedRshiftOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJavaUnsignedRshiftOp_clearMemoryPool ( );
void SgJavaUnsignedRshiftOp_extendMemoryPoolForFileIO ( );
unsigned long SgJavaUnsignedRshiftOp_initializeStorageClassArray( SgJavaUnsignedRshiftOpStorageClass *storageArray );
void SgJavaUnsignedRshiftOp_resetValidFreepointers( );
unsigned long SgJavaUnsignedRshiftOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgConcatenationOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgConcatenationOp* SgConcatenationOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgConcatenationOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgConcatenationOp* SgConcatenationOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgConcatenationOp* SgConcatenationOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgConcatenationOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgConcatenationOp_clearMemoryPool ( );
void SgConcatenationOp_extendMemoryPoolForFileIO ( );
unsigned long SgConcatenationOp_initializeStorageClassArray( SgConcatenationOpStorageClass *storageArray );
void SgConcatenationOp_resetValidFreepointers( );
unsigned long SgConcatenationOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgPointerAssignOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgPointerAssignOp* SgPointerAssignOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgPointerAssignOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgPointerAssignOp* SgPointerAssignOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgPointerAssignOp* SgPointerAssignOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgPointerAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgPointerAssignOp_clearMemoryPool ( );
void SgPointerAssignOp_extendMemoryPoolForFileIO ( );
unsigned long SgPointerAssignOp_initializeStorageClassArray( SgPointerAssignOpStorageClass *storageArray );
void SgPointerAssignOp_resetValidFreepointers( );
unsigned long SgPointerAssignOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUserDefinedBinaryOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUserDefinedBinaryOp* SgUserDefinedBinaryOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUserDefinedBinaryOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUserDefinedBinaryOp* SgUserDefinedBinaryOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUserDefinedBinaryOp* SgUserDefinedBinaryOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUserDefinedBinaryOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUserDefinedBinaryOp_clearMemoryPool ( );
void SgUserDefinedBinaryOp_extendMemoryPoolForFileIO ( );
unsigned long SgUserDefinedBinaryOp_initializeStorageClassArray( SgUserDefinedBinaryOpStorageClass *storageArray );
void SgUserDefinedBinaryOp_resetValidFreepointers( );
unsigned long SgUserDefinedBinaryOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCompoundAssignOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCompoundAssignOp* SgCompoundAssignOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCompoundAssignOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCompoundAssignOp* SgCompoundAssignOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCompoundAssignOp* SgCompoundAssignOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCompoundAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCompoundAssignOp_clearMemoryPool ( );
void SgCompoundAssignOp_extendMemoryPoolForFileIO ( );
unsigned long SgCompoundAssignOp_initializeStorageClassArray( SgCompoundAssignOpStorageClass *storageArray );
void SgCompoundAssignOp_resetValidFreepointers( );
unsigned long SgCompoundAssignOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgPlusAssignOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgPlusAssignOp* SgPlusAssignOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgPlusAssignOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgPlusAssignOp* SgPlusAssignOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgPlusAssignOp* SgPlusAssignOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgPlusAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgPlusAssignOp_clearMemoryPool ( );
void SgPlusAssignOp_extendMemoryPoolForFileIO ( );
unsigned long SgPlusAssignOp_initializeStorageClassArray( SgPlusAssignOpStorageClass *storageArray );
void SgPlusAssignOp_resetValidFreepointers( );
unsigned long SgPlusAssignOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgMinusAssignOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgMinusAssignOp* SgMinusAssignOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgMinusAssignOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgMinusAssignOp* SgMinusAssignOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgMinusAssignOp* SgMinusAssignOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgMinusAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgMinusAssignOp_clearMemoryPool ( );
void SgMinusAssignOp_extendMemoryPoolForFileIO ( );
unsigned long SgMinusAssignOp_initializeStorageClassArray( SgMinusAssignOpStorageClass *storageArray );
void SgMinusAssignOp_resetValidFreepointers( );
unsigned long SgMinusAssignOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAndAssignOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAndAssignOp* SgAndAssignOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAndAssignOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAndAssignOp* SgAndAssignOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAndAssignOp* SgAndAssignOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAndAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAndAssignOp_clearMemoryPool ( );
void SgAndAssignOp_extendMemoryPoolForFileIO ( );
unsigned long SgAndAssignOp_initializeStorageClassArray( SgAndAssignOpStorageClass *storageArray );
void SgAndAssignOp_resetValidFreepointers( );
unsigned long SgAndAssignOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIorAssignOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIorAssignOp* SgIorAssignOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIorAssignOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIorAssignOp* SgIorAssignOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIorAssignOp* SgIorAssignOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIorAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIorAssignOp_clearMemoryPool ( );
void SgIorAssignOp_extendMemoryPoolForFileIO ( );
unsigned long SgIorAssignOp_initializeStorageClassArray( SgIorAssignOpStorageClass *storageArray );
void SgIorAssignOp_resetValidFreepointers( );
unsigned long SgIorAssignOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgMultAssignOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgMultAssignOp* SgMultAssignOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgMultAssignOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgMultAssignOp* SgMultAssignOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgMultAssignOp* SgMultAssignOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgMultAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgMultAssignOp_clearMemoryPool ( );
void SgMultAssignOp_extendMemoryPoolForFileIO ( );
unsigned long SgMultAssignOp_initializeStorageClassArray( SgMultAssignOpStorageClass *storageArray );
void SgMultAssignOp_resetValidFreepointers( );
unsigned long SgMultAssignOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDivAssignOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDivAssignOp* SgDivAssignOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDivAssignOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDivAssignOp* SgDivAssignOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDivAssignOp* SgDivAssignOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDivAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDivAssignOp_clearMemoryPool ( );
void SgDivAssignOp_extendMemoryPoolForFileIO ( );
unsigned long SgDivAssignOp_initializeStorageClassArray( SgDivAssignOpStorageClass *storageArray );
void SgDivAssignOp_resetValidFreepointers( );
unsigned long SgDivAssignOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgModAssignOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgModAssignOp* SgModAssignOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgModAssignOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgModAssignOp* SgModAssignOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgModAssignOp* SgModAssignOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgModAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgModAssignOp_clearMemoryPool ( );
void SgModAssignOp_extendMemoryPoolForFileIO ( );
unsigned long SgModAssignOp_initializeStorageClassArray( SgModAssignOpStorageClass *storageArray );
void SgModAssignOp_resetValidFreepointers( );
unsigned long SgModAssignOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgXorAssignOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgXorAssignOp* SgXorAssignOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgXorAssignOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgXorAssignOp* SgXorAssignOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgXorAssignOp* SgXorAssignOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgXorAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgXorAssignOp_clearMemoryPool ( );
void SgXorAssignOp_extendMemoryPoolForFileIO ( );
unsigned long SgXorAssignOp_initializeStorageClassArray( SgXorAssignOpStorageClass *storageArray );
void SgXorAssignOp_resetValidFreepointers( );
unsigned long SgXorAssignOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLshiftAssignOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLshiftAssignOp* SgLshiftAssignOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLshiftAssignOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLshiftAssignOp* SgLshiftAssignOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLshiftAssignOp* SgLshiftAssignOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLshiftAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLshiftAssignOp_clearMemoryPool ( );
void SgLshiftAssignOp_extendMemoryPoolForFileIO ( );
unsigned long SgLshiftAssignOp_initializeStorageClassArray( SgLshiftAssignOpStorageClass *storageArray );
void SgLshiftAssignOp_resetValidFreepointers( );
unsigned long SgLshiftAssignOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgRshiftAssignOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgRshiftAssignOp* SgRshiftAssignOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgRshiftAssignOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgRshiftAssignOp* SgRshiftAssignOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgRshiftAssignOp* SgRshiftAssignOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgRshiftAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgRshiftAssignOp_clearMemoryPool ( );
void SgRshiftAssignOp_extendMemoryPoolForFileIO ( );
unsigned long SgRshiftAssignOp_initializeStorageClassArray( SgRshiftAssignOpStorageClass *storageArray );
void SgRshiftAssignOp_resetValidFreepointers( );
unsigned long SgRshiftAssignOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJavaUnsignedRshiftAssignOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJavaUnsignedRshiftAssignOp* SgJavaUnsignedRshiftAssignOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJavaUnsignedRshiftAssignOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJavaUnsignedRshiftAssignOp* SgJavaUnsignedRshiftAssignOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJavaUnsignedRshiftAssignOp* SgJavaUnsignedRshiftAssignOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJavaUnsignedRshiftAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJavaUnsignedRshiftAssignOp_clearMemoryPool ( );
void SgJavaUnsignedRshiftAssignOp_extendMemoryPoolForFileIO ( );
unsigned long SgJavaUnsignedRshiftAssignOp_initializeStorageClassArray( SgJavaUnsignedRshiftAssignOpStorageClass *storageArray );
void SgJavaUnsignedRshiftAssignOp_resetValidFreepointers( );
unsigned long SgJavaUnsignedRshiftAssignOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIntegerDivideAssignOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIntegerDivideAssignOp* SgIntegerDivideAssignOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIntegerDivideAssignOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIntegerDivideAssignOp* SgIntegerDivideAssignOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIntegerDivideAssignOp* SgIntegerDivideAssignOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIntegerDivideAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIntegerDivideAssignOp_clearMemoryPool ( );
void SgIntegerDivideAssignOp_extendMemoryPoolForFileIO ( );
unsigned long SgIntegerDivideAssignOp_initializeStorageClassArray( SgIntegerDivideAssignOpStorageClass *storageArray );
void SgIntegerDivideAssignOp_resetValidFreepointers( );
unsigned long SgIntegerDivideAssignOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgExponentiationAssignOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgExponentiationAssignOp* SgExponentiationAssignOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgExponentiationAssignOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgExponentiationAssignOp* SgExponentiationAssignOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgExponentiationAssignOp* SgExponentiationAssignOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgExponentiationAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgExponentiationAssignOp_clearMemoryPool ( );
void SgExponentiationAssignOp_extendMemoryPoolForFileIO ( );
unsigned long SgExponentiationAssignOp_initializeStorageClassArray( SgExponentiationAssignOpStorageClass *storageArray );
void SgExponentiationAssignOp_resetValidFreepointers( );
unsigned long SgExponentiationAssignOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgMembershipOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgMembershipOp* SgMembershipOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgMembershipOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgMembershipOp* SgMembershipOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgMembershipOp* SgMembershipOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgMembershipOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgMembershipOp_clearMemoryPool ( );
void SgMembershipOp_extendMemoryPoolForFileIO ( );
unsigned long SgMembershipOp_initializeStorageClassArray( SgMembershipOpStorageClass *storageArray );
void SgMembershipOp_resetValidFreepointers( );
unsigned long SgMembershipOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNonMembershipOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNonMembershipOp* SgNonMembershipOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNonMembershipOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNonMembershipOp* SgNonMembershipOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNonMembershipOp* SgNonMembershipOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNonMembershipOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNonMembershipOp_clearMemoryPool ( );
void SgNonMembershipOp_extendMemoryPoolForFileIO ( );
unsigned long SgNonMembershipOp_initializeStorageClassArray( SgNonMembershipOpStorageClass *storageArray );
void SgNonMembershipOp_resetValidFreepointers( );
unsigned long SgNonMembershipOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIsOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIsOp* SgIsOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIsOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIsOp* SgIsOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIsOp* SgIsOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIsOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIsOp_clearMemoryPool ( );
void SgIsOp_extendMemoryPoolForFileIO ( );
unsigned long SgIsOp_initializeStorageClassArray( SgIsOpStorageClass *storageArray );
void SgIsOp_resetValidFreepointers( );
unsigned long SgIsOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIsNotOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIsNotOp* SgIsNotOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIsNotOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIsNotOp* SgIsNotOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIsNotOp* SgIsNotOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIsNotOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIsNotOp_clearMemoryPool ( );
void SgIsNotOp_extendMemoryPoolForFileIO ( );
unsigned long SgIsNotOp_initializeStorageClassArray( SgIsNotOpStorageClass *storageArray );
void SgIsNotOp_resetValidFreepointers( );
unsigned long SgIsNotOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgExprListExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgExprListExp* SgExprListExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgExprListExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgExprListExp* SgExprListExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgExprListExp* SgExprListExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgExprListExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgExprListExp_clearMemoryPool ( );
void SgExprListExp_extendMemoryPoolForFileIO ( );
unsigned long SgExprListExp_initializeStorageClassArray( SgExprListExpStorageClass *storageArray );
void SgExprListExp_resetValidFreepointers( );
unsigned long SgExprListExp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgListExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgListExp* SgListExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgListExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgListExp* SgListExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgListExp* SgListExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgListExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgListExp_clearMemoryPool ( );
void SgListExp_extendMemoryPoolForFileIO ( );
unsigned long SgListExp_initializeStorageClassArray( SgListExpStorageClass *storageArray );
void SgListExp_resetValidFreepointers( );
unsigned long SgListExp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTupleExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTupleExp* SgTupleExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTupleExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTupleExp* SgTupleExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTupleExp* SgTupleExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTupleExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTupleExp_clearMemoryPool ( );
void SgTupleExp_extendMemoryPoolForFileIO ( );
unsigned long SgTupleExp_initializeStorageClassArray( SgTupleExpStorageClass *storageArray );
void SgTupleExp_resetValidFreepointers( );
unsigned long SgTupleExp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgVarRefExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgVarRefExp* SgVarRefExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgVarRefExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgVarRefExp* SgVarRefExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgVarRefExp* SgVarRefExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgVarRefExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgVarRefExp_clearMemoryPool ( );
void SgVarRefExp_extendMemoryPoolForFileIO ( );
unsigned long SgVarRefExp_initializeStorageClassArray( SgVarRefExpStorageClass *storageArray );
void SgVarRefExp_resetValidFreepointers( );
unsigned long SgVarRefExp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgClassNameRefExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgClassNameRefExp* SgClassNameRefExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgClassNameRefExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgClassNameRefExp* SgClassNameRefExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgClassNameRefExp* SgClassNameRefExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgClassNameRefExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgClassNameRefExp_clearMemoryPool ( );
void SgClassNameRefExp_extendMemoryPoolForFileIO ( );
unsigned long SgClassNameRefExp_initializeStorageClassArray( SgClassNameRefExpStorageClass *storageArray );
void SgClassNameRefExp_resetValidFreepointers( );
unsigned long SgClassNameRefExp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFunctionRefExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFunctionRefExp* SgFunctionRefExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFunctionRefExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFunctionRefExp* SgFunctionRefExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFunctionRefExp* SgFunctionRefExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFunctionRefExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFunctionRefExp_clearMemoryPool ( );
void SgFunctionRefExp_extendMemoryPoolForFileIO ( );
unsigned long SgFunctionRefExp_initializeStorageClassArray( SgFunctionRefExpStorageClass *storageArray );
void SgFunctionRefExp_resetValidFreepointers( );
unsigned long SgFunctionRefExp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgMemberFunctionRefExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgMemberFunctionRefExp* SgMemberFunctionRefExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgMemberFunctionRefExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgMemberFunctionRefExp* SgMemberFunctionRefExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgMemberFunctionRefExp* SgMemberFunctionRefExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgMemberFunctionRefExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgMemberFunctionRefExp_clearMemoryPool ( );
void SgMemberFunctionRefExp_extendMemoryPoolForFileIO ( );
unsigned long SgMemberFunctionRefExp_initializeStorageClassArray( SgMemberFunctionRefExpStorageClass *storageArray );
void SgMemberFunctionRefExp_resetValidFreepointers( );
unsigned long SgMemberFunctionRefExp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgValueExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgValueExp* SgValueExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgValueExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgValueExp* SgValueExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgValueExp* SgValueExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgValueExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgValueExp_clearMemoryPool ( );
void SgValueExp_extendMemoryPoolForFileIO ( );
unsigned long SgValueExp_initializeStorageClassArray( SgValueExpStorageClass *storageArray );
void SgValueExp_resetValidFreepointers( );
unsigned long SgValueExp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgBoolValExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgBoolValExp* SgBoolValExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgBoolValExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgBoolValExp* SgBoolValExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgBoolValExp* SgBoolValExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgBoolValExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgBoolValExp_clearMemoryPool ( );
void SgBoolValExp_extendMemoryPoolForFileIO ( );
unsigned long SgBoolValExp_initializeStorageClassArray( SgBoolValExpStorageClass *storageArray );
void SgBoolValExp_resetValidFreepointers( );
unsigned long SgBoolValExp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgStringVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgStringVal* SgStringVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgStringVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgStringVal* SgStringVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgStringVal* SgStringVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgStringVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgStringVal_clearMemoryPool ( );
void SgStringVal_extendMemoryPoolForFileIO ( );
unsigned long SgStringVal_initializeStorageClassArray( SgStringValStorageClass *storageArray );
void SgStringVal_resetValidFreepointers( );
unsigned long SgStringVal_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgShortVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgShortVal* SgShortVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgShortVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgShortVal* SgShortVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgShortVal* SgShortVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgShortVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgShortVal_clearMemoryPool ( );
void SgShortVal_extendMemoryPoolForFileIO ( );
unsigned long SgShortVal_initializeStorageClassArray( SgShortValStorageClass *storageArray );
void SgShortVal_resetValidFreepointers( );
unsigned long SgShortVal_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCharVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCharVal* SgCharVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCharVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCharVal* SgCharVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCharVal* SgCharVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCharVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCharVal_clearMemoryPool ( );
void SgCharVal_extendMemoryPoolForFileIO ( );
unsigned long SgCharVal_initializeStorageClassArray( SgCharValStorageClass *storageArray );
void SgCharVal_resetValidFreepointers( );
unsigned long SgCharVal_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUnsignedCharVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUnsignedCharVal* SgUnsignedCharVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUnsignedCharVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUnsignedCharVal* SgUnsignedCharVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUnsignedCharVal* SgUnsignedCharVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUnsignedCharVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUnsignedCharVal_clearMemoryPool ( );
void SgUnsignedCharVal_extendMemoryPoolForFileIO ( );
unsigned long SgUnsignedCharVal_initializeStorageClassArray( SgUnsignedCharValStorageClass *storageArray );
void SgUnsignedCharVal_resetValidFreepointers( );
unsigned long SgUnsignedCharVal_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgWcharVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgWcharVal* SgWcharVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgWcharVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgWcharVal* SgWcharVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgWcharVal* SgWcharVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgWcharVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgWcharVal_clearMemoryPool ( );
void SgWcharVal_extendMemoryPoolForFileIO ( );
unsigned long SgWcharVal_initializeStorageClassArray( SgWcharValStorageClass *storageArray );
void SgWcharVal_resetValidFreepointers( );
unsigned long SgWcharVal_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUnsignedShortVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUnsignedShortVal* SgUnsignedShortVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUnsignedShortVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUnsignedShortVal* SgUnsignedShortVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUnsignedShortVal* SgUnsignedShortVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUnsignedShortVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUnsignedShortVal_clearMemoryPool ( );
void SgUnsignedShortVal_extendMemoryPoolForFileIO ( );
unsigned long SgUnsignedShortVal_initializeStorageClassArray( SgUnsignedShortValStorageClass *storageArray );
void SgUnsignedShortVal_resetValidFreepointers( );
unsigned long SgUnsignedShortVal_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIntVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIntVal* SgIntVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIntVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIntVal* SgIntVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIntVal* SgIntVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIntVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIntVal_clearMemoryPool ( );
void SgIntVal_extendMemoryPoolForFileIO ( );
unsigned long SgIntVal_initializeStorageClassArray( SgIntValStorageClass *storageArray );
void SgIntVal_resetValidFreepointers( );
unsigned long SgIntVal_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgEnumVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgEnumVal* SgEnumVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgEnumVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgEnumVal* SgEnumVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgEnumVal* SgEnumVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgEnumVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgEnumVal_clearMemoryPool ( );
void SgEnumVal_extendMemoryPoolForFileIO ( );
unsigned long SgEnumVal_initializeStorageClassArray( SgEnumValStorageClass *storageArray );
void SgEnumVal_resetValidFreepointers( );
unsigned long SgEnumVal_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUnsignedIntVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUnsignedIntVal* SgUnsignedIntVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUnsignedIntVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUnsignedIntVal* SgUnsignedIntVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUnsignedIntVal* SgUnsignedIntVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUnsignedIntVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUnsignedIntVal_clearMemoryPool ( );
void SgUnsignedIntVal_extendMemoryPoolForFileIO ( );
unsigned long SgUnsignedIntVal_initializeStorageClassArray( SgUnsignedIntValStorageClass *storageArray );
void SgUnsignedIntVal_resetValidFreepointers( );
unsigned long SgUnsignedIntVal_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLongIntVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLongIntVal* SgLongIntVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLongIntVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLongIntVal* SgLongIntVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLongIntVal* SgLongIntVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLongIntVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLongIntVal_clearMemoryPool ( );
void SgLongIntVal_extendMemoryPoolForFileIO ( );
unsigned long SgLongIntVal_initializeStorageClassArray( SgLongIntValStorageClass *storageArray );
void SgLongIntVal_resetValidFreepointers( );
unsigned long SgLongIntVal_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLongLongIntVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLongLongIntVal* SgLongLongIntVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLongLongIntVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLongLongIntVal* SgLongLongIntVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLongLongIntVal* SgLongLongIntVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLongLongIntVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLongLongIntVal_clearMemoryPool ( );
void SgLongLongIntVal_extendMemoryPoolForFileIO ( );
unsigned long SgLongLongIntVal_initializeStorageClassArray( SgLongLongIntValStorageClass *storageArray );
void SgLongLongIntVal_resetValidFreepointers( );
unsigned long SgLongLongIntVal_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUnsignedLongLongIntVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUnsignedLongLongIntVal* SgUnsignedLongLongIntVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUnsignedLongLongIntVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUnsignedLongLongIntVal* SgUnsignedLongLongIntVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUnsignedLongLongIntVal* SgUnsignedLongLongIntVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUnsignedLongLongIntVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUnsignedLongLongIntVal_clearMemoryPool ( );
void SgUnsignedLongLongIntVal_extendMemoryPoolForFileIO ( );
unsigned long SgUnsignedLongLongIntVal_initializeStorageClassArray( SgUnsignedLongLongIntValStorageClass *storageArray );
void SgUnsignedLongLongIntVal_resetValidFreepointers( );
unsigned long SgUnsignedLongLongIntVal_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUnsignedLongVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUnsignedLongVal* SgUnsignedLongVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUnsignedLongVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUnsignedLongVal* SgUnsignedLongVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUnsignedLongVal* SgUnsignedLongVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUnsignedLongVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUnsignedLongVal_clearMemoryPool ( );
void SgUnsignedLongVal_extendMemoryPoolForFileIO ( );
unsigned long SgUnsignedLongVal_initializeStorageClassArray( SgUnsignedLongValStorageClass *storageArray );
void SgUnsignedLongVal_resetValidFreepointers( );
unsigned long SgUnsignedLongVal_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFloatVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFloatVal* SgFloatVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFloatVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFloatVal* SgFloatVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFloatVal* SgFloatVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFloatVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFloatVal_clearMemoryPool ( );
void SgFloatVal_extendMemoryPoolForFileIO ( );
unsigned long SgFloatVal_initializeStorageClassArray( SgFloatValStorageClass *storageArray );
void SgFloatVal_resetValidFreepointers( );
unsigned long SgFloatVal_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDoubleVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDoubleVal* SgDoubleVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDoubleVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDoubleVal* SgDoubleVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDoubleVal* SgDoubleVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDoubleVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDoubleVal_clearMemoryPool ( );
void SgDoubleVal_extendMemoryPoolForFileIO ( );
unsigned long SgDoubleVal_initializeStorageClassArray( SgDoubleValStorageClass *storageArray );
void SgDoubleVal_resetValidFreepointers( );
unsigned long SgDoubleVal_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLongDoubleVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLongDoubleVal* SgLongDoubleVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLongDoubleVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLongDoubleVal* SgLongDoubleVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLongDoubleVal* SgLongDoubleVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLongDoubleVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLongDoubleVal_clearMemoryPool ( );
void SgLongDoubleVal_extendMemoryPoolForFileIO ( );
unsigned long SgLongDoubleVal_initializeStorageClassArray( SgLongDoubleValStorageClass *storageArray );
void SgLongDoubleVal_resetValidFreepointers( );
unsigned long SgLongDoubleVal_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgComplexVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgComplexVal* SgComplexVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgComplexVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgComplexVal* SgComplexVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgComplexVal* SgComplexVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgComplexVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgComplexVal_clearMemoryPool ( );
void SgComplexVal_extendMemoryPoolForFileIO ( );
unsigned long SgComplexVal_initializeStorageClassArray( SgComplexValStorageClass *storageArray );
void SgComplexVal_resetValidFreepointers( );
unsigned long SgComplexVal_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUpcThreads_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUpcThreads* SgUpcThreads_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUpcThreads_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUpcThreads* SgUpcThreads_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUpcThreads* SgUpcThreads_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUpcThreads_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUpcThreads_clearMemoryPool ( );
void SgUpcThreads_extendMemoryPoolForFileIO ( );
unsigned long SgUpcThreads_initializeStorageClassArray( SgUpcThreadsStorageClass *storageArray );
void SgUpcThreads_resetValidFreepointers( );
unsigned long SgUpcThreads_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUpcMythread_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUpcMythread* SgUpcMythread_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUpcMythread_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUpcMythread* SgUpcMythread_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUpcMythread* SgUpcMythread_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUpcMythread_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUpcMythread_clearMemoryPool ( );
void SgUpcMythread_extendMemoryPoolForFileIO ( );
unsigned long SgUpcMythread_initializeStorageClassArray( SgUpcMythreadStorageClass *storageArray );
void SgUpcMythread_resetValidFreepointers( );
unsigned long SgUpcMythread_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCallExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCallExpression* SgCallExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCallExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCallExpression* SgCallExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCallExpression* SgCallExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCallExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCallExpression_clearMemoryPool ( );
void SgCallExpression_extendMemoryPoolForFileIO ( );
unsigned long SgCallExpression_initializeStorageClassArray( SgCallExpressionStorageClass *storageArray );
void SgCallExpression_resetValidFreepointers( );
unsigned long SgCallExpression_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFunctionCallExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFunctionCallExp* SgFunctionCallExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFunctionCallExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFunctionCallExp* SgFunctionCallExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFunctionCallExp* SgFunctionCallExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFunctionCallExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFunctionCallExp_clearMemoryPool ( );
void SgFunctionCallExp_extendMemoryPoolForFileIO ( );
unsigned long SgFunctionCallExp_initializeStorageClassArray( SgFunctionCallExpStorageClass *storageArray );
void SgFunctionCallExp_resetValidFreepointers( );
unsigned long SgFunctionCallExp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgSizeOfOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgSizeOfOp* SgSizeOfOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgSizeOfOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgSizeOfOp* SgSizeOfOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgSizeOfOp* SgSizeOfOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgSizeOfOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgSizeOfOp_clearMemoryPool ( );
void SgSizeOfOp_extendMemoryPoolForFileIO ( );
unsigned long SgSizeOfOp_initializeStorageClassArray( SgSizeOfOpStorageClass *storageArray );
void SgSizeOfOp_resetValidFreepointers( );
unsigned long SgSizeOfOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUpcLocalsizeofExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUpcLocalsizeofExpression* SgUpcLocalsizeofExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUpcLocalsizeofExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUpcLocalsizeofExpression* SgUpcLocalsizeofExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUpcLocalsizeofExpression* SgUpcLocalsizeofExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUpcLocalsizeofExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUpcLocalsizeofExpression_clearMemoryPool ( );
void SgUpcLocalsizeofExpression_extendMemoryPoolForFileIO ( );
unsigned long SgUpcLocalsizeofExpression_initializeStorageClassArray( SgUpcLocalsizeofExpressionStorageClass *storageArray );
void SgUpcLocalsizeofExpression_resetValidFreepointers( );
unsigned long SgUpcLocalsizeofExpression_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUpcBlocksizeofExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUpcBlocksizeofExpression* SgUpcBlocksizeofExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUpcBlocksizeofExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUpcBlocksizeofExpression* SgUpcBlocksizeofExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUpcBlocksizeofExpression* SgUpcBlocksizeofExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUpcBlocksizeofExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUpcBlocksizeofExpression_clearMemoryPool ( );
void SgUpcBlocksizeofExpression_extendMemoryPoolForFileIO ( );
unsigned long SgUpcBlocksizeofExpression_initializeStorageClassArray( SgUpcBlocksizeofExpressionStorageClass *storageArray );
void SgUpcBlocksizeofExpression_resetValidFreepointers( );
unsigned long SgUpcBlocksizeofExpression_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUpcElemsizeofExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUpcElemsizeofExpression* SgUpcElemsizeofExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUpcElemsizeofExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUpcElemsizeofExpression* SgUpcElemsizeofExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUpcElemsizeofExpression* SgUpcElemsizeofExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUpcElemsizeofExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUpcElemsizeofExpression_clearMemoryPool ( );
void SgUpcElemsizeofExpression_extendMemoryPoolForFileIO ( );
unsigned long SgUpcElemsizeofExpression_initializeStorageClassArray( SgUpcElemsizeofExpressionStorageClass *storageArray );
void SgUpcElemsizeofExpression_resetValidFreepointers( );
unsigned long SgUpcElemsizeofExpression_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJavaInstanceOfOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJavaInstanceOfOp* SgJavaInstanceOfOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJavaInstanceOfOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJavaInstanceOfOp* SgJavaInstanceOfOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJavaInstanceOfOp* SgJavaInstanceOfOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJavaInstanceOfOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJavaInstanceOfOp_clearMemoryPool ( );
void SgJavaInstanceOfOp_extendMemoryPoolForFileIO ( );
unsigned long SgJavaInstanceOfOp_initializeStorageClassArray( SgJavaInstanceOfOpStorageClass *storageArray );
void SgJavaInstanceOfOp_resetValidFreepointers( );
unsigned long SgJavaInstanceOfOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgSuperExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgSuperExp* SgSuperExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgSuperExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgSuperExp* SgSuperExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgSuperExp* SgSuperExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgSuperExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgSuperExp_clearMemoryPool ( );
void SgSuperExp_extendMemoryPoolForFileIO ( );
unsigned long SgSuperExp_initializeStorageClassArray( SgSuperExpStorageClass *storageArray );
void SgSuperExp_resetValidFreepointers( );
unsigned long SgSuperExp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeIdOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeIdOp* SgTypeIdOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeIdOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeIdOp* SgTypeIdOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeIdOp* SgTypeIdOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeIdOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeIdOp_clearMemoryPool ( );
void SgTypeIdOp_extendMemoryPoolForFileIO ( );
unsigned long SgTypeIdOp_initializeStorageClassArray( SgTypeIdOpStorageClass *storageArray );
void SgTypeIdOp_resetValidFreepointers( );
unsigned long SgTypeIdOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgConditionalExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgConditionalExp* SgConditionalExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgConditionalExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgConditionalExp* SgConditionalExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgConditionalExp* SgConditionalExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgConditionalExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgConditionalExp_clearMemoryPool ( );
void SgConditionalExp_extendMemoryPoolForFileIO ( );
unsigned long SgConditionalExp_initializeStorageClassArray( SgConditionalExpStorageClass *storageArray );
void SgConditionalExp_resetValidFreepointers( );
unsigned long SgConditionalExp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNewExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNewExp* SgNewExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNewExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNewExp* SgNewExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNewExp* SgNewExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNewExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNewExp_clearMemoryPool ( );
void SgNewExp_extendMemoryPoolForFileIO ( );
unsigned long SgNewExp_initializeStorageClassArray( SgNewExpStorageClass *storageArray );
void SgNewExp_resetValidFreepointers( );
unsigned long SgNewExp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDeleteExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDeleteExp* SgDeleteExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDeleteExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDeleteExp* SgDeleteExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDeleteExp* SgDeleteExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDeleteExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDeleteExp_clearMemoryPool ( );
void SgDeleteExp_extendMemoryPoolForFileIO ( );
unsigned long SgDeleteExp_initializeStorageClassArray( SgDeleteExpStorageClass *storageArray );
void SgDeleteExp_resetValidFreepointers( );
unsigned long SgDeleteExp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgThisExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgThisExp* SgThisExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgThisExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgThisExp* SgThisExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgThisExp* SgThisExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgThisExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgThisExp_clearMemoryPool ( );
void SgThisExp_extendMemoryPoolForFileIO ( );
unsigned long SgThisExp_initializeStorageClassArray( SgThisExpStorageClass *storageArray );
void SgThisExp_resetValidFreepointers( );
unsigned long SgThisExp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgRefExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgRefExp* SgRefExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgRefExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgRefExp* SgRefExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgRefExp* SgRefExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgRefExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgRefExp_clearMemoryPool ( );
void SgRefExp_extendMemoryPoolForFileIO ( );
unsigned long SgRefExp_initializeStorageClassArray( SgRefExpStorageClass *storageArray );
void SgRefExp_resetValidFreepointers( );
unsigned long SgRefExp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgInitializer_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgInitializer* SgInitializer_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgInitializer_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgInitializer* SgInitializer_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgInitializer* SgInitializer_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgInitializer_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgInitializer_clearMemoryPool ( );
void SgInitializer_extendMemoryPoolForFileIO ( );
unsigned long SgInitializer_initializeStorageClassArray( SgInitializerStorageClass *storageArray );
void SgInitializer_resetValidFreepointers( );
unsigned long SgInitializer_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAggregateInitializer_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAggregateInitializer* SgAggregateInitializer_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAggregateInitializer_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAggregateInitializer* SgAggregateInitializer_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAggregateInitializer* SgAggregateInitializer_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAggregateInitializer_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAggregateInitializer_clearMemoryPool ( );
void SgAggregateInitializer_extendMemoryPoolForFileIO ( );
unsigned long SgAggregateInitializer_initializeStorageClassArray( SgAggregateInitializerStorageClass *storageArray );
void SgAggregateInitializer_resetValidFreepointers( );
unsigned long SgAggregateInitializer_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCompoundInitializer_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCompoundInitializer* SgCompoundInitializer_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCompoundInitializer_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCompoundInitializer* SgCompoundInitializer_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCompoundInitializer* SgCompoundInitializer_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCompoundInitializer_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCompoundInitializer_clearMemoryPool ( );
void SgCompoundInitializer_extendMemoryPoolForFileIO ( );
unsigned long SgCompoundInitializer_initializeStorageClassArray( SgCompoundInitializerStorageClass *storageArray );
void SgCompoundInitializer_resetValidFreepointers( );
unsigned long SgCompoundInitializer_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgConstructorInitializer_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgConstructorInitializer* SgConstructorInitializer_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgConstructorInitializer_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgConstructorInitializer* SgConstructorInitializer_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgConstructorInitializer* SgConstructorInitializer_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgConstructorInitializer_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgConstructorInitializer_clearMemoryPool ( );
void SgConstructorInitializer_extendMemoryPoolForFileIO ( );
unsigned long SgConstructorInitializer_initializeStorageClassArray( SgConstructorInitializerStorageClass *storageArray );
void SgConstructorInitializer_resetValidFreepointers( );
unsigned long SgConstructorInitializer_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAssignInitializer_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAssignInitializer* SgAssignInitializer_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAssignInitializer_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAssignInitializer* SgAssignInitializer_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAssignInitializer* SgAssignInitializer_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAssignInitializer_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAssignInitializer_clearMemoryPool ( );
void SgAssignInitializer_extendMemoryPoolForFileIO ( );
unsigned long SgAssignInitializer_initializeStorageClassArray( SgAssignInitializerStorageClass *storageArray );
void SgAssignInitializer_resetValidFreepointers( );
unsigned long SgAssignInitializer_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDesignatedInitializer_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDesignatedInitializer* SgDesignatedInitializer_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDesignatedInitializer_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDesignatedInitializer* SgDesignatedInitializer_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDesignatedInitializer* SgDesignatedInitializer_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDesignatedInitializer_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDesignatedInitializer_clearMemoryPool ( );
void SgDesignatedInitializer_extendMemoryPoolForFileIO ( );
unsigned long SgDesignatedInitializer_initializeStorageClassArray( SgDesignatedInitializerStorageClass *storageArray );
void SgDesignatedInitializer_resetValidFreepointers( );
unsigned long SgDesignatedInitializer_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgVarArgStartOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgVarArgStartOp* SgVarArgStartOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgVarArgStartOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgVarArgStartOp* SgVarArgStartOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgVarArgStartOp* SgVarArgStartOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgVarArgStartOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgVarArgStartOp_clearMemoryPool ( );
void SgVarArgStartOp_extendMemoryPoolForFileIO ( );
unsigned long SgVarArgStartOp_initializeStorageClassArray( SgVarArgStartOpStorageClass *storageArray );
void SgVarArgStartOp_resetValidFreepointers( );
unsigned long SgVarArgStartOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgVarArgOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgVarArgOp* SgVarArgOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgVarArgOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgVarArgOp* SgVarArgOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgVarArgOp* SgVarArgOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgVarArgOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgVarArgOp_clearMemoryPool ( );
void SgVarArgOp_extendMemoryPoolForFileIO ( );
unsigned long SgVarArgOp_initializeStorageClassArray( SgVarArgOpStorageClass *storageArray );
void SgVarArgOp_resetValidFreepointers( );
unsigned long SgVarArgOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgVarArgEndOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgVarArgEndOp* SgVarArgEndOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgVarArgEndOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgVarArgEndOp* SgVarArgEndOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgVarArgEndOp* SgVarArgEndOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgVarArgEndOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgVarArgEndOp_clearMemoryPool ( );
void SgVarArgEndOp_extendMemoryPoolForFileIO ( );
unsigned long SgVarArgEndOp_initializeStorageClassArray( SgVarArgEndOpStorageClass *storageArray );
void SgVarArgEndOp_resetValidFreepointers( );
unsigned long SgVarArgEndOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgVarArgCopyOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgVarArgCopyOp* SgVarArgCopyOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgVarArgCopyOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgVarArgCopyOp* SgVarArgCopyOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgVarArgCopyOp* SgVarArgCopyOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgVarArgCopyOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgVarArgCopyOp_clearMemoryPool ( );
void SgVarArgCopyOp_extendMemoryPoolForFileIO ( );
unsigned long SgVarArgCopyOp_initializeStorageClassArray( SgVarArgCopyOpStorageClass *storageArray );
void SgVarArgCopyOp_resetValidFreepointers( );
unsigned long SgVarArgCopyOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgVarArgStartOneOperandOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgVarArgStartOneOperandOp* SgVarArgStartOneOperandOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgVarArgStartOneOperandOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgVarArgStartOneOperandOp* SgVarArgStartOneOperandOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgVarArgStartOneOperandOp* SgVarArgStartOneOperandOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgVarArgStartOneOperandOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgVarArgStartOneOperandOp_clearMemoryPool ( );
void SgVarArgStartOneOperandOp_extendMemoryPoolForFileIO ( );
unsigned long SgVarArgStartOneOperandOp_initializeStorageClassArray( SgVarArgStartOneOperandOpStorageClass *storageArray );
void SgVarArgStartOneOperandOp_resetValidFreepointers( );
unsigned long SgVarArgStartOneOperandOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNullExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNullExpression* SgNullExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNullExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNullExpression* SgNullExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNullExpression* SgNullExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNullExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNullExpression_clearMemoryPool ( );
void SgNullExpression_extendMemoryPoolForFileIO ( );
unsigned long SgNullExpression_initializeStorageClassArray( SgNullExpressionStorageClass *storageArray );
void SgNullExpression_resetValidFreepointers( );
unsigned long SgNullExpression_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgVariantExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgVariantExpression* SgVariantExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgVariantExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgVariantExpression* SgVariantExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgVariantExpression* SgVariantExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgVariantExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgVariantExpression_clearMemoryPool ( );
void SgVariantExpression_extendMemoryPoolForFileIO ( );
unsigned long SgVariantExpression_initializeStorageClassArray( SgVariantExpressionStorageClass *storageArray );
void SgVariantExpression_resetValidFreepointers( );
unsigned long SgVariantExpression_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgSubscriptExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgSubscriptExpression* SgSubscriptExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgSubscriptExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgSubscriptExpression* SgSubscriptExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgSubscriptExpression* SgSubscriptExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgSubscriptExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgSubscriptExpression_clearMemoryPool ( );
void SgSubscriptExpression_extendMemoryPoolForFileIO ( );
unsigned long SgSubscriptExpression_initializeStorageClassArray( SgSubscriptExpressionStorageClass *storageArray );
void SgSubscriptExpression_resetValidFreepointers( );
unsigned long SgSubscriptExpression_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgColonShapeExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgColonShapeExp* SgColonShapeExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgColonShapeExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgColonShapeExp* SgColonShapeExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgColonShapeExp* SgColonShapeExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgColonShapeExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgColonShapeExp_clearMemoryPool ( );
void SgColonShapeExp_extendMemoryPoolForFileIO ( );
unsigned long SgColonShapeExp_initializeStorageClassArray( SgColonShapeExpStorageClass *storageArray );
void SgColonShapeExp_resetValidFreepointers( );
unsigned long SgColonShapeExp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsteriskShapeExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsteriskShapeExp* SgAsteriskShapeExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsteriskShapeExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsteriskShapeExp* SgAsteriskShapeExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsteriskShapeExp* SgAsteriskShapeExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsteriskShapeExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsteriskShapeExp_clearMemoryPool ( );
void SgAsteriskShapeExp_extendMemoryPoolForFileIO ( );
unsigned long SgAsteriskShapeExp_initializeStorageClassArray( SgAsteriskShapeExpStorageClass *storageArray );
void SgAsteriskShapeExp_resetValidFreepointers( );
unsigned long SgAsteriskShapeExp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgImpliedDo_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgImpliedDo* SgImpliedDo_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgImpliedDo_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgImpliedDo* SgImpliedDo_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgImpliedDo* SgImpliedDo_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgImpliedDo_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgImpliedDo_clearMemoryPool ( );
void SgImpliedDo_extendMemoryPoolForFileIO ( );
unsigned long SgImpliedDo_initializeStorageClassArray( SgImpliedDoStorageClass *storageArray );
void SgImpliedDo_resetValidFreepointers( );
unsigned long SgImpliedDo_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIOItemExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIOItemExpression* SgIOItemExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIOItemExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIOItemExpression* SgIOItemExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIOItemExpression* SgIOItemExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIOItemExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIOItemExpression_clearMemoryPool ( );
void SgIOItemExpression_extendMemoryPoolForFileIO ( );
unsigned long SgIOItemExpression_initializeStorageClassArray( SgIOItemExpressionStorageClass *storageArray );
void SgIOItemExpression_resetValidFreepointers( );
unsigned long SgIOItemExpression_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgStatementExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgStatementExpression* SgStatementExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgStatementExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgStatementExpression* SgStatementExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgStatementExpression* SgStatementExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgStatementExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgStatementExpression_clearMemoryPool ( );
void SgStatementExpression_extendMemoryPoolForFileIO ( );
unsigned long SgStatementExpression_initializeStorageClassArray( SgStatementExpressionStorageClass *storageArray );
void SgStatementExpression_resetValidFreepointers( );
unsigned long SgStatementExpression_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmOp* SgAsmOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmOp* SgAsmOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmOp* SgAsmOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmOp_clearMemoryPool ( );
void SgAsmOp_extendMemoryPoolForFileIO ( );
unsigned long SgAsmOp_initializeStorageClassArray( SgAsmOpStorageClass *storageArray );
void SgAsmOp_resetValidFreepointers( );
unsigned long SgAsmOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLabelRefExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLabelRefExp* SgLabelRefExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLabelRefExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLabelRefExp* SgLabelRefExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLabelRefExp* SgLabelRefExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLabelRefExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLabelRefExp_clearMemoryPool ( );
void SgLabelRefExp_extendMemoryPoolForFileIO ( );
unsigned long SgLabelRefExp_initializeStorageClassArray( SgLabelRefExpStorageClass *storageArray );
void SgLabelRefExp_resetValidFreepointers( );
unsigned long SgLabelRefExp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgActualArgumentExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgActualArgumentExpression* SgActualArgumentExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgActualArgumentExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgActualArgumentExpression* SgActualArgumentExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgActualArgumentExpression* SgActualArgumentExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgActualArgumentExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgActualArgumentExpression_clearMemoryPool ( );
void SgActualArgumentExpression_extendMemoryPoolForFileIO ( );
unsigned long SgActualArgumentExpression_initializeStorageClassArray( SgActualArgumentExpressionStorageClass *storageArray );
void SgActualArgumentExpression_resetValidFreepointers( );
unsigned long SgActualArgumentExpression_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUnknownArrayOrFunctionReference_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUnknownArrayOrFunctionReference* SgUnknownArrayOrFunctionReference_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUnknownArrayOrFunctionReference_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUnknownArrayOrFunctionReference* SgUnknownArrayOrFunctionReference_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUnknownArrayOrFunctionReference* SgUnknownArrayOrFunctionReference_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUnknownArrayOrFunctionReference_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUnknownArrayOrFunctionReference_clearMemoryPool ( );
void SgUnknownArrayOrFunctionReference_extendMemoryPoolForFileIO ( );
unsigned long SgUnknownArrayOrFunctionReference_initializeStorageClassArray( SgUnknownArrayOrFunctionReferenceStorageClass *storageArray );
void SgUnknownArrayOrFunctionReference_resetValidFreepointers( );
unsigned long SgUnknownArrayOrFunctionReference_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgPseudoDestructorRefExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgPseudoDestructorRefExp* SgPseudoDestructorRefExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgPseudoDestructorRefExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgPseudoDestructorRefExp* SgPseudoDestructorRefExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgPseudoDestructorRefExp* SgPseudoDestructorRefExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgPseudoDestructorRefExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgPseudoDestructorRefExp_clearMemoryPool ( );
void SgPseudoDestructorRefExp_extendMemoryPoolForFileIO ( );
unsigned long SgPseudoDestructorRefExp_initializeStorageClassArray( SgPseudoDestructorRefExpStorageClass *storageArray );
void SgPseudoDestructorRefExp_resetValidFreepointers( );
unsigned long SgPseudoDestructorRefExp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCAFCoExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCAFCoExpression* SgCAFCoExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCAFCoExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCAFCoExpression* SgCAFCoExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCAFCoExpression* SgCAFCoExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCAFCoExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCAFCoExpression_clearMemoryPool ( );
void SgCAFCoExpression_extendMemoryPoolForFileIO ( );
unsigned long SgCAFCoExpression_initializeStorageClassArray( SgCAFCoExpressionStorageClass *storageArray );
void SgCAFCoExpression_resetValidFreepointers( );
unsigned long SgCAFCoExpression_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCudaKernelCallExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCudaKernelCallExp* SgCudaKernelCallExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCudaKernelCallExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCudaKernelCallExp* SgCudaKernelCallExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCudaKernelCallExp* SgCudaKernelCallExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCudaKernelCallExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCudaKernelCallExp_clearMemoryPool ( );
void SgCudaKernelCallExp_extendMemoryPoolForFileIO ( );
unsigned long SgCudaKernelCallExp_initializeStorageClassArray( SgCudaKernelCallExpStorageClass *storageArray );
void SgCudaKernelCallExp_resetValidFreepointers( );
unsigned long SgCudaKernelCallExp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCudaKernelExecConfig_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCudaKernelExecConfig* SgCudaKernelExecConfig_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCudaKernelExecConfig_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCudaKernelExecConfig* SgCudaKernelExecConfig_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCudaKernelExecConfig* SgCudaKernelExecConfig_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCudaKernelExecConfig_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCudaKernelExecConfig_clearMemoryPool ( );
void SgCudaKernelExecConfig_extendMemoryPoolForFileIO ( );
unsigned long SgCudaKernelExecConfig_initializeStorageClassArray( SgCudaKernelExecConfigStorageClass *storageArray );
void SgCudaKernelExecConfig_resetValidFreepointers( );
unsigned long SgCudaKernelExecConfig_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLambdaRefExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLambdaRefExp* SgLambdaRefExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLambdaRefExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLambdaRefExp* SgLambdaRefExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLambdaRefExp* SgLambdaRefExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLambdaRefExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLambdaRefExp_clearMemoryPool ( );
void SgLambdaRefExp_extendMemoryPoolForFileIO ( );
unsigned long SgLambdaRefExp_initializeStorageClassArray( SgLambdaRefExpStorageClass *storageArray );
void SgLambdaRefExp_resetValidFreepointers( );
unsigned long SgLambdaRefExp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDictionaryExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDictionaryExp* SgDictionaryExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDictionaryExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDictionaryExp* SgDictionaryExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDictionaryExp* SgDictionaryExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDictionaryExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDictionaryExp_clearMemoryPool ( );
void SgDictionaryExp_extendMemoryPoolForFileIO ( );
unsigned long SgDictionaryExp_initializeStorageClassArray( SgDictionaryExpStorageClass *storageArray );
void SgDictionaryExp_resetValidFreepointers( );
unsigned long SgDictionaryExp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgKeyDatumPair_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgKeyDatumPair* SgKeyDatumPair_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgKeyDatumPair_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgKeyDatumPair* SgKeyDatumPair_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgKeyDatumPair* SgKeyDatumPair_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgKeyDatumPair_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgKeyDatumPair_clearMemoryPool ( );
void SgKeyDatumPair_extendMemoryPoolForFileIO ( );
unsigned long SgKeyDatumPair_initializeStorageClassArray( SgKeyDatumPairStorageClass *storageArray );
void SgKeyDatumPair_resetValidFreepointers( );
unsigned long SgKeyDatumPair_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgComprehension_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgComprehension* SgComprehension_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgComprehension_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgComprehension* SgComprehension_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgComprehension* SgComprehension_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgComprehension_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgComprehension_clearMemoryPool ( );
void SgComprehension_extendMemoryPoolForFileIO ( );
unsigned long SgComprehension_initializeStorageClassArray( SgComprehensionStorageClass *storageArray );
void SgComprehension_resetValidFreepointers( );
unsigned long SgComprehension_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgListComprehension_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgListComprehension* SgListComprehension_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgListComprehension_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgListComprehension* SgListComprehension_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgListComprehension* SgListComprehension_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgListComprehension_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgListComprehension_clearMemoryPool ( );
void SgListComprehension_extendMemoryPoolForFileIO ( );
unsigned long SgListComprehension_initializeStorageClassArray( SgListComprehensionStorageClass *storageArray );
void SgListComprehension_resetValidFreepointers( );
unsigned long SgListComprehension_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgSetComprehension_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgSetComprehension* SgSetComprehension_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgSetComprehension_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgSetComprehension* SgSetComprehension_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgSetComprehension* SgSetComprehension_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgSetComprehension_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgSetComprehension_clearMemoryPool ( );
void SgSetComprehension_extendMemoryPoolForFileIO ( );
unsigned long SgSetComprehension_initializeStorageClassArray( SgSetComprehensionStorageClass *storageArray );
void SgSetComprehension_resetValidFreepointers( );
unsigned long SgSetComprehension_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDictionaryComprehension_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDictionaryComprehension* SgDictionaryComprehension_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDictionaryComprehension_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDictionaryComprehension* SgDictionaryComprehension_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDictionaryComprehension* SgDictionaryComprehension_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDictionaryComprehension_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDictionaryComprehension_clearMemoryPool ( );
void SgDictionaryComprehension_extendMemoryPoolForFileIO ( );
unsigned long SgDictionaryComprehension_initializeStorageClassArray( SgDictionaryComprehensionStorageClass *storageArray );
void SgDictionaryComprehension_resetValidFreepointers( );
unsigned long SgDictionaryComprehension_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNaryOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNaryOp* SgNaryOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNaryOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNaryOp* SgNaryOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNaryOp* SgNaryOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNaryOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNaryOp_clearMemoryPool ( );
void SgNaryOp_extendMemoryPoolForFileIO ( );
unsigned long SgNaryOp_initializeStorageClassArray( SgNaryOpStorageClass *storageArray );
void SgNaryOp_resetValidFreepointers( );
unsigned long SgNaryOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNaryBooleanOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNaryBooleanOp* SgNaryBooleanOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNaryBooleanOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNaryBooleanOp* SgNaryBooleanOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNaryBooleanOp* SgNaryBooleanOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNaryBooleanOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNaryBooleanOp_clearMemoryPool ( );
void SgNaryBooleanOp_extendMemoryPoolForFileIO ( );
unsigned long SgNaryBooleanOp_initializeStorageClassArray( SgNaryBooleanOpStorageClass *storageArray );
void SgNaryBooleanOp_resetValidFreepointers( );
unsigned long SgNaryBooleanOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNaryComparisonOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNaryComparisonOp* SgNaryComparisonOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNaryComparisonOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNaryComparisonOp* SgNaryComparisonOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNaryComparisonOp* SgNaryComparisonOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNaryComparisonOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNaryComparisonOp_clearMemoryPool ( );
void SgNaryComparisonOp_extendMemoryPoolForFileIO ( );
unsigned long SgNaryComparisonOp_initializeStorageClassArray( SgNaryComparisonOpStorageClass *storageArray );
void SgNaryComparisonOp_resetValidFreepointers( );
unsigned long SgNaryComparisonOp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgStringConversion_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgStringConversion* SgStringConversion_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgStringConversion_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgStringConversion* SgStringConversion_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgStringConversion* SgStringConversion_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgStringConversion_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgStringConversion_clearMemoryPool ( );
void SgStringConversion_extendMemoryPoolForFileIO ( );
unsigned long SgStringConversion_initializeStorageClassArray( SgStringConversionStorageClass *storageArray );
void SgStringConversion_resetValidFreepointers( );
unsigned long SgStringConversion_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgYieldExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgYieldExpression* SgYieldExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgYieldExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgYieldExpression* SgYieldExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgYieldExpression* SgYieldExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgYieldExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgYieldExpression_clearMemoryPool ( );
void SgYieldExpression_extendMemoryPoolForFileIO ( );
unsigned long SgYieldExpression_initializeStorageClassArray( SgYieldExpressionStorageClass *storageArray );
void SgYieldExpression_resetValidFreepointers( );
unsigned long SgYieldExpression_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgToken_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgToken* SgToken_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgToken_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgToken* SgToken_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgToken* SgToken_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgToken_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgToken_clearMemoryPool ( );
void SgToken_extendMemoryPoolForFileIO ( );
unsigned long SgToken_initializeStorageClassArray( SgTokenStorageClass *storageArray );
void SgToken_resetValidFreepointers( );
unsigned long SgToken_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgSymbol* SgSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgSymbol* SgSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgSymbol* SgSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgSymbol_clearMemoryPool ( );
void SgSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgSymbol_initializeStorageClassArray( SgSymbolStorageClass *storageArray );
void SgSymbol_resetValidFreepointers( );
unsigned long SgSymbol_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgVariableSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgVariableSymbol* SgVariableSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgVariableSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgVariableSymbol* SgVariableSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgVariableSymbol* SgVariableSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgVariableSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgVariableSymbol_clearMemoryPool ( );
void SgVariableSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgVariableSymbol_initializeStorageClassArray( SgVariableSymbolStorageClass *storageArray );
void SgVariableSymbol_resetValidFreepointers( );
unsigned long SgVariableSymbol_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFunctionSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFunctionSymbol* SgFunctionSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFunctionSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFunctionSymbol* SgFunctionSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFunctionSymbol* SgFunctionSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFunctionSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFunctionSymbol_clearMemoryPool ( );
void SgFunctionSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgFunctionSymbol_initializeStorageClassArray( SgFunctionSymbolStorageClass *storageArray );
void SgFunctionSymbol_resetValidFreepointers( );
unsigned long SgFunctionSymbol_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgMemberFunctionSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgMemberFunctionSymbol* SgMemberFunctionSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgMemberFunctionSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgMemberFunctionSymbol* SgMemberFunctionSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgMemberFunctionSymbol* SgMemberFunctionSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgMemberFunctionSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgMemberFunctionSymbol_clearMemoryPool ( );
void SgMemberFunctionSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgMemberFunctionSymbol_initializeStorageClassArray( SgMemberFunctionSymbolStorageClass *storageArray );
void SgMemberFunctionSymbol_resetValidFreepointers( );
unsigned long SgMemberFunctionSymbol_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgRenameSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgRenameSymbol* SgRenameSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgRenameSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgRenameSymbol* SgRenameSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgRenameSymbol* SgRenameSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgRenameSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgRenameSymbol_clearMemoryPool ( );
void SgRenameSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgRenameSymbol_initializeStorageClassArray( SgRenameSymbolStorageClass *storageArray );
void SgRenameSymbol_resetValidFreepointers( );
unsigned long SgRenameSymbol_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFunctionTypeSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFunctionTypeSymbol* SgFunctionTypeSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFunctionTypeSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFunctionTypeSymbol* SgFunctionTypeSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFunctionTypeSymbol* SgFunctionTypeSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFunctionTypeSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFunctionTypeSymbol_clearMemoryPool ( );
void SgFunctionTypeSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgFunctionTypeSymbol_initializeStorageClassArray( SgFunctionTypeSymbolStorageClass *storageArray );
void SgFunctionTypeSymbol_resetValidFreepointers( );
unsigned long SgFunctionTypeSymbol_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgClassSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgClassSymbol* SgClassSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgClassSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgClassSymbol* SgClassSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgClassSymbol* SgClassSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgClassSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgClassSymbol_clearMemoryPool ( );
void SgClassSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgClassSymbol_initializeStorageClassArray( SgClassSymbolStorageClass *storageArray );
void SgClassSymbol_resetValidFreepointers( );
unsigned long SgClassSymbol_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateSymbol* SgTemplateSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateSymbol* SgTemplateSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateSymbol* SgTemplateSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateSymbol_clearMemoryPool ( );
void SgTemplateSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateSymbol_initializeStorageClassArray( SgTemplateSymbolStorageClass *storageArray );
void SgTemplateSymbol_resetValidFreepointers( );
unsigned long SgTemplateSymbol_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgEnumSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgEnumSymbol* SgEnumSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgEnumSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgEnumSymbol* SgEnumSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgEnumSymbol* SgEnumSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgEnumSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgEnumSymbol_clearMemoryPool ( );
void SgEnumSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgEnumSymbol_initializeStorageClassArray( SgEnumSymbolStorageClass *storageArray );
void SgEnumSymbol_resetValidFreepointers( );
unsigned long SgEnumSymbol_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgEnumFieldSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgEnumFieldSymbol* SgEnumFieldSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgEnumFieldSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgEnumFieldSymbol* SgEnumFieldSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgEnumFieldSymbol* SgEnumFieldSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgEnumFieldSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgEnumFieldSymbol_clearMemoryPool ( );
void SgEnumFieldSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgEnumFieldSymbol_initializeStorageClassArray( SgEnumFieldSymbolStorageClass *storageArray );
void SgEnumFieldSymbol_resetValidFreepointers( );
unsigned long SgEnumFieldSymbol_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypedefSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypedefSymbol* SgTypedefSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypedefSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypedefSymbol* SgTypedefSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypedefSymbol* SgTypedefSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypedefSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypedefSymbol_clearMemoryPool ( );
void SgTypedefSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgTypedefSymbol_initializeStorageClassArray( SgTypedefSymbolStorageClass *storageArray );
void SgTypedefSymbol_resetValidFreepointers( );
unsigned long SgTypedefSymbol_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLabelSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLabelSymbol* SgLabelSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLabelSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLabelSymbol* SgLabelSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLabelSymbol* SgLabelSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLabelSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLabelSymbol_clearMemoryPool ( );
void SgLabelSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgLabelSymbol_initializeStorageClassArray( SgLabelSymbolStorageClass *storageArray );
void SgLabelSymbol_resetValidFreepointers( );
unsigned long SgLabelSymbol_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDefaultSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDefaultSymbol* SgDefaultSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDefaultSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDefaultSymbol* SgDefaultSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDefaultSymbol* SgDefaultSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDefaultSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDefaultSymbol_clearMemoryPool ( );
void SgDefaultSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgDefaultSymbol_initializeStorageClassArray( SgDefaultSymbolStorageClass *storageArray );
void SgDefaultSymbol_resetValidFreepointers( );
unsigned long SgDefaultSymbol_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNamespaceSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNamespaceSymbol* SgNamespaceSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNamespaceSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNamespaceSymbol* SgNamespaceSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNamespaceSymbol* SgNamespaceSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNamespaceSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNamespaceSymbol_clearMemoryPool ( );
void SgNamespaceSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgNamespaceSymbol_initializeStorageClassArray( SgNamespaceSymbolStorageClass *storageArray );
void SgNamespaceSymbol_resetValidFreepointers( );
unsigned long SgNamespaceSymbol_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIntrinsicSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIntrinsicSymbol* SgIntrinsicSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIntrinsicSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIntrinsicSymbol* SgIntrinsicSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIntrinsicSymbol* SgIntrinsicSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIntrinsicSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIntrinsicSymbol_clearMemoryPool ( );
void SgIntrinsicSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgIntrinsicSymbol_initializeStorageClassArray( SgIntrinsicSymbolStorageClass *storageArray );
void SgIntrinsicSymbol_resetValidFreepointers( );
unsigned long SgIntrinsicSymbol_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgModuleSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgModuleSymbol* SgModuleSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgModuleSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgModuleSymbol* SgModuleSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgModuleSymbol* SgModuleSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgModuleSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgModuleSymbol_clearMemoryPool ( );
void SgModuleSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgModuleSymbol_initializeStorageClassArray( SgModuleSymbolStorageClass *storageArray );
void SgModuleSymbol_resetValidFreepointers( );
unsigned long SgModuleSymbol_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgInterfaceSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgInterfaceSymbol* SgInterfaceSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgInterfaceSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgInterfaceSymbol* SgInterfaceSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgInterfaceSymbol* SgInterfaceSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgInterfaceSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgInterfaceSymbol_clearMemoryPool ( );
void SgInterfaceSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgInterfaceSymbol_initializeStorageClassArray( SgInterfaceSymbolStorageClass *storageArray );
void SgInterfaceSymbol_resetValidFreepointers( );
unsigned long SgInterfaceSymbol_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCommonSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCommonSymbol* SgCommonSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCommonSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCommonSymbol* SgCommonSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCommonSymbol* SgCommonSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCommonSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCommonSymbol_clearMemoryPool ( );
void SgCommonSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgCommonSymbol_initializeStorageClassArray( SgCommonSymbolStorageClass *storageArray );
void SgCommonSymbol_resetValidFreepointers( );
unsigned long SgCommonSymbol_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAliasSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAliasSymbol* SgAliasSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAliasSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAliasSymbol* SgAliasSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAliasSymbol* SgAliasSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAliasSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAliasSymbol_clearMemoryPool ( );
void SgAliasSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgAliasSymbol_initializeStorageClassArray( SgAliasSymbolStorageClass *storageArray );
void SgAliasSymbol_resetValidFreepointers( );
unsigned long SgAliasSymbol_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmBinaryAddressSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmBinaryAddressSymbol* SgAsmBinaryAddressSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmBinaryAddressSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmBinaryAddressSymbol* SgAsmBinaryAddressSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmBinaryAddressSymbol* SgAsmBinaryAddressSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmBinaryAddressSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmBinaryAddressSymbol_clearMemoryPool ( );
void SgAsmBinaryAddressSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgAsmBinaryAddressSymbol_initializeStorageClassArray( SgAsmBinaryAddressSymbolStorageClass *storageArray );
void SgAsmBinaryAddressSymbol_resetValidFreepointers( );
unsigned long SgAsmBinaryAddressSymbol_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmBinaryDataSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmBinaryDataSymbol* SgAsmBinaryDataSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmBinaryDataSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmBinaryDataSymbol* SgAsmBinaryDataSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmBinaryDataSymbol* SgAsmBinaryDataSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmBinaryDataSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmBinaryDataSymbol_clearMemoryPool ( );
void SgAsmBinaryDataSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgAsmBinaryDataSymbol_initializeStorageClassArray( SgAsmBinaryDataSymbolStorageClass *storageArray );
void SgAsmBinaryDataSymbol_resetValidFreepointers( );
unsigned long SgAsmBinaryDataSymbol_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJavaLabelSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJavaLabelSymbol* SgJavaLabelSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJavaLabelSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJavaLabelSymbol* SgJavaLabelSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJavaLabelSymbol* SgJavaLabelSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJavaLabelSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJavaLabelSymbol_clearMemoryPool ( );
void SgJavaLabelSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgJavaLabelSymbol_initializeStorageClassArray( SgJavaLabelSymbolStorageClass *storageArray );
void SgJavaLabelSymbol_resetValidFreepointers( );
unsigned long SgJavaLabelSymbol_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmNode_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmNode* SgAsmNode_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmNode_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmNode* SgAsmNode_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmNode* SgAsmNode_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmNode_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmNode_clearMemoryPool ( );
void SgAsmNode_extendMemoryPoolForFileIO ( );
unsigned long SgAsmNode_initializeStorageClassArray( SgAsmNodeStorageClass *storageArray );
void SgAsmNode_resetValidFreepointers( );
unsigned long SgAsmNode_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmStatement* SgAsmStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmStatement* SgAsmStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmStatement* SgAsmStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmStatement_clearMemoryPool ( );
void SgAsmStatement_extendMemoryPoolForFileIO ( );
unsigned long SgAsmStatement_initializeStorageClassArray( SgAsmStatementStorageClass *storageArray );
void SgAsmStatement_resetValidFreepointers( );
unsigned long SgAsmStatement_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmFunction_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmFunction* SgAsmFunction_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmFunction_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmFunction* SgAsmFunction_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmFunction* SgAsmFunction_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmFunction_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmFunction_clearMemoryPool ( );
void SgAsmFunction_extendMemoryPoolForFileIO ( );
unsigned long SgAsmFunction_initializeStorageClassArray( SgAsmFunctionStorageClass *storageArray );
void SgAsmFunction_resetValidFreepointers( );
unsigned long SgAsmFunction_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmBlock_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmBlock* SgAsmBlock_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmBlock_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmBlock* SgAsmBlock_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmBlock* SgAsmBlock_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmBlock_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmBlock_clearMemoryPool ( );
void SgAsmBlock_extendMemoryPoolForFileIO ( );
unsigned long SgAsmBlock_initializeStorageClassArray( SgAsmBlockStorageClass *storageArray );
void SgAsmBlock_resetValidFreepointers( );
unsigned long SgAsmBlock_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmInstruction_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmInstruction* SgAsmInstruction_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmInstruction_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmInstruction* SgAsmInstruction_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmInstruction* SgAsmInstruction_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmInstruction_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmInstruction_clearMemoryPool ( );
void SgAsmInstruction_extendMemoryPoolForFileIO ( );
unsigned long SgAsmInstruction_initializeStorageClassArray( SgAsmInstructionStorageClass *storageArray );
void SgAsmInstruction_resetValidFreepointers( );
unsigned long SgAsmInstruction_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmx86Instruction_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmx86Instruction* SgAsmx86Instruction_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmx86Instruction_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmx86Instruction* SgAsmx86Instruction_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmx86Instruction* SgAsmx86Instruction_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmx86Instruction_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmx86Instruction_clearMemoryPool ( );
void SgAsmx86Instruction_extendMemoryPoolForFileIO ( );
unsigned long SgAsmx86Instruction_initializeStorageClassArray( SgAsmx86InstructionStorageClass *storageArray );
void SgAsmx86Instruction_resetValidFreepointers( );
unsigned long SgAsmx86Instruction_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmArmInstruction_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmArmInstruction* SgAsmArmInstruction_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmArmInstruction_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmArmInstruction* SgAsmArmInstruction_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmArmInstruction* SgAsmArmInstruction_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmArmInstruction_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmArmInstruction_clearMemoryPool ( );
void SgAsmArmInstruction_extendMemoryPoolForFileIO ( );
unsigned long SgAsmArmInstruction_initializeStorageClassArray( SgAsmArmInstructionStorageClass *storageArray );
void SgAsmArmInstruction_resetValidFreepointers( );
unsigned long SgAsmArmInstruction_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmPowerpcInstruction_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmPowerpcInstruction* SgAsmPowerpcInstruction_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmPowerpcInstruction_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmPowerpcInstruction* SgAsmPowerpcInstruction_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmPowerpcInstruction* SgAsmPowerpcInstruction_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmPowerpcInstruction_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmPowerpcInstruction_clearMemoryPool ( );
void SgAsmPowerpcInstruction_extendMemoryPoolForFileIO ( );
unsigned long SgAsmPowerpcInstruction_initializeStorageClassArray( SgAsmPowerpcInstructionStorageClass *storageArray );
void SgAsmPowerpcInstruction_resetValidFreepointers( );
unsigned long SgAsmPowerpcInstruction_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmStaticData_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmStaticData* SgAsmStaticData_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmStaticData_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmStaticData* SgAsmStaticData_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmStaticData* SgAsmStaticData_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmStaticData_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmStaticData_clearMemoryPool ( );
void SgAsmStaticData_extendMemoryPoolForFileIO ( );
unsigned long SgAsmStaticData_initializeStorageClassArray( SgAsmStaticDataStorageClass *storageArray );
void SgAsmStaticData_resetValidFreepointers( );
unsigned long SgAsmStaticData_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmExpression* SgAsmExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmExpression* SgAsmExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmExpression* SgAsmExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmExpression_clearMemoryPool ( );
void SgAsmExpression_extendMemoryPoolForFileIO ( );
unsigned long SgAsmExpression_initializeStorageClassArray( SgAsmExpressionStorageClass *storageArray );
void SgAsmExpression_resetValidFreepointers( );
unsigned long SgAsmExpression_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmValueExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmValueExpression* SgAsmValueExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmValueExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmValueExpression* SgAsmValueExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmValueExpression* SgAsmValueExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmValueExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmValueExpression_clearMemoryPool ( );
void SgAsmValueExpression_extendMemoryPoolForFileIO ( );
unsigned long SgAsmValueExpression_initializeStorageClassArray( SgAsmValueExpressionStorageClass *storageArray );
void SgAsmValueExpression_resetValidFreepointers( );
unsigned long SgAsmValueExpression_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmIntegerValueExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmIntegerValueExpression* SgAsmIntegerValueExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmIntegerValueExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmIntegerValueExpression* SgAsmIntegerValueExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmIntegerValueExpression* SgAsmIntegerValueExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmIntegerValueExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmIntegerValueExpression_clearMemoryPool ( );
void SgAsmIntegerValueExpression_extendMemoryPoolForFileIO ( );
unsigned long SgAsmIntegerValueExpression_initializeStorageClassArray( SgAsmIntegerValueExpressionStorageClass *storageArray );
void SgAsmIntegerValueExpression_resetValidFreepointers( );
unsigned long SgAsmIntegerValueExpression_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmByteValueExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmByteValueExpression* SgAsmByteValueExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmByteValueExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmByteValueExpression* SgAsmByteValueExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmByteValueExpression* SgAsmByteValueExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmByteValueExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmByteValueExpression_clearMemoryPool ( );
void SgAsmByteValueExpression_extendMemoryPoolForFileIO ( );
unsigned long SgAsmByteValueExpression_initializeStorageClassArray( SgAsmByteValueExpressionStorageClass *storageArray );
void SgAsmByteValueExpression_resetValidFreepointers( );
unsigned long SgAsmByteValueExpression_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmWordValueExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmWordValueExpression* SgAsmWordValueExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmWordValueExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmWordValueExpression* SgAsmWordValueExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmWordValueExpression* SgAsmWordValueExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmWordValueExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmWordValueExpression_clearMemoryPool ( );
void SgAsmWordValueExpression_extendMemoryPoolForFileIO ( );
unsigned long SgAsmWordValueExpression_initializeStorageClassArray( SgAsmWordValueExpressionStorageClass *storageArray );
void SgAsmWordValueExpression_resetValidFreepointers( );
unsigned long SgAsmWordValueExpression_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDoubleWordValueExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDoubleWordValueExpression* SgAsmDoubleWordValueExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDoubleWordValueExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDoubleWordValueExpression* SgAsmDoubleWordValueExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDoubleWordValueExpression* SgAsmDoubleWordValueExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDoubleWordValueExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDoubleWordValueExpression_clearMemoryPool ( );
void SgAsmDoubleWordValueExpression_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDoubleWordValueExpression_initializeStorageClassArray( SgAsmDoubleWordValueExpressionStorageClass *storageArray );
void SgAsmDoubleWordValueExpression_resetValidFreepointers( );
unsigned long SgAsmDoubleWordValueExpression_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmQuadWordValueExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmQuadWordValueExpression* SgAsmQuadWordValueExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmQuadWordValueExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmQuadWordValueExpression* SgAsmQuadWordValueExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmQuadWordValueExpression* SgAsmQuadWordValueExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmQuadWordValueExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmQuadWordValueExpression_clearMemoryPool ( );
void SgAsmQuadWordValueExpression_extendMemoryPoolForFileIO ( );
unsigned long SgAsmQuadWordValueExpression_initializeStorageClassArray( SgAsmQuadWordValueExpressionStorageClass *storageArray );
void SgAsmQuadWordValueExpression_resetValidFreepointers( );
unsigned long SgAsmQuadWordValueExpression_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmSingleFloatValueExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmSingleFloatValueExpression* SgAsmSingleFloatValueExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmSingleFloatValueExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmSingleFloatValueExpression* SgAsmSingleFloatValueExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmSingleFloatValueExpression* SgAsmSingleFloatValueExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmSingleFloatValueExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmSingleFloatValueExpression_clearMemoryPool ( );
void SgAsmSingleFloatValueExpression_extendMemoryPoolForFileIO ( );
unsigned long SgAsmSingleFloatValueExpression_initializeStorageClassArray( SgAsmSingleFloatValueExpressionStorageClass *storageArray );
void SgAsmSingleFloatValueExpression_resetValidFreepointers( );
unsigned long SgAsmSingleFloatValueExpression_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDoubleFloatValueExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDoubleFloatValueExpression* SgAsmDoubleFloatValueExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDoubleFloatValueExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDoubleFloatValueExpression* SgAsmDoubleFloatValueExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDoubleFloatValueExpression* SgAsmDoubleFloatValueExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDoubleFloatValueExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDoubleFloatValueExpression_clearMemoryPool ( );
void SgAsmDoubleFloatValueExpression_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDoubleFloatValueExpression_initializeStorageClassArray( SgAsmDoubleFloatValueExpressionStorageClass *storageArray );
void SgAsmDoubleFloatValueExpression_resetValidFreepointers( );
unsigned long SgAsmDoubleFloatValueExpression_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmVectorValueExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmVectorValueExpression* SgAsmVectorValueExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmVectorValueExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmVectorValueExpression* SgAsmVectorValueExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmVectorValueExpression* SgAsmVectorValueExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmVectorValueExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmVectorValueExpression_clearMemoryPool ( );
void SgAsmVectorValueExpression_extendMemoryPoolForFileIO ( );
unsigned long SgAsmVectorValueExpression_initializeStorageClassArray( SgAsmVectorValueExpressionStorageClass *storageArray );
void SgAsmVectorValueExpression_resetValidFreepointers( );
unsigned long SgAsmVectorValueExpression_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmBinaryExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmBinaryExpression* SgAsmBinaryExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmBinaryExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmBinaryExpression* SgAsmBinaryExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmBinaryExpression* SgAsmBinaryExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmBinaryExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmBinaryExpression_clearMemoryPool ( );
void SgAsmBinaryExpression_extendMemoryPoolForFileIO ( );
unsigned long SgAsmBinaryExpression_initializeStorageClassArray( SgAsmBinaryExpressionStorageClass *storageArray );
void SgAsmBinaryExpression_resetValidFreepointers( );
unsigned long SgAsmBinaryExpression_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmBinaryAdd_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmBinaryAdd* SgAsmBinaryAdd_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmBinaryAdd_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmBinaryAdd* SgAsmBinaryAdd_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmBinaryAdd* SgAsmBinaryAdd_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmBinaryAdd_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmBinaryAdd_clearMemoryPool ( );
void SgAsmBinaryAdd_extendMemoryPoolForFileIO ( );
unsigned long SgAsmBinaryAdd_initializeStorageClassArray( SgAsmBinaryAddStorageClass *storageArray );
void SgAsmBinaryAdd_resetValidFreepointers( );
unsigned long SgAsmBinaryAdd_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmBinarySubtract_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmBinarySubtract* SgAsmBinarySubtract_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmBinarySubtract_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmBinarySubtract* SgAsmBinarySubtract_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmBinarySubtract* SgAsmBinarySubtract_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmBinarySubtract_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmBinarySubtract_clearMemoryPool ( );
void SgAsmBinarySubtract_extendMemoryPoolForFileIO ( );
unsigned long SgAsmBinarySubtract_initializeStorageClassArray( SgAsmBinarySubtractStorageClass *storageArray );
void SgAsmBinarySubtract_resetValidFreepointers( );
unsigned long SgAsmBinarySubtract_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmBinaryMultiply_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmBinaryMultiply* SgAsmBinaryMultiply_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmBinaryMultiply_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmBinaryMultiply* SgAsmBinaryMultiply_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmBinaryMultiply* SgAsmBinaryMultiply_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmBinaryMultiply_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmBinaryMultiply_clearMemoryPool ( );
void SgAsmBinaryMultiply_extendMemoryPoolForFileIO ( );
unsigned long SgAsmBinaryMultiply_initializeStorageClassArray( SgAsmBinaryMultiplyStorageClass *storageArray );
void SgAsmBinaryMultiply_resetValidFreepointers( );
unsigned long SgAsmBinaryMultiply_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmBinaryDivide_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmBinaryDivide* SgAsmBinaryDivide_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmBinaryDivide_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmBinaryDivide* SgAsmBinaryDivide_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmBinaryDivide* SgAsmBinaryDivide_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmBinaryDivide_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmBinaryDivide_clearMemoryPool ( );
void SgAsmBinaryDivide_extendMemoryPoolForFileIO ( );
unsigned long SgAsmBinaryDivide_initializeStorageClassArray( SgAsmBinaryDivideStorageClass *storageArray );
void SgAsmBinaryDivide_resetValidFreepointers( );
unsigned long SgAsmBinaryDivide_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmBinaryMod_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmBinaryMod* SgAsmBinaryMod_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmBinaryMod_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmBinaryMod* SgAsmBinaryMod_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmBinaryMod* SgAsmBinaryMod_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmBinaryMod_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmBinaryMod_clearMemoryPool ( );
void SgAsmBinaryMod_extendMemoryPoolForFileIO ( );
unsigned long SgAsmBinaryMod_initializeStorageClassArray( SgAsmBinaryModStorageClass *storageArray );
void SgAsmBinaryMod_resetValidFreepointers( );
unsigned long SgAsmBinaryMod_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmBinaryAddPreupdate_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmBinaryAddPreupdate* SgAsmBinaryAddPreupdate_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmBinaryAddPreupdate_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmBinaryAddPreupdate* SgAsmBinaryAddPreupdate_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmBinaryAddPreupdate* SgAsmBinaryAddPreupdate_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmBinaryAddPreupdate_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmBinaryAddPreupdate_clearMemoryPool ( );
void SgAsmBinaryAddPreupdate_extendMemoryPoolForFileIO ( );
unsigned long SgAsmBinaryAddPreupdate_initializeStorageClassArray( SgAsmBinaryAddPreupdateStorageClass *storageArray );
void SgAsmBinaryAddPreupdate_resetValidFreepointers( );
unsigned long SgAsmBinaryAddPreupdate_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmBinarySubtractPreupdate_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmBinarySubtractPreupdate* SgAsmBinarySubtractPreupdate_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmBinarySubtractPreupdate_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmBinarySubtractPreupdate* SgAsmBinarySubtractPreupdate_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmBinarySubtractPreupdate* SgAsmBinarySubtractPreupdate_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmBinarySubtractPreupdate_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmBinarySubtractPreupdate_clearMemoryPool ( );
void SgAsmBinarySubtractPreupdate_extendMemoryPoolForFileIO ( );
unsigned long SgAsmBinarySubtractPreupdate_initializeStorageClassArray( SgAsmBinarySubtractPreupdateStorageClass *storageArray );
void SgAsmBinarySubtractPreupdate_resetValidFreepointers( );
unsigned long SgAsmBinarySubtractPreupdate_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmBinaryAddPostupdate_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmBinaryAddPostupdate* SgAsmBinaryAddPostupdate_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmBinaryAddPostupdate_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmBinaryAddPostupdate* SgAsmBinaryAddPostupdate_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmBinaryAddPostupdate* SgAsmBinaryAddPostupdate_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmBinaryAddPostupdate_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmBinaryAddPostupdate_clearMemoryPool ( );
void SgAsmBinaryAddPostupdate_extendMemoryPoolForFileIO ( );
unsigned long SgAsmBinaryAddPostupdate_initializeStorageClassArray( SgAsmBinaryAddPostupdateStorageClass *storageArray );
void SgAsmBinaryAddPostupdate_resetValidFreepointers( );
unsigned long SgAsmBinaryAddPostupdate_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmBinarySubtractPostupdate_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmBinarySubtractPostupdate* SgAsmBinarySubtractPostupdate_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmBinarySubtractPostupdate_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmBinarySubtractPostupdate* SgAsmBinarySubtractPostupdate_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmBinarySubtractPostupdate* SgAsmBinarySubtractPostupdate_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmBinarySubtractPostupdate_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmBinarySubtractPostupdate_clearMemoryPool ( );
void SgAsmBinarySubtractPostupdate_extendMemoryPoolForFileIO ( );
unsigned long SgAsmBinarySubtractPostupdate_initializeStorageClassArray( SgAsmBinarySubtractPostupdateStorageClass *storageArray );
void SgAsmBinarySubtractPostupdate_resetValidFreepointers( );
unsigned long SgAsmBinarySubtractPostupdate_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmBinaryLsl_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmBinaryLsl* SgAsmBinaryLsl_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmBinaryLsl_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmBinaryLsl* SgAsmBinaryLsl_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmBinaryLsl* SgAsmBinaryLsl_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmBinaryLsl_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmBinaryLsl_clearMemoryPool ( );
void SgAsmBinaryLsl_extendMemoryPoolForFileIO ( );
unsigned long SgAsmBinaryLsl_initializeStorageClassArray( SgAsmBinaryLslStorageClass *storageArray );
void SgAsmBinaryLsl_resetValidFreepointers( );
unsigned long SgAsmBinaryLsl_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmBinaryLsr_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmBinaryLsr* SgAsmBinaryLsr_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmBinaryLsr_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmBinaryLsr* SgAsmBinaryLsr_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmBinaryLsr* SgAsmBinaryLsr_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmBinaryLsr_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmBinaryLsr_clearMemoryPool ( );
void SgAsmBinaryLsr_extendMemoryPoolForFileIO ( );
unsigned long SgAsmBinaryLsr_initializeStorageClassArray( SgAsmBinaryLsrStorageClass *storageArray );
void SgAsmBinaryLsr_resetValidFreepointers( );
unsigned long SgAsmBinaryLsr_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmBinaryAsr_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmBinaryAsr* SgAsmBinaryAsr_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmBinaryAsr_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmBinaryAsr* SgAsmBinaryAsr_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmBinaryAsr* SgAsmBinaryAsr_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmBinaryAsr_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmBinaryAsr_clearMemoryPool ( );
void SgAsmBinaryAsr_extendMemoryPoolForFileIO ( );
unsigned long SgAsmBinaryAsr_initializeStorageClassArray( SgAsmBinaryAsrStorageClass *storageArray );
void SgAsmBinaryAsr_resetValidFreepointers( );
unsigned long SgAsmBinaryAsr_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmBinaryRor_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmBinaryRor* SgAsmBinaryRor_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmBinaryRor_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmBinaryRor* SgAsmBinaryRor_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmBinaryRor* SgAsmBinaryRor_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmBinaryRor_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmBinaryRor_clearMemoryPool ( );
void SgAsmBinaryRor_extendMemoryPoolForFileIO ( );
unsigned long SgAsmBinaryRor_initializeStorageClassArray( SgAsmBinaryRorStorageClass *storageArray );
void SgAsmBinaryRor_resetValidFreepointers( );
unsigned long SgAsmBinaryRor_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmUnaryExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmUnaryExpression* SgAsmUnaryExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmUnaryExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmUnaryExpression* SgAsmUnaryExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmUnaryExpression* SgAsmUnaryExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmUnaryExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmUnaryExpression_clearMemoryPool ( );
void SgAsmUnaryExpression_extendMemoryPoolForFileIO ( );
unsigned long SgAsmUnaryExpression_initializeStorageClassArray( SgAsmUnaryExpressionStorageClass *storageArray );
void SgAsmUnaryExpression_resetValidFreepointers( );
unsigned long SgAsmUnaryExpression_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmUnaryPlus_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmUnaryPlus* SgAsmUnaryPlus_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmUnaryPlus_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmUnaryPlus* SgAsmUnaryPlus_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmUnaryPlus* SgAsmUnaryPlus_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmUnaryPlus_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmUnaryPlus_clearMemoryPool ( );
void SgAsmUnaryPlus_extendMemoryPoolForFileIO ( );
unsigned long SgAsmUnaryPlus_initializeStorageClassArray( SgAsmUnaryPlusStorageClass *storageArray );
void SgAsmUnaryPlus_resetValidFreepointers( );
unsigned long SgAsmUnaryPlus_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmUnaryMinus_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmUnaryMinus* SgAsmUnaryMinus_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmUnaryMinus_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmUnaryMinus* SgAsmUnaryMinus_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmUnaryMinus* SgAsmUnaryMinus_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmUnaryMinus_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmUnaryMinus_clearMemoryPool ( );
void SgAsmUnaryMinus_extendMemoryPoolForFileIO ( );
unsigned long SgAsmUnaryMinus_initializeStorageClassArray( SgAsmUnaryMinusStorageClass *storageArray );
void SgAsmUnaryMinus_resetValidFreepointers( );
unsigned long SgAsmUnaryMinus_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmUnaryRrx_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmUnaryRrx* SgAsmUnaryRrx_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmUnaryRrx_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmUnaryRrx* SgAsmUnaryRrx_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmUnaryRrx* SgAsmUnaryRrx_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmUnaryRrx_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmUnaryRrx_clearMemoryPool ( );
void SgAsmUnaryRrx_extendMemoryPoolForFileIO ( );
unsigned long SgAsmUnaryRrx_initializeStorageClassArray( SgAsmUnaryRrxStorageClass *storageArray );
void SgAsmUnaryRrx_resetValidFreepointers( );
unsigned long SgAsmUnaryRrx_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmUnaryArmSpecialRegisterList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmUnaryArmSpecialRegisterList* SgAsmUnaryArmSpecialRegisterList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmUnaryArmSpecialRegisterList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmUnaryArmSpecialRegisterList* SgAsmUnaryArmSpecialRegisterList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmUnaryArmSpecialRegisterList* SgAsmUnaryArmSpecialRegisterList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmUnaryArmSpecialRegisterList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmUnaryArmSpecialRegisterList_clearMemoryPool ( );
void SgAsmUnaryArmSpecialRegisterList_extendMemoryPoolForFileIO ( );
unsigned long SgAsmUnaryArmSpecialRegisterList_initializeStorageClassArray( SgAsmUnaryArmSpecialRegisterListStorageClass *storageArray );
void SgAsmUnaryArmSpecialRegisterList_resetValidFreepointers( );
unsigned long SgAsmUnaryArmSpecialRegisterList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmMemoryReferenceExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmMemoryReferenceExpression* SgAsmMemoryReferenceExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmMemoryReferenceExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmMemoryReferenceExpression* SgAsmMemoryReferenceExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmMemoryReferenceExpression* SgAsmMemoryReferenceExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmMemoryReferenceExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmMemoryReferenceExpression_clearMemoryPool ( );
void SgAsmMemoryReferenceExpression_extendMemoryPoolForFileIO ( );
unsigned long SgAsmMemoryReferenceExpression_initializeStorageClassArray( SgAsmMemoryReferenceExpressionStorageClass *storageArray );
void SgAsmMemoryReferenceExpression_resetValidFreepointers( );
unsigned long SgAsmMemoryReferenceExpression_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmRegisterReferenceExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmRegisterReferenceExpression* SgAsmRegisterReferenceExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmRegisterReferenceExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmRegisterReferenceExpression* SgAsmRegisterReferenceExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmRegisterReferenceExpression* SgAsmRegisterReferenceExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmRegisterReferenceExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmRegisterReferenceExpression_clearMemoryPool ( );
void SgAsmRegisterReferenceExpression_extendMemoryPoolForFileIO ( );
unsigned long SgAsmRegisterReferenceExpression_initializeStorageClassArray( SgAsmRegisterReferenceExpressionStorageClass *storageArray );
void SgAsmRegisterReferenceExpression_resetValidFreepointers( );
unsigned long SgAsmRegisterReferenceExpression_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmx86RegisterReferenceExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmx86RegisterReferenceExpression* SgAsmx86RegisterReferenceExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmx86RegisterReferenceExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmx86RegisterReferenceExpression* SgAsmx86RegisterReferenceExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmx86RegisterReferenceExpression* SgAsmx86RegisterReferenceExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmx86RegisterReferenceExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmx86RegisterReferenceExpression_clearMemoryPool ( );
void SgAsmx86RegisterReferenceExpression_extendMemoryPoolForFileIO ( );
unsigned long SgAsmx86RegisterReferenceExpression_initializeStorageClassArray( SgAsmx86RegisterReferenceExpressionStorageClass *storageArray );
void SgAsmx86RegisterReferenceExpression_resetValidFreepointers( );
unsigned long SgAsmx86RegisterReferenceExpression_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmArmRegisterReferenceExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmArmRegisterReferenceExpression* SgAsmArmRegisterReferenceExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmArmRegisterReferenceExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmArmRegisterReferenceExpression* SgAsmArmRegisterReferenceExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmArmRegisterReferenceExpression* SgAsmArmRegisterReferenceExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmArmRegisterReferenceExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmArmRegisterReferenceExpression_clearMemoryPool ( );
void SgAsmArmRegisterReferenceExpression_extendMemoryPoolForFileIO ( );
unsigned long SgAsmArmRegisterReferenceExpression_initializeStorageClassArray( SgAsmArmRegisterReferenceExpressionStorageClass *storageArray );
void SgAsmArmRegisterReferenceExpression_resetValidFreepointers( );
unsigned long SgAsmArmRegisterReferenceExpression_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmPowerpcRegisterReferenceExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmPowerpcRegisterReferenceExpression* SgAsmPowerpcRegisterReferenceExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmPowerpcRegisterReferenceExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmPowerpcRegisterReferenceExpression* SgAsmPowerpcRegisterReferenceExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmPowerpcRegisterReferenceExpression* SgAsmPowerpcRegisterReferenceExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmPowerpcRegisterReferenceExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmPowerpcRegisterReferenceExpression_clearMemoryPool ( );
void SgAsmPowerpcRegisterReferenceExpression_extendMemoryPoolForFileIO ( );
unsigned long SgAsmPowerpcRegisterReferenceExpression_initializeStorageClassArray( SgAsmPowerpcRegisterReferenceExpressionStorageClass *storageArray );
void SgAsmPowerpcRegisterReferenceExpression_resetValidFreepointers( );
unsigned long SgAsmPowerpcRegisterReferenceExpression_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmControlFlagsExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmControlFlagsExpression* SgAsmControlFlagsExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmControlFlagsExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmControlFlagsExpression* SgAsmControlFlagsExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmControlFlagsExpression* SgAsmControlFlagsExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmControlFlagsExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmControlFlagsExpression_clearMemoryPool ( );
void SgAsmControlFlagsExpression_extendMemoryPoolForFileIO ( );
unsigned long SgAsmControlFlagsExpression_initializeStorageClassArray( SgAsmControlFlagsExpressionStorageClass *storageArray );
void SgAsmControlFlagsExpression_resetValidFreepointers( );
unsigned long SgAsmControlFlagsExpression_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmCommonSubExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmCommonSubExpression* SgAsmCommonSubExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmCommonSubExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmCommonSubExpression* SgAsmCommonSubExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmCommonSubExpression* SgAsmCommonSubExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmCommonSubExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmCommonSubExpression_clearMemoryPool ( );
void SgAsmCommonSubExpression_extendMemoryPoolForFileIO ( );
unsigned long SgAsmCommonSubExpression_initializeStorageClassArray( SgAsmCommonSubExpressionStorageClass *storageArray );
void SgAsmCommonSubExpression_resetValidFreepointers( );
unsigned long SgAsmCommonSubExpression_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmExprListExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmExprListExp* SgAsmExprListExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmExprListExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmExprListExp* SgAsmExprListExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmExprListExp* SgAsmExprListExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmExprListExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmExprListExp_clearMemoryPool ( );
void SgAsmExprListExp_extendMemoryPoolForFileIO ( );
unsigned long SgAsmExprListExp_initializeStorageClassArray( SgAsmExprListExpStorageClass *storageArray );
void SgAsmExprListExp_resetValidFreepointers( );
unsigned long SgAsmExprListExp_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmInterpretation_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmInterpretation* SgAsmInterpretation_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmInterpretation_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmInterpretation* SgAsmInterpretation_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmInterpretation* SgAsmInterpretation_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmInterpretation_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmInterpretation_clearMemoryPool ( );
void SgAsmInterpretation_extendMemoryPoolForFileIO ( );
unsigned long SgAsmInterpretation_initializeStorageClassArray( SgAsmInterpretationStorageClass *storageArray );
void SgAsmInterpretation_resetValidFreepointers( );
unsigned long SgAsmInterpretation_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmOperandList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmOperandList* SgAsmOperandList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmOperandList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmOperandList* SgAsmOperandList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmOperandList* SgAsmOperandList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmOperandList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmOperandList_clearMemoryPool ( );
void SgAsmOperandList_extendMemoryPoolForFileIO ( );
unsigned long SgAsmOperandList_initializeStorageClassArray( SgAsmOperandListStorageClass *storageArray );
void SgAsmOperandList_resetValidFreepointers( );
unsigned long SgAsmOperandList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmType* SgAsmType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmType* SgAsmType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmType* SgAsmType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmType_clearMemoryPool ( );
void SgAsmType_extendMemoryPoolForFileIO ( );
unsigned long SgAsmType_initializeStorageClassArray( SgAsmTypeStorageClass *storageArray );
void SgAsmType_resetValidFreepointers( );
unsigned long SgAsmType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmTypeByte_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmTypeByte* SgAsmTypeByte_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmTypeByte_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmTypeByte* SgAsmTypeByte_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmTypeByte* SgAsmTypeByte_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmTypeByte_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmTypeByte_clearMemoryPool ( );
void SgAsmTypeByte_extendMemoryPoolForFileIO ( );
unsigned long SgAsmTypeByte_initializeStorageClassArray( SgAsmTypeByteStorageClass *storageArray );
void SgAsmTypeByte_resetValidFreepointers( );
unsigned long SgAsmTypeByte_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmTypeWord_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmTypeWord* SgAsmTypeWord_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmTypeWord_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmTypeWord* SgAsmTypeWord_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmTypeWord* SgAsmTypeWord_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmTypeWord_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmTypeWord_clearMemoryPool ( );
void SgAsmTypeWord_extendMemoryPoolForFileIO ( );
unsigned long SgAsmTypeWord_initializeStorageClassArray( SgAsmTypeWordStorageClass *storageArray );
void SgAsmTypeWord_resetValidFreepointers( );
unsigned long SgAsmTypeWord_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmTypeDoubleWord_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmTypeDoubleWord* SgAsmTypeDoubleWord_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmTypeDoubleWord_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmTypeDoubleWord* SgAsmTypeDoubleWord_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmTypeDoubleWord* SgAsmTypeDoubleWord_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmTypeDoubleWord_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmTypeDoubleWord_clearMemoryPool ( );
void SgAsmTypeDoubleWord_extendMemoryPoolForFileIO ( );
unsigned long SgAsmTypeDoubleWord_initializeStorageClassArray( SgAsmTypeDoubleWordStorageClass *storageArray );
void SgAsmTypeDoubleWord_resetValidFreepointers( );
unsigned long SgAsmTypeDoubleWord_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmTypeQuadWord_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmTypeQuadWord* SgAsmTypeQuadWord_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmTypeQuadWord_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmTypeQuadWord* SgAsmTypeQuadWord_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmTypeQuadWord* SgAsmTypeQuadWord_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmTypeQuadWord_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmTypeQuadWord_clearMemoryPool ( );
void SgAsmTypeQuadWord_extendMemoryPoolForFileIO ( );
unsigned long SgAsmTypeQuadWord_initializeStorageClassArray( SgAsmTypeQuadWordStorageClass *storageArray );
void SgAsmTypeQuadWord_resetValidFreepointers( );
unsigned long SgAsmTypeQuadWord_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmTypeDoubleQuadWord_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmTypeDoubleQuadWord* SgAsmTypeDoubleQuadWord_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmTypeDoubleQuadWord_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmTypeDoubleQuadWord* SgAsmTypeDoubleQuadWord_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmTypeDoubleQuadWord* SgAsmTypeDoubleQuadWord_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmTypeDoubleQuadWord_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmTypeDoubleQuadWord_clearMemoryPool ( );
void SgAsmTypeDoubleQuadWord_extendMemoryPoolForFileIO ( );
unsigned long SgAsmTypeDoubleQuadWord_initializeStorageClassArray( SgAsmTypeDoubleQuadWordStorageClass *storageArray );
void SgAsmTypeDoubleQuadWord_resetValidFreepointers( );
unsigned long SgAsmTypeDoubleQuadWord_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmType80bitFloat_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmType80bitFloat* SgAsmType80bitFloat_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmType80bitFloat_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmType80bitFloat* SgAsmType80bitFloat_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmType80bitFloat* SgAsmType80bitFloat_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmType80bitFloat_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmType80bitFloat_clearMemoryPool ( );
void SgAsmType80bitFloat_extendMemoryPoolForFileIO ( );
unsigned long SgAsmType80bitFloat_initializeStorageClassArray( SgAsmType80bitFloatStorageClass *storageArray );
void SgAsmType80bitFloat_resetValidFreepointers( );
unsigned long SgAsmType80bitFloat_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmType128bitFloat_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmType128bitFloat* SgAsmType128bitFloat_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmType128bitFloat_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmType128bitFloat* SgAsmType128bitFloat_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmType128bitFloat* SgAsmType128bitFloat_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmType128bitFloat_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmType128bitFloat_clearMemoryPool ( );
void SgAsmType128bitFloat_extendMemoryPoolForFileIO ( );
unsigned long SgAsmType128bitFloat_initializeStorageClassArray( SgAsmType128bitFloatStorageClass *storageArray );
void SgAsmType128bitFloat_resetValidFreepointers( );
unsigned long SgAsmType128bitFloat_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmTypeSingleFloat_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmTypeSingleFloat* SgAsmTypeSingleFloat_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmTypeSingleFloat_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmTypeSingleFloat* SgAsmTypeSingleFloat_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmTypeSingleFloat* SgAsmTypeSingleFloat_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmTypeSingleFloat_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmTypeSingleFloat_clearMemoryPool ( );
void SgAsmTypeSingleFloat_extendMemoryPoolForFileIO ( );
unsigned long SgAsmTypeSingleFloat_initializeStorageClassArray( SgAsmTypeSingleFloatStorageClass *storageArray );
void SgAsmTypeSingleFloat_resetValidFreepointers( );
unsigned long SgAsmTypeSingleFloat_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmTypeDoubleFloat_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmTypeDoubleFloat* SgAsmTypeDoubleFloat_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmTypeDoubleFloat_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmTypeDoubleFloat* SgAsmTypeDoubleFloat_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmTypeDoubleFloat* SgAsmTypeDoubleFloat_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmTypeDoubleFloat_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmTypeDoubleFloat_clearMemoryPool ( );
void SgAsmTypeDoubleFloat_extendMemoryPoolForFileIO ( );
unsigned long SgAsmTypeDoubleFloat_initializeStorageClassArray( SgAsmTypeDoubleFloatStorageClass *storageArray );
void SgAsmTypeDoubleFloat_resetValidFreepointers( );
unsigned long SgAsmTypeDoubleFloat_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmTypeVector_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmTypeVector* SgAsmTypeVector_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmTypeVector_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmTypeVector* SgAsmTypeVector_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmTypeVector* SgAsmTypeVector_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmTypeVector_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmTypeVector_clearMemoryPool ( );
void SgAsmTypeVector_extendMemoryPoolForFileIO ( );
unsigned long SgAsmTypeVector_initializeStorageClassArray( SgAsmTypeVectorStorageClass *storageArray );
void SgAsmTypeVector_resetValidFreepointers( );
unsigned long SgAsmTypeVector_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmExecutableFileFormat_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmExecutableFileFormat* SgAsmExecutableFileFormat_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmExecutableFileFormat_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmExecutableFileFormat* SgAsmExecutableFileFormat_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmExecutableFileFormat* SgAsmExecutableFileFormat_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmExecutableFileFormat_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmExecutableFileFormat_clearMemoryPool ( );
void SgAsmExecutableFileFormat_extendMemoryPoolForFileIO ( );
unsigned long SgAsmExecutableFileFormat_initializeStorageClassArray( SgAsmExecutableFileFormatStorageClass *storageArray );
void SgAsmExecutableFileFormat_resetValidFreepointers( );
unsigned long SgAsmExecutableFileFormat_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmGenericDLL_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmGenericDLL* SgAsmGenericDLL_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmGenericDLL_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmGenericDLL* SgAsmGenericDLL_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmGenericDLL* SgAsmGenericDLL_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmGenericDLL_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmGenericDLL_clearMemoryPool ( );
void SgAsmGenericDLL_extendMemoryPoolForFileIO ( );
unsigned long SgAsmGenericDLL_initializeStorageClassArray( SgAsmGenericDLLStorageClass *storageArray );
void SgAsmGenericDLL_resetValidFreepointers( );
unsigned long SgAsmGenericDLL_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmGenericFormat_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmGenericFormat* SgAsmGenericFormat_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmGenericFormat_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmGenericFormat* SgAsmGenericFormat_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmGenericFormat* SgAsmGenericFormat_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmGenericFormat_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmGenericFormat_clearMemoryPool ( );
void SgAsmGenericFormat_extendMemoryPoolForFileIO ( );
unsigned long SgAsmGenericFormat_initializeStorageClassArray( SgAsmGenericFormatStorageClass *storageArray );
void SgAsmGenericFormat_resetValidFreepointers( );
unsigned long SgAsmGenericFormat_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmGenericDLLList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmGenericDLLList* SgAsmGenericDLLList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmGenericDLLList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmGenericDLLList* SgAsmGenericDLLList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmGenericDLLList* SgAsmGenericDLLList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmGenericDLLList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmGenericDLLList_clearMemoryPool ( );
void SgAsmGenericDLLList_extendMemoryPoolForFileIO ( );
unsigned long SgAsmGenericDLLList_initializeStorageClassArray( SgAsmGenericDLLListStorageClass *storageArray );
void SgAsmGenericDLLList_resetValidFreepointers( );
unsigned long SgAsmGenericDLLList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfEHFrameEntryFD_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfEHFrameEntryFD* SgAsmElfEHFrameEntryFD_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfEHFrameEntryFD_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfEHFrameEntryFD* SgAsmElfEHFrameEntryFD_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfEHFrameEntryFD* SgAsmElfEHFrameEntryFD_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfEHFrameEntryFD_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfEHFrameEntryFD_clearMemoryPool ( );
void SgAsmElfEHFrameEntryFD_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfEHFrameEntryFD_initializeStorageClassArray( SgAsmElfEHFrameEntryFDStorageClass *storageArray );
void SgAsmElfEHFrameEntryFD_resetValidFreepointers( );
unsigned long SgAsmElfEHFrameEntryFD_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmGenericFile_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmGenericFile* SgAsmGenericFile_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmGenericFile_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmGenericFile* SgAsmGenericFile_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmGenericFile* SgAsmGenericFile_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmGenericFile_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmGenericFile_clearMemoryPool ( );
void SgAsmGenericFile_extendMemoryPoolForFileIO ( );
unsigned long SgAsmGenericFile_initializeStorageClassArray( SgAsmGenericFileStorageClass *storageArray );
void SgAsmGenericFile_resetValidFreepointers( );
unsigned long SgAsmGenericFile_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmGenericSection_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmGenericSection* SgAsmGenericSection_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmGenericSection_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmGenericSection* SgAsmGenericSection_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmGenericSection* SgAsmGenericSection_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmGenericSection_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmGenericSection_clearMemoryPool ( );
void SgAsmGenericSection_extendMemoryPoolForFileIO ( );
unsigned long SgAsmGenericSection_initializeStorageClassArray( SgAsmGenericSectionStorageClass *storageArray );
void SgAsmGenericSection_resetValidFreepointers( );
unsigned long SgAsmGenericSection_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmGenericHeader_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmGenericHeader* SgAsmGenericHeader_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmGenericHeader_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmGenericHeader* SgAsmGenericHeader_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmGenericHeader* SgAsmGenericHeader_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmGenericHeader_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmGenericHeader_clearMemoryPool ( );
void SgAsmGenericHeader_extendMemoryPoolForFileIO ( );
unsigned long SgAsmGenericHeader_initializeStorageClassArray( SgAsmGenericHeaderStorageClass *storageArray );
void SgAsmGenericHeader_resetValidFreepointers( );
unsigned long SgAsmGenericHeader_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmPEFileHeader_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmPEFileHeader* SgAsmPEFileHeader_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmPEFileHeader_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmPEFileHeader* SgAsmPEFileHeader_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmPEFileHeader* SgAsmPEFileHeader_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmPEFileHeader_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmPEFileHeader_clearMemoryPool ( );
void SgAsmPEFileHeader_extendMemoryPoolForFileIO ( );
unsigned long SgAsmPEFileHeader_initializeStorageClassArray( SgAsmPEFileHeaderStorageClass *storageArray );
void SgAsmPEFileHeader_resetValidFreepointers( );
unsigned long SgAsmPEFileHeader_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmLEFileHeader_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmLEFileHeader* SgAsmLEFileHeader_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmLEFileHeader_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmLEFileHeader* SgAsmLEFileHeader_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmLEFileHeader* SgAsmLEFileHeader_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmLEFileHeader_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmLEFileHeader_clearMemoryPool ( );
void SgAsmLEFileHeader_extendMemoryPoolForFileIO ( );
unsigned long SgAsmLEFileHeader_initializeStorageClassArray( SgAsmLEFileHeaderStorageClass *storageArray );
void SgAsmLEFileHeader_resetValidFreepointers( );
unsigned long SgAsmLEFileHeader_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmNEFileHeader_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmNEFileHeader* SgAsmNEFileHeader_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmNEFileHeader_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmNEFileHeader* SgAsmNEFileHeader_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmNEFileHeader* SgAsmNEFileHeader_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmNEFileHeader_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmNEFileHeader_clearMemoryPool ( );
void SgAsmNEFileHeader_extendMemoryPoolForFileIO ( );
unsigned long SgAsmNEFileHeader_initializeStorageClassArray( SgAsmNEFileHeaderStorageClass *storageArray );
void SgAsmNEFileHeader_resetValidFreepointers( );
unsigned long SgAsmNEFileHeader_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDOSFileHeader_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDOSFileHeader* SgAsmDOSFileHeader_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDOSFileHeader_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDOSFileHeader* SgAsmDOSFileHeader_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDOSFileHeader* SgAsmDOSFileHeader_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDOSFileHeader_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDOSFileHeader_clearMemoryPool ( );
void SgAsmDOSFileHeader_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDOSFileHeader_initializeStorageClassArray( SgAsmDOSFileHeaderStorageClass *storageArray );
void SgAsmDOSFileHeader_resetValidFreepointers( );
unsigned long SgAsmDOSFileHeader_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfFileHeader_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfFileHeader* SgAsmElfFileHeader_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfFileHeader_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfFileHeader* SgAsmElfFileHeader_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfFileHeader* SgAsmElfFileHeader_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfFileHeader_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfFileHeader_clearMemoryPool ( );
void SgAsmElfFileHeader_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfFileHeader_initializeStorageClassArray( SgAsmElfFileHeaderStorageClass *storageArray );
void SgAsmElfFileHeader_resetValidFreepointers( );
unsigned long SgAsmElfFileHeader_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfSection_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfSection* SgAsmElfSection_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfSection_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfSection* SgAsmElfSection_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfSection* SgAsmElfSection_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfSection_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfSection_clearMemoryPool ( );
void SgAsmElfSection_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfSection_initializeStorageClassArray( SgAsmElfSectionStorageClass *storageArray );
void SgAsmElfSection_resetValidFreepointers( );
unsigned long SgAsmElfSection_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfSymbolSection_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfSymbolSection* SgAsmElfSymbolSection_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfSymbolSection_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfSymbolSection* SgAsmElfSymbolSection_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfSymbolSection* SgAsmElfSymbolSection_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfSymbolSection_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfSymbolSection_clearMemoryPool ( );
void SgAsmElfSymbolSection_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfSymbolSection_initializeStorageClassArray( SgAsmElfSymbolSectionStorageClass *storageArray );
void SgAsmElfSymbolSection_resetValidFreepointers( );
unsigned long SgAsmElfSymbolSection_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfRelocSection_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfRelocSection* SgAsmElfRelocSection_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfRelocSection_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfRelocSection* SgAsmElfRelocSection_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfRelocSection* SgAsmElfRelocSection_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfRelocSection_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfRelocSection_clearMemoryPool ( );
void SgAsmElfRelocSection_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfRelocSection_initializeStorageClassArray( SgAsmElfRelocSectionStorageClass *storageArray );
void SgAsmElfRelocSection_resetValidFreepointers( );
unsigned long SgAsmElfRelocSection_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfDynamicSection_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfDynamicSection* SgAsmElfDynamicSection_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfDynamicSection_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfDynamicSection* SgAsmElfDynamicSection_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfDynamicSection* SgAsmElfDynamicSection_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfDynamicSection_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfDynamicSection_clearMemoryPool ( );
void SgAsmElfDynamicSection_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfDynamicSection_initializeStorageClassArray( SgAsmElfDynamicSectionStorageClass *storageArray );
void SgAsmElfDynamicSection_resetValidFreepointers( );
unsigned long SgAsmElfDynamicSection_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfStringSection_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfStringSection* SgAsmElfStringSection_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfStringSection_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfStringSection* SgAsmElfStringSection_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfStringSection* SgAsmElfStringSection_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfStringSection_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfStringSection_clearMemoryPool ( );
void SgAsmElfStringSection_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfStringSection_initializeStorageClassArray( SgAsmElfStringSectionStorageClass *storageArray );
void SgAsmElfStringSection_resetValidFreepointers( );
unsigned long SgAsmElfStringSection_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfNoteSection_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfNoteSection* SgAsmElfNoteSection_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfNoteSection_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfNoteSection* SgAsmElfNoteSection_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfNoteSection* SgAsmElfNoteSection_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfNoteSection_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfNoteSection_clearMemoryPool ( );
void SgAsmElfNoteSection_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfNoteSection_initializeStorageClassArray( SgAsmElfNoteSectionStorageClass *storageArray );
void SgAsmElfNoteSection_resetValidFreepointers( );
unsigned long SgAsmElfNoteSection_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfEHFrameSection_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfEHFrameSection* SgAsmElfEHFrameSection_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfEHFrameSection_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfEHFrameSection* SgAsmElfEHFrameSection_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfEHFrameSection* SgAsmElfEHFrameSection_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfEHFrameSection_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfEHFrameSection_clearMemoryPool ( );
void SgAsmElfEHFrameSection_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfEHFrameSection_initializeStorageClassArray( SgAsmElfEHFrameSectionStorageClass *storageArray );
void SgAsmElfEHFrameSection_resetValidFreepointers( );
unsigned long SgAsmElfEHFrameSection_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfSymverSection_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfSymverSection* SgAsmElfSymverSection_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfSymverSection_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfSymverSection* SgAsmElfSymverSection_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfSymverSection* SgAsmElfSymverSection_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfSymverSection_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfSymverSection_clearMemoryPool ( );
void SgAsmElfSymverSection_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfSymverSection_initializeStorageClassArray( SgAsmElfSymverSectionStorageClass *storageArray );
void SgAsmElfSymverSection_resetValidFreepointers( );
unsigned long SgAsmElfSymverSection_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfSymverDefinedSection_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfSymverDefinedSection* SgAsmElfSymverDefinedSection_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfSymverDefinedSection_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfSymverDefinedSection* SgAsmElfSymverDefinedSection_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfSymverDefinedSection* SgAsmElfSymverDefinedSection_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfSymverDefinedSection_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfSymverDefinedSection_clearMemoryPool ( );
void SgAsmElfSymverDefinedSection_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfSymverDefinedSection_initializeStorageClassArray( SgAsmElfSymverDefinedSectionStorageClass *storageArray );
void SgAsmElfSymverDefinedSection_resetValidFreepointers( );
unsigned long SgAsmElfSymverDefinedSection_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfSymverNeededSection_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfSymverNeededSection* SgAsmElfSymverNeededSection_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfSymverNeededSection_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfSymverNeededSection* SgAsmElfSymverNeededSection_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfSymverNeededSection* SgAsmElfSymverNeededSection_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfSymverNeededSection_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfSymverNeededSection_clearMemoryPool ( );
void SgAsmElfSymverNeededSection_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfSymverNeededSection_initializeStorageClassArray( SgAsmElfSymverNeededSectionStorageClass *storageArray );
void SgAsmElfSymverNeededSection_resetValidFreepointers( );
unsigned long SgAsmElfSymverNeededSection_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfSectionTable_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfSectionTable* SgAsmElfSectionTable_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfSectionTable_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfSectionTable* SgAsmElfSectionTable_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfSectionTable* SgAsmElfSectionTable_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfSectionTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfSectionTable_clearMemoryPool ( );
void SgAsmElfSectionTable_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfSectionTable_initializeStorageClassArray( SgAsmElfSectionTableStorageClass *storageArray );
void SgAsmElfSectionTable_resetValidFreepointers( );
unsigned long SgAsmElfSectionTable_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfSegmentTable_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfSegmentTable* SgAsmElfSegmentTable_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfSegmentTable_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfSegmentTable* SgAsmElfSegmentTable_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfSegmentTable* SgAsmElfSegmentTable_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfSegmentTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfSegmentTable_clearMemoryPool ( );
void SgAsmElfSegmentTable_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfSegmentTable_initializeStorageClassArray( SgAsmElfSegmentTableStorageClass *storageArray );
void SgAsmElfSegmentTable_resetValidFreepointers( );
unsigned long SgAsmElfSegmentTable_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmPESection_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmPESection* SgAsmPESection_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmPESection_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmPESection* SgAsmPESection_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmPESection* SgAsmPESection_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmPESection_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmPESection_clearMemoryPool ( );
void SgAsmPESection_extendMemoryPoolForFileIO ( );
unsigned long SgAsmPESection_initializeStorageClassArray( SgAsmPESectionStorageClass *storageArray );
void SgAsmPESection_resetValidFreepointers( );
unsigned long SgAsmPESection_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmPEImportSection_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmPEImportSection* SgAsmPEImportSection_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmPEImportSection_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmPEImportSection* SgAsmPEImportSection_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmPEImportSection* SgAsmPEImportSection_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmPEImportSection_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmPEImportSection_clearMemoryPool ( );
void SgAsmPEImportSection_extendMemoryPoolForFileIO ( );
unsigned long SgAsmPEImportSection_initializeStorageClassArray( SgAsmPEImportSectionStorageClass *storageArray );
void SgAsmPEImportSection_resetValidFreepointers( );
unsigned long SgAsmPEImportSection_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmPEExportSection_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmPEExportSection* SgAsmPEExportSection_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmPEExportSection_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmPEExportSection* SgAsmPEExportSection_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmPEExportSection* SgAsmPEExportSection_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmPEExportSection_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmPEExportSection_clearMemoryPool ( );
void SgAsmPEExportSection_extendMemoryPoolForFileIO ( );
unsigned long SgAsmPEExportSection_initializeStorageClassArray( SgAsmPEExportSectionStorageClass *storageArray );
void SgAsmPEExportSection_resetValidFreepointers( );
unsigned long SgAsmPEExportSection_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmPEStringSection_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmPEStringSection* SgAsmPEStringSection_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmPEStringSection_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmPEStringSection* SgAsmPEStringSection_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmPEStringSection* SgAsmPEStringSection_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmPEStringSection_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmPEStringSection_clearMemoryPool ( );
void SgAsmPEStringSection_extendMemoryPoolForFileIO ( );
unsigned long SgAsmPEStringSection_initializeStorageClassArray( SgAsmPEStringSectionStorageClass *storageArray );
void SgAsmPEStringSection_resetValidFreepointers( );
unsigned long SgAsmPEStringSection_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmPESectionTable_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmPESectionTable* SgAsmPESectionTable_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmPESectionTable_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmPESectionTable* SgAsmPESectionTable_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmPESectionTable* SgAsmPESectionTable_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmPESectionTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmPESectionTable_clearMemoryPool ( );
void SgAsmPESectionTable_extendMemoryPoolForFileIO ( );
unsigned long SgAsmPESectionTable_initializeStorageClassArray( SgAsmPESectionTableStorageClass *storageArray );
void SgAsmPESectionTable_resetValidFreepointers( );
unsigned long SgAsmPESectionTable_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDOSExtendedHeader_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDOSExtendedHeader* SgAsmDOSExtendedHeader_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDOSExtendedHeader_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDOSExtendedHeader* SgAsmDOSExtendedHeader_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDOSExtendedHeader* SgAsmDOSExtendedHeader_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDOSExtendedHeader_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDOSExtendedHeader_clearMemoryPool ( );
void SgAsmDOSExtendedHeader_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDOSExtendedHeader_initializeStorageClassArray( SgAsmDOSExtendedHeaderStorageClass *storageArray );
void SgAsmDOSExtendedHeader_resetValidFreepointers( );
unsigned long SgAsmDOSExtendedHeader_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmCoffSymbolTable_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmCoffSymbolTable* SgAsmCoffSymbolTable_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmCoffSymbolTable_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmCoffSymbolTable* SgAsmCoffSymbolTable_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmCoffSymbolTable* SgAsmCoffSymbolTable_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmCoffSymbolTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmCoffSymbolTable_clearMemoryPool ( );
void SgAsmCoffSymbolTable_extendMemoryPoolForFileIO ( );
unsigned long SgAsmCoffSymbolTable_initializeStorageClassArray( SgAsmCoffSymbolTableStorageClass *storageArray );
void SgAsmCoffSymbolTable_resetValidFreepointers( );
unsigned long SgAsmCoffSymbolTable_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmNESection_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmNESection* SgAsmNESection_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmNESection_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmNESection* SgAsmNESection_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmNESection* SgAsmNESection_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmNESection_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmNESection_clearMemoryPool ( );
void SgAsmNESection_extendMemoryPoolForFileIO ( );
unsigned long SgAsmNESection_initializeStorageClassArray( SgAsmNESectionStorageClass *storageArray );
void SgAsmNESection_resetValidFreepointers( );
unsigned long SgAsmNESection_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmNESectionTable_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmNESectionTable* SgAsmNESectionTable_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmNESectionTable_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmNESectionTable* SgAsmNESectionTable_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmNESectionTable* SgAsmNESectionTable_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmNESectionTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmNESectionTable_clearMemoryPool ( );
void SgAsmNESectionTable_extendMemoryPoolForFileIO ( );
unsigned long SgAsmNESectionTable_initializeStorageClassArray( SgAsmNESectionTableStorageClass *storageArray );
void SgAsmNESectionTable_resetValidFreepointers( );
unsigned long SgAsmNESectionTable_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmNENameTable_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmNENameTable* SgAsmNENameTable_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmNENameTable_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmNENameTable* SgAsmNENameTable_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmNENameTable* SgAsmNENameTable_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmNENameTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmNENameTable_clearMemoryPool ( );
void SgAsmNENameTable_extendMemoryPoolForFileIO ( );
unsigned long SgAsmNENameTable_initializeStorageClassArray( SgAsmNENameTableStorageClass *storageArray );
void SgAsmNENameTable_resetValidFreepointers( );
unsigned long SgAsmNENameTable_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmNEModuleTable_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmNEModuleTable* SgAsmNEModuleTable_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmNEModuleTable_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmNEModuleTable* SgAsmNEModuleTable_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmNEModuleTable* SgAsmNEModuleTable_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmNEModuleTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmNEModuleTable_clearMemoryPool ( );
void SgAsmNEModuleTable_extendMemoryPoolForFileIO ( );
unsigned long SgAsmNEModuleTable_initializeStorageClassArray( SgAsmNEModuleTableStorageClass *storageArray );
void SgAsmNEModuleTable_resetValidFreepointers( );
unsigned long SgAsmNEModuleTable_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmNEStringTable_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmNEStringTable* SgAsmNEStringTable_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmNEStringTable_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmNEStringTable* SgAsmNEStringTable_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmNEStringTable* SgAsmNEStringTable_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmNEStringTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmNEStringTable_clearMemoryPool ( );
void SgAsmNEStringTable_extendMemoryPoolForFileIO ( );
unsigned long SgAsmNEStringTable_initializeStorageClassArray( SgAsmNEStringTableStorageClass *storageArray );
void SgAsmNEStringTable_resetValidFreepointers( );
unsigned long SgAsmNEStringTable_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmNEEntryTable_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmNEEntryTable* SgAsmNEEntryTable_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmNEEntryTable_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmNEEntryTable* SgAsmNEEntryTable_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmNEEntryTable* SgAsmNEEntryTable_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmNEEntryTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmNEEntryTable_clearMemoryPool ( );
void SgAsmNEEntryTable_extendMemoryPoolForFileIO ( );
unsigned long SgAsmNEEntryTable_initializeStorageClassArray( SgAsmNEEntryTableStorageClass *storageArray );
void SgAsmNEEntryTable_resetValidFreepointers( );
unsigned long SgAsmNEEntryTable_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmNERelocTable_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmNERelocTable* SgAsmNERelocTable_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmNERelocTable_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmNERelocTable* SgAsmNERelocTable_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmNERelocTable* SgAsmNERelocTable_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmNERelocTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmNERelocTable_clearMemoryPool ( );
void SgAsmNERelocTable_extendMemoryPoolForFileIO ( );
unsigned long SgAsmNERelocTable_initializeStorageClassArray( SgAsmNERelocTableStorageClass *storageArray );
void SgAsmNERelocTable_resetValidFreepointers( );
unsigned long SgAsmNERelocTable_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmLESection_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmLESection* SgAsmLESection_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmLESection_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmLESection* SgAsmLESection_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmLESection* SgAsmLESection_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmLESection_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmLESection_clearMemoryPool ( );
void SgAsmLESection_extendMemoryPoolForFileIO ( );
unsigned long SgAsmLESection_initializeStorageClassArray( SgAsmLESectionStorageClass *storageArray );
void SgAsmLESection_resetValidFreepointers( );
unsigned long SgAsmLESection_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmLESectionTable_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmLESectionTable* SgAsmLESectionTable_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmLESectionTable_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmLESectionTable* SgAsmLESectionTable_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmLESectionTable* SgAsmLESectionTable_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmLESectionTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmLESectionTable_clearMemoryPool ( );
void SgAsmLESectionTable_extendMemoryPoolForFileIO ( );
unsigned long SgAsmLESectionTable_initializeStorageClassArray( SgAsmLESectionTableStorageClass *storageArray );
void SgAsmLESectionTable_resetValidFreepointers( );
unsigned long SgAsmLESectionTable_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmLENameTable_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmLENameTable* SgAsmLENameTable_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmLENameTable_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmLENameTable* SgAsmLENameTable_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmLENameTable* SgAsmLENameTable_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmLENameTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmLENameTable_clearMemoryPool ( );
void SgAsmLENameTable_extendMemoryPoolForFileIO ( );
unsigned long SgAsmLENameTable_initializeStorageClassArray( SgAsmLENameTableStorageClass *storageArray );
void SgAsmLENameTable_resetValidFreepointers( );
unsigned long SgAsmLENameTable_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmLEPageTable_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmLEPageTable* SgAsmLEPageTable_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmLEPageTable_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmLEPageTable* SgAsmLEPageTable_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmLEPageTable* SgAsmLEPageTable_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmLEPageTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmLEPageTable_clearMemoryPool ( );
void SgAsmLEPageTable_extendMemoryPoolForFileIO ( );
unsigned long SgAsmLEPageTable_initializeStorageClassArray( SgAsmLEPageTableStorageClass *storageArray );
void SgAsmLEPageTable_resetValidFreepointers( );
unsigned long SgAsmLEPageTable_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmLEEntryTable_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmLEEntryTable* SgAsmLEEntryTable_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmLEEntryTable_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmLEEntryTable* SgAsmLEEntryTable_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmLEEntryTable* SgAsmLEEntryTable_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmLEEntryTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmLEEntryTable_clearMemoryPool ( );
void SgAsmLEEntryTable_extendMemoryPoolForFileIO ( );
unsigned long SgAsmLEEntryTable_initializeStorageClassArray( SgAsmLEEntryTableStorageClass *storageArray );
void SgAsmLEEntryTable_resetValidFreepointers( );
unsigned long SgAsmLEEntryTable_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmLERelocTable_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmLERelocTable* SgAsmLERelocTable_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmLERelocTable_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmLERelocTable* SgAsmLERelocTable_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmLERelocTable* SgAsmLERelocTable_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmLERelocTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmLERelocTable_clearMemoryPool ( );
void SgAsmLERelocTable_extendMemoryPoolForFileIO ( );
unsigned long SgAsmLERelocTable_initializeStorageClassArray( SgAsmLERelocTableStorageClass *storageArray );
void SgAsmLERelocTable_resetValidFreepointers( );
unsigned long SgAsmLERelocTable_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmGenericSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmGenericSymbol* SgAsmGenericSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmGenericSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmGenericSymbol* SgAsmGenericSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmGenericSymbol* SgAsmGenericSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmGenericSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmGenericSymbol_clearMemoryPool ( );
void SgAsmGenericSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgAsmGenericSymbol_initializeStorageClassArray( SgAsmGenericSymbolStorageClass *storageArray );
void SgAsmGenericSymbol_resetValidFreepointers( );
unsigned long SgAsmGenericSymbol_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmCoffSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmCoffSymbol* SgAsmCoffSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmCoffSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmCoffSymbol* SgAsmCoffSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmCoffSymbol* SgAsmCoffSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmCoffSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmCoffSymbol_clearMemoryPool ( );
void SgAsmCoffSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgAsmCoffSymbol_initializeStorageClassArray( SgAsmCoffSymbolStorageClass *storageArray );
void SgAsmCoffSymbol_resetValidFreepointers( );
unsigned long SgAsmCoffSymbol_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfSymbol* SgAsmElfSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfSymbol* SgAsmElfSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfSymbol* SgAsmElfSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfSymbol_clearMemoryPool ( );
void SgAsmElfSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfSymbol_initializeStorageClassArray( SgAsmElfSymbolStorageClass *storageArray );
void SgAsmElfSymbol_resetValidFreepointers( );
unsigned long SgAsmElfSymbol_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmGenericStrtab_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmGenericStrtab* SgAsmGenericStrtab_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmGenericStrtab_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmGenericStrtab* SgAsmGenericStrtab_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmGenericStrtab* SgAsmGenericStrtab_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmGenericStrtab_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmGenericStrtab_clearMemoryPool ( );
void SgAsmGenericStrtab_extendMemoryPoolForFileIO ( );
unsigned long SgAsmGenericStrtab_initializeStorageClassArray( SgAsmGenericStrtabStorageClass *storageArray );
void SgAsmGenericStrtab_resetValidFreepointers( );
unsigned long SgAsmGenericStrtab_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfStrtab_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfStrtab* SgAsmElfStrtab_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfStrtab_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfStrtab* SgAsmElfStrtab_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfStrtab* SgAsmElfStrtab_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfStrtab_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfStrtab_clearMemoryPool ( );
void SgAsmElfStrtab_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfStrtab_initializeStorageClassArray( SgAsmElfStrtabStorageClass *storageArray );
void SgAsmElfStrtab_resetValidFreepointers( );
unsigned long SgAsmElfStrtab_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmCoffStrtab_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmCoffStrtab* SgAsmCoffStrtab_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmCoffStrtab_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmCoffStrtab* SgAsmCoffStrtab_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmCoffStrtab* SgAsmCoffStrtab_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmCoffStrtab_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmCoffStrtab_clearMemoryPool ( );
void SgAsmCoffStrtab_extendMemoryPoolForFileIO ( );
unsigned long SgAsmCoffStrtab_initializeStorageClassArray( SgAsmCoffStrtabStorageClass *storageArray );
void SgAsmCoffStrtab_resetValidFreepointers( );
unsigned long SgAsmCoffStrtab_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmGenericSymbolList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmGenericSymbolList* SgAsmGenericSymbolList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmGenericSymbolList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmGenericSymbolList* SgAsmGenericSymbolList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmGenericSymbolList* SgAsmGenericSymbolList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmGenericSymbolList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmGenericSymbolList_clearMemoryPool ( );
void SgAsmGenericSymbolList_extendMemoryPoolForFileIO ( );
unsigned long SgAsmGenericSymbolList_initializeStorageClassArray( SgAsmGenericSymbolListStorageClass *storageArray );
void SgAsmGenericSymbolList_resetValidFreepointers( );
unsigned long SgAsmGenericSymbolList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmGenericSectionList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmGenericSectionList* SgAsmGenericSectionList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmGenericSectionList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmGenericSectionList* SgAsmGenericSectionList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmGenericSectionList* SgAsmGenericSectionList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmGenericSectionList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmGenericSectionList_clearMemoryPool ( );
void SgAsmGenericSectionList_extendMemoryPoolForFileIO ( );
unsigned long SgAsmGenericSectionList_initializeStorageClassArray( SgAsmGenericSectionListStorageClass *storageArray );
void SgAsmGenericSectionList_resetValidFreepointers( );
unsigned long SgAsmGenericSectionList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmGenericHeaderList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmGenericHeaderList* SgAsmGenericHeaderList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmGenericHeaderList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmGenericHeaderList* SgAsmGenericHeaderList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmGenericHeaderList* SgAsmGenericHeaderList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmGenericHeaderList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmGenericHeaderList_clearMemoryPool ( );
void SgAsmGenericHeaderList_extendMemoryPoolForFileIO ( );
unsigned long SgAsmGenericHeaderList_initializeStorageClassArray( SgAsmGenericHeaderListStorageClass *storageArray );
void SgAsmGenericHeaderList_resetValidFreepointers( );
unsigned long SgAsmGenericHeaderList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmGenericString_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmGenericString* SgAsmGenericString_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmGenericString_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmGenericString* SgAsmGenericString_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmGenericString* SgAsmGenericString_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmGenericString_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmGenericString_clearMemoryPool ( );
void SgAsmGenericString_extendMemoryPoolForFileIO ( );
unsigned long SgAsmGenericString_initializeStorageClassArray( SgAsmGenericStringStorageClass *storageArray );
void SgAsmGenericString_resetValidFreepointers( );
unsigned long SgAsmGenericString_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmBasicString_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmBasicString* SgAsmBasicString_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmBasicString_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmBasicString* SgAsmBasicString_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmBasicString* SgAsmBasicString_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmBasicString_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmBasicString_clearMemoryPool ( );
void SgAsmBasicString_extendMemoryPoolForFileIO ( );
unsigned long SgAsmBasicString_initializeStorageClassArray( SgAsmBasicStringStorageClass *storageArray );
void SgAsmBasicString_resetValidFreepointers( );
unsigned long SgAsmBasicString_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmStoredString_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmStoredString* SgAsmStoredString_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmStoredString_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmStoredString* SgAsmStoredString_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmStoredString* SgAsmStoredString_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmStoredString_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmStoredString_clearMemoryPool ( );
void SgAsmStoredString_extendMemoryPoolForFileIO ( );
unsigned long SgAsmStoredString_initializeStorageClassArray( SgAsmStoredStringStorageClass *storageArray );
void SgAsmStoredString_resetValidFreepointers( );
unsigned long SgAsmStoredString_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfSectionTableEntry_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfSectionTableEntry* SgAsmElfSectionTableEntry_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfSectionTableEntry_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfSectionTableEntry* SgAsmElfSectionTableEntry_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfSectionTableEntry* SgAsmElfSectionTableEntry_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfSectionTableEntry_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfSectionTableEntry_clearMemoryPool ( );
void SgAsmElfSectionTableEntry_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfSectionTableEntry_initializeStorageClassArray( SgAsmElfSectionTableEntryStorageClass *storageArray );
void SgAsmElfSectionTableEntry_resetValidFreepointers( );
unsigned long SgAsmElfSectionTableEntry_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfSegmentTableEntry_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfSegmentTableEntry* SgAsmElfSegmentTableEntry_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfSegmentTableEntry_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfSegmentTableEntry* SgAsmElfSegmentTableEntry_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfSegmentTableEntry* SgAsmElfSegmentTableEntry_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfSegmentTableEntry_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfSegmentTableEntry_clearMemoryPool ( );
void SgAsmElfSegmentTableEntry_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfSegmentTableEntry_initializeStorageClassArray( SgAsmElfSegmentTableEntryStorageClass *storageArray );
void SgAsmElfSegmentTableEntry_resetValidFreepointers( );
unsigned long SgAsmElfSegmentTableEntry_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfSymbolList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfSymbolList* SgAsmElfSymbolList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfSymbolList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfSymbolList* SgAsmElfSymbolList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfSymbolList* SgAsmElfSymbolList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfSymbolList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfSymbolList_clearMemoryPool ( );
void SgAsmElfSymbolList_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfSymbolList_initializeStorageClassArray( SgAsmElfSymbolListStorageClass *storageArray );
void SgAsmElfSymbolList_resetValidFreepointers( );
unsigned long SgAsmElfSymbolList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfRelocEntry_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfRelocEntry* SgAsmElfRelocEntry_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfRelocEntry_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfRelocEntry* SgAsmElfRelocEntry_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfRelocEntry* SgAsmElfRelocEntry_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfRelocEntry_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfRelocEntry_clearMemoryPool ( );
void SgAsmElfRelocEntry_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfRelocEntry_initializeStorageClassArray( SgAsmElfRelocEntryStorageClass *storageArray );
void SgAsmElfRelocEntry_resetValidFreepointers( );
unsigned long SgAsmElfRelocEntry_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfRelocEntryList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfRelocEntryList* SgAsmElfRelocEntryList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfRelocEntryList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfRelocEntryList* SgAsmElfRelocEntryList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfRelocEntryList* SgAsmElfRelocEntryList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfRelocEntryList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfRelocEntryList_clearMemoryPool ( );
void SgAsmElfRelocEntryList_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfRelocEntryList_initializeStorageClassArray( SgAsmElfRelocEntryListStorageClass *storageArray );
void SgAsmElfRelocEntryList_resetValidFreepointers( );
unsigned long SgAsmElfRelocEntryList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmPEExportEntry_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmPEExportEntry* SgAsmPEExportEntry_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmPEExportEntry_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmPEExportEntry* SgAsmPEExportEntry_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmPEExportEntry* SgAsmPEExportEntry_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmPEExportEntry_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmPEExportEntry_clearMemoryPool ( );
void SgAsmPEExportEntry_extendMemoryPoolForFileIO ( );
unsigned long SgAsmPEExportEntry_initializeStorageClassArray( SgAsmPEExportEntryStorageClass *storageArray );
void SgAsmPEExportEntry_resetValidFreepointers( );
unsigned long SgAsmPEExportEntry_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmPEExportEntryList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmPEExportEntryList* SgAsmPEExportEntryList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmPEExportEntryList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmPEExportEntryList* SgAsmPEExportEntryList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmPEExportEntryList* SgAsmPEExportEntryList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmPEExportEntryList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmPEExportEntryList_clearMemoryPool ( );
void SgAsmPEExportEntryList_extendMemoryPoolForFileIO ( );
unsigned long SgAsmPEExportEntryList_initializeStorageClassArray( SgAsmPEExportEntryListStorageClass *storageArray );
void SgAsmPEExportEntryList_resetValidFreepointers( );
unsigned long SgAsmPEExportEntryList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfDynamicEntry_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfDynamicEntry* SgAsmElfDynamicEntry_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfDynamicEntry_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfDynamicEntry* SgAsmElfDynamicEntry_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfDynamicEntry* SgAsmElfDynamicEntry_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfDynamicEntry_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfDynamicEntry_clearMemoryPool ( );
void SgAsmElfDynamicEntry_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfDynamicEntry_initializeStorageClassArray( SgAsmElfDynamicEntryStorageClass *storageArray );
void SgAsmElfDynamicEntry_resetValidFreepointers( );
unsigned long SgAsmElfDynamicEntry_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfDynamicEntryList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfDynamicEntryList* SgAsmElfDynamicEntryList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfDynamicEntryList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfDynamicEntryList* SgAsmElfDynamicEntryList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfDynamicEntryList* SgAsmElfDynamicEntryList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfDynamicEntryList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfDynamicEntryList_clearMemoryPool ( );
void SgAsmElfDynamicEntryList_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfDynamicEntryList_initializeStorageClassArray( SgAsmElfDynamicEntryListStorageClass *storageArray );
void SgAsmElfDynamicEntryList_resetValidFreepointers( );
unsigned long SgAsmElfDynamicEntryList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfSegmentTableEntryList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfSegmentTableEntryList* SgAsmElfSegmentTableEntryList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfSegmentTableEntryList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfSegmentTableEntryList* SgAsmElfSegmentTableEntryList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfSegmentTableEntryList* SgAsmElfSegmentTableEntryList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfSegmentTableEntryList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfSegmentTableEntryList_clearMemoryPool ( );
void SgAsmElfSegmentTableEntryList_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfSegmentTableEntryList_initializeStorageClassArray( SgAsmElfSegmentTableEntryListStorageClass *storageArray );
void SgAsmElfSegmentTableEntryList_resetValidFreepointers( );
unsigned long SgAsmElfSegmentTableEntryList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmStringStorage_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmStringStorage* SgAsmStringStorage_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmStringStorage_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmStringStorage* SgAsmStringStorage_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmStringStorage* SgAsmStringStorage_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmStringStorage_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmStringStorage_clearMemoryPool ( );
void SgAsmStringStorage_extendMemoryPoolForFileIO ( );
unsigned long SgAsmStringStorage_initializeStorageClassArray( SgAsmStringStorageStorageClass *storageArray );
void SgAsmStringStorage_resetValidFreepointers( );
unsigned long SgAsmStringStorage_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfNoteEntry_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfNoteEntry* SgAsmElfNoteEntry_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfNoteEntry_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfNoteEntry* SgAsmElfNoteEntry_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfNoteEntry* SgAsmElfNoteEntry_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfNoteEntry_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfNoteEntry_clearMemoryPool ( );
void SgAsmElfNoteEntry_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfNoteEntry_initializeStorageClassArray( SgAsmElfNoteEntryStorageClass *storageArray );
void SgAsmElfNoteEntry_resetValidFreepointers( );
unsigned long SgAsmElfNoteEntry_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfNoteEntryList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfNoteEntryList* SgAsmElfNoteEntryList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfNoteEntryList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfNoteEntryList* SgAsmElfNoteEntryList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfNoteEntryList* SgAsmElfNoteEntryList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfNoteEntryList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfNoteEntryList_clearMemoryPool ( );
void SgAsmElfNoteEntryList_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfNoteEntryList_initializeStorageClassArray( SgAsmElfNoteEntryListStorageClass *storageArray );
void SgAsmElfNoteEntryList_resetValidFreepointers( );
unsigned long SgAsmElfNoteEntryList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfSymverEntry_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfSymverEntry* SgAsmElfSymverEntry_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfSymverEntry_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfSymverEntry* SgAsmElfSymverEntry_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfSymverEntry* SgAsmElfSymverEntry_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfSymverEntry_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfSymverEntry_clearMemoryPool ( );
void SgAsmElfSymverEntry_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfSymverEntry_initializeStorageClassArray( SgAsmElfSymverEntryStorageClass *storageArray );
void SgAsmElfSymverEntry_resetValidFreepointers( );
unsigned long SgAsmElfSymverEntry_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfSymverEntryList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfSymverEntryList* SgAsmElfSymverEntryList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfSymverEntryList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfSymverEntryList* SgAsmElfSymverEntryList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfSymverEntryList* SgAsmElfSymverEntryList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfSymverEntryList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfSymverEntryList_clearMemoryPool ( );
void SgAsmElfSymverEntryList_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfSymverEntryList_initializeStorageClassArray( SgAsmElfSymverEntryListStorageClass *storageArray );
void SgAsmElfSymverEntryList_resetValidFreepointers( );
unsigned long SgAsmElfSymverEntryList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfSymverDefinedEntry_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfSymverDefinedEntry* SgAsmElfSymverDefinedEntry_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfSymverDefinedEntry_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfSymverDefinedEntry* SgAsmElfSymverDefinedEntry_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfSymverDefinedEntry* SgAsmElfSymverDefinedEntry_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfSymverDefinedEntry_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfSymverDefinedEntry_clearMemoryPool ( );
void SgAsmElfSymverDefinedEntry_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfSymverDefinedEntry_initializeStorageClassArray( SgAsmElfSymverDefinedEntryStorageClass *storageArray );
void SgAsmElfSymverDefinedEntry_resetValidFreepointers( );
unsigned long SgAsmElfSymverDefinedEntry_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfSymverDefinedEntryList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfSymverDefinedEntryList* SgAsmElfSymverDefinedEntryList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfSymverDefinedEntryList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfSymverDefinedEntryList* SgAsmElfSymverDefinedEntryList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfSymverDefinedEntryList* SgAsmElfSymverDefinedEntryList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfSymverDefinedEntryList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfSymverDefinedEntryList_clearMemoryPool ( );
void SgAsmElfSymverDefinedEntryList_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfSymverDefinedEntryList_initializeStorageClassArray( SgAsmElfSymverDefinedEntryListStorageClass *storageArray );
void SgAsmElfSymverDefinedEntryList_resetValidFreepointers( );
unsigned long SgAsmElfSymverDefinedEntryList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfSymverDefinedAux_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfSymverDefinedAux* SgAsmElfSymverDefinedAux_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfSymverDefinedAux_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfSymverDefinedAux* SgAsmElfSymverDefinedAux_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfSymverDefinedAux* SgAsmElfSymverDefinedAux_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfSymverDefinedAux_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfSymverDefinedAux_clearMemoryPool ( );
void SgAsmElfSymverDefinedAux_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfSymverDefinedAux_initializeStorageClassArray( SgAsmElfSymverDefinedAuxStorageClass *storageArray );
void SgAsmElfSymverDefinedAux_resetValidFreepointers( );
unsigned long SgAsmElfSymverDefinedAux_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfSymverDefinedAuxList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfSymverDefinedAuxList* SgAsmElfSymverDefinedAuxList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfSymverDefinedAuxList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfSymverDefinedAuxList* SgAsmElfSymverDefinedAuxList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfSymverDefinedAuxList* SgAsmElfSymverDefinedAuxList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfSymverDefinedAuxList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfSymverDefinedAuxList_clearMemoryPool ( );
void SgAsmElfSymverDefinedAuxList_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfSymverDefinedAuxList_initializeStorageClassArray( SgAsmElfSymverDefinedAuxListStorageClass *storageArray );
void SgAsmElfSymverDefinedAuxList_resetValidFreepointers( );
unsigned long SgAsmElfSymverDefinedAuxList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfSymverNeededEntry_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfSymverNeededEntry* SgAsmElfSymverNeededEntry_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfSymverNeededEntry_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfSymverNeededEntry* SgAsmElfSymverNeededEntry_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfSymverNeededEntry* SgAsmElfSymverNeededEntry_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfSymverNeededEntry_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfSymverNeededEntry_clearMemoryPool ( );
void SgAsmElfSymverNeededEntry_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfSymverNeededEntry_initializeStorageClassArray( SgAsmElfSymverNeededEntryStorageClass *storageArray );
void SgAsmElfSymverNeededEntry_resetValidFreepointers( );
unsigned long SgAsmElfSymverNeededEntry_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfSymverNeededEntryList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfSymverNeededEntryList* SgAsmElfSymverNeededEntryList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfSymverNeededEntryList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfSymverNeededEntryList* SgAsmElfSymverNeededEntryList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfSymverNeededEntryList* SgAsmElfSymverNeededEntryList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfSymverNeededEntryList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfSymverNeededEntryList_clearMemoryPool ( );
void SgAsmElfSymverNeededEntryList_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfSymverNeededEntryList_initializeStorageClassArray( SgAsmElfSymverNeededEntryListStorageClass *storageArray );
void SgAsmElfSymverNeededEntryList_resetValidFreepointers( );
unsigned long SgAsmElfSymverNeededEntryList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfSymverNeededAux_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfSymverNeededAux* SgAsmElfSymverNeededAux_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfSymverNeededAux_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfSymverNeededAux* SgAsmElfSymverNeededAux_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfSymverNeededAux* SgAsmElfSymverNeededAux_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfSymverNeededAux_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfSymverNeededAux_clearMemoryPool ( );
void SgAsmElfSymverNeededAux_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfSymverNeededAux_initializeStorageClassArray( SgAsmElfSymverNeededAuxStorageClass *storageArray );
void SgAsmElfSymverNeededAux_resetValidFreepointers( );
unsigned long SgAsmElfSymverNeededAux_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfSymverNeededAuxList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfSymverNeededAuxList* SgAsmElfSymverNeededAuxList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfSymverNeededAuxList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfSymverNeededAuxList* SgAsmElfSymverNeededAuxList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfSymverNeededAuxList* SgAsmElfSymverNeededAuxList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfSymverNeededAuxList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfSymverNeededAuxList_clearMemoryPool ( );
void SgAsmElfSymverNeededAuxList_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfSymverNeededAuxList_initializeStorageClassArray( SgAsmElfSymverNeededAuxListStorageClass *storageArray );
void SgAsmElfSymverNeededAuxList_resetValidFreepointers( );
unsigned long SgAsmElfSymverNeededAuxList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmPEImportDirectory_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmPEImportDirectory* SgAsmPEImportDirectory_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmPEImportDirectory_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmPEImportDirectory* SgAsmPEImportDirectory_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmPEImportDirectory* SgAsmPEImportDirectory_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmPEImportDirectory_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmPEImportDirectory_clearMemoryPool ( );
void SgAsmPEImportDirectory_extendMemoryPoolForFileIO ( );
unsigned long SgAsmPEImportDirectory_initializeStorageClassArray( SgAsmPEImportDirectoryStorageClass *storageArray );
void SgAsmPEImportDirectory_resetValidFreepointers( );
unsigned long SgAsmPEImportDirectory_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmPESectionTableEntry_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmPESectionTableEntry* SgAsmPESectionTableEntry_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmPESectionTableEntry_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmPESectionTableEntry* SgAsmPESectionTableEntry_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmPESectionTableEntry* SgAsmPESectionTableEntry_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmPESectionTableEntry_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmPESectionTableEntry_clearMemoryPool ( );
void SgAsmPESectionTableEntry_extendMemoryPoolForFileIO ( );
unsigned long SgAsmPESectionTableEntry_initializeStorageClassArray( SgAsmPESectionTableEntryStorageClass *storageArray );
void SgAsmPESectionTableEntry_resetValidFreepointers( );
unsigned long SgAsmPESectionTableEntry_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmPEExportDirectory_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmPEExportDirectory* SgAsmPEExportDirectory_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmPEExportDirectory_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmPEExportDirectory* SgAsmPEExportDirectory_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmPEExportDirectory* SgAsmPEExportDirectory_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmPEExportDirectory_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmPEExportDirectory_clearMemoryPool ( );
void SgAsmPEExportDirectory_extendMemoryPoolForFileIO ( );
unsigned long SgAsmPEExportDirectory_initializeStorageClassArray( SgAsmPEExportDirectoryStorageClass *storageArray );
void SgAsmPEExportDirectory_resetValidFreepointers( );
unsigned long SgAsmPEExportDirectory_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmPERVASizePair_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmPERVASizePair* SgAsmPERVASizePair_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmPERVASizePair_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmPERVASizePair* SgAsmPERVASizePair_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmPERVASizePair* SgAsmPERVASizePair_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmPERVASizePair_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmPERVASizePair_clearMemoryPool ( );
void SgAsmPERVASizePair_extendMemoryPoolForFileIO ( );
unsigned long SgAsmPERVASizePair_initializeStorageClassArray( SgAsmPERVASizePairStorageClass *storageArray );
void SgAsmPERVASizePair_resetValidFreepointers( );
unsigned long SgAsmPERVASizePair_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmCoffSymbolList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmCoffSymbolList* SgAsmCoffSymbolList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmCoffSymbolList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmCoffSymbolList* SgAsmCoffSymbolList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmCoffSymbolList* SgAsmCoffSymbolList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmCoffSymbolList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmCoffSymbolList_clearMemoryPool ( );
void SgAsmCoffSymbolList_extendMemoryPoolForFileIO ( );
unsigned long SgAsmCoffSymbolList_initializeStorageClassArray( SgAsmCoffSymbolListStorageClass *storageArray );
void SgAsmCoffSymbolList_resetValidFreepointers( );
unsigned long SgAsmCoffSymbolList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmPERVASizePairList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmPERVASizePairList* SgAsmPERVASizePairList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmPERVASizePairList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmPERVASizePairList* SgAsmPERVASizePairList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmPERVASizePairList* SgAsmPERVASizePairList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmPERVASizePairList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmPERVASizePairList_clearMemoryPool ( );
void SgAsmPERVASizePairList_extendMemoryPoolForFileIO ( );
unsigned long SgAsmPERVASizePairList_initializeStorageClassArray( SgAsmPERVASizePairListStorageClass *storageArray );
void SgAsmPERVASizePairList_resetValidFreepointers( );
unsigned long SgAsmPERVASizePairList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfEHFrameEntryCI_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfEHFrameEntryCI* SgAsmElfEHFrameEntryCI_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfEHFrameEntryCI_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfEHFrameEntryCI* SgAsmElfEHFrameEntryCI_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfEHFrameEntryCI* SgAsmElfEHFrameEntryCI_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfEHFrameEntryCI_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfEHFrameEntryCI_clearMemoryPool ( );
void SgAsmElfEHFrameEntryCI_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfEHFrameEntryCI_initializeStorageClassArray( SgAsmElfEHFrameEntryCIStorageClass *storageArray );
void SgAsmElfEHFrameEntryCI_resetValidFreepointers( );
unsigned long SgAsmElfEHFrameEntryCI_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmPEImportDirectoryList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmPEImportDirectoryList* SgAsmPEImportDirectoryList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmPEImportDirectoryList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmPEImportDirectoryList* SgAsmPEImportDirectoryList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmPEImportDirectoryList* SgAsmPEImportDirectoryList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmPEImportDirectoryList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmPEImportDirectoryList_clearMemoryPool ( );
void SgAsmPEImportDirectoryList_extendMemoryPoolForFileIO ( );
unsigned long SgAsmPEImportDirectoryList_initializeStorageClassArray( SgAsmPEImportDirectoryListStorageClass *storageArray );
void SgAsmPEImportDirectoryList_resetValidFreepointers( );
unsigned long SgAsmPEImportDirectoryList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmNEEntryPoint_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmNEEntryPoint* SgAsmNEEntryPoint_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmNEEntryPoint_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmNEEntryPoint* SgAsmNEEntryPoint_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmNEEntryPoint* SgAsmNEEntryPoint_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmNEEntryPoint_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmNEEntryPoint_clearMemoryPool ( );
void SgAsmNEEntryPoint_extendMemoryPoolForFileIO ( );
unsigned long SgAsmNEEntryPoint_initializeStorageClassArray( SgAsmNEEntryPointStorageClass *storageArray );
void SgAsmNEEntryPoint_resetValidFreepointers( );
unsigned long SgAsmNEEntryPoint_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmNERelocEntry_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmNERelocEntry* SgAsmNERelocEntry_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmNERelocEntry_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmNERelocEntry* SgAsmNERelocEntry_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmNERelocEntry* SgAsmNERelocEntry_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmNERelocEntry_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmNERelocEntry_clearMemoryPool ( );
void SgAsmNERelocEntry_extendMemoryPoolForFileIO ( );
unsigned long SgAsmNERelocEntry_initializeStorageClassArray( SgAsmNERelocEntryStorageClass *storageArray );
void SgAsmNERelocEntry_resetValidFreepointers( );
unsigned long SgAsmNERelocEntry_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmNESectionTableEntry_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmNESectionTableEntry* SgAsmNESectionTableEntry_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmNESectionTableEntry_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmNESectionTableEntry* SgAsmNESectionTableEntry_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmNESectionTableEntry* SgAsmNESectionTableEntry_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmNESectionTableEntry_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmNESectionTableEntry_clearMemoryPool ( );
void SgAsmNESectionTableEntry_extendMemoryPoolForFileIO ( );
unsigned long SgAsmNESectionTableEntry_initializeStorageClassArray( SgAsmNESectionTableEntryStorageClass *storageArray );
void SgAsmNESectionTableEntry_resetValidFreepointers( );
unsigned long SgAsmNESectionTableEntry_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfEHFrameEntryCIList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfEHFrameEntryCIList* SgAsmElfEHFrameEntryCIList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfEHFrameEntryCIList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfEHFrameEntryCIList* SgAsmElfEHFrameEntryCIList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfEHFrameEntryCIList* SgAsmElfEHFrameEntryCIList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfEHFrameEntryCIList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfEHFrameEntryCIList_clearMemoryPool ( );
void SgAsmElfEHFrameEntryCIList_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfEHFrameEntryCIList_initializeStorageClassArray( SgAsmElfEHFrameEntryCIListStorageClass *storageArray );
void SgAsmElfEHFrameEntryCIList_resetValidFreepointers( );
unsigned long SgAsmElfEHFrameEntryCIList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmLEPageTableEntry_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmLEPageTableEntry* SgAsmLEPageTableEntry_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmLEPageTableEntry_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmLEPageTableEntry* SgAsmLEPageTableEntry_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmLEPageTableEntry* SgAsmLEPageTableEntry_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmLEPageTableEntry_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmLEPageTableEntry_clearMemoryPool ( );
void SgAsmLEPageTableEntry_extendMemoryPoolForFileIO ( );
unsigned long SgAsmLEPageTableEntry_initializeStorageClassArray( SgAsmLEPageTableEntryStorageClass *storageArray );
void SgAsmLEPageTableEntry_resetValidFreepointers( );
unsigned long SgAsmLEPageTableEntry_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmLEEntryPoint_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmLEEntryPoint* SgAsmLEEntryPoint_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmLEEntryPoint_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmLEEntryPoint* SgAsmLEEntryPoint_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmLEEntryPoint* SgAsmLEEntryPoint_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmLEEntryPoint_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmLEEntryPoint_clearMemoryPool ( );
void SgAsmLEEntryPoint_extendMemoryPoolForFileIO ( );
unsigned long SgAsmLEEntryPoint_initializeStorageClassArray( SgAsmLEEntryPointStorageClass *storageArray );
void SgAsmLEEntryPoint_resetValidFreepointers( );
unsigned long SgAsmLEEntryPoint_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmLESectionTableEntry_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmLESectionTableEntry* SgAsmLESectionTableEntry_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmLESectionTableEntry_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmLESectionTableEntry* SgAsmLESectionTableEntry_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmLESectionTableEntry* SgAsmLESectionTableEntry_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmLESectionTableEntry_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmLESectionTableEntry_clearMemoryPool ( );
void SgAsmLESectionTableEntry_extendMemoryPoolForFileIO ( );
unsigned long SgAsmLESectionTableEntry_initializeStorageClassArray( SgAsmLESectionTableEntryStorageClass *storageArray );
void SgAsmLESectionTableEntry_resetValidFreepointers( );
unsigned long SgAsmLESectionTableEntry_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmElfEHFrameEntryFDList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmElfEHFrameEntryFDList* SgAsmElfEHFrameEntryFDList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmElfEHFrameEntryFDList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmElfEHFrameEntryFDList* SgAsmElfEHFrameEntryFDList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmElfEHFrameEntryFDList* SgAsmElfEHFrameEntryFDList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmElfEHFrameEntryFDList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmElfEHFrameEntryFDList_clearMemoryPool ( );
void SgAsmElfEHFrameEntryFDList_extendMemoryPoolForFileIO ( );
unsigned long SgAsmElfEHFrameEntryFDList_initializeStorageClassArray( SgAsmElfEHFrameEntryFDListStorageClass *storageArray );
void SgAsmElfEHFrameEntryFDList_resetValidFreepointers( );
unsigned long SgAsmElfEHFrameEntryFDList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfInformation_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfInformation* SgAsmDwarfInformation_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfInformation_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfInformation* SgAsmDwarfInformation_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfInformation* SgAsmDwarfInformation_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfInformation_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfInformation_clearMemoryPool ( );
void SgAsmDwarfInformation_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfInformation_initializeStorageClassArray( SgAsmDwarfInformationStorageClass *storageArray );
void SgAsmDwarfInformation_resetValidFreepointers( );
unsigned long SgAsmDwarfInformation_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfMacro_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfMacro* SgAsmDwarfMacro_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfMacro_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfMacro* SgAsmDwarfMacro_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfMacro* SgAsmDwarfMacro_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfMacro_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfMacro_clearMemoryPool ( );
void SgAsmDwarfMacro_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfMacro_initializeStorageClassArray( SgAsmDwarfMacroStorageClass *storageArray );
void SgAsmDwarfMacro_resetValidFreepointers( );
unsigned long SgAsmDwarfMacro_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfMacroList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfMacroList* SgAsmDwarfMacroList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfMacroList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfMacroList* SgAsmDwarfMacroList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfMacroList* SgAsmDwarfMacroList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfMacroList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfMacroList_clearMemoryPool ( );
void SgAsmDwarfMacroList_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfMacroList_initializeStorageClassArray( SgAsmDwarfMacroListStorageClass *storageArray );
void SgAsmDwarfMacroList_resetValidFreepointers( );
unsigned long SgAsmDwarfMacroList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfLine_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfLine* SgAsmDwarfLine_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfLine_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfLine* SgAsmDwarfLine_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfLine* SgAsmDwarfLine_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfLine_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfLine_clearMemoryPool ( );
void SgAsmDwarfLine_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfLine_initializeStorageClassArray( SgAsmDwarfLineStorageClass *storageArray );
void SgAsmDwarfLine_resetValidFreepointers( );
unsigned long SgAsmDwarfLine_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfLineList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfLineList* SgAsmDwarfLineList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfLineList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfLineList* SgAsmDwarfLineList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfLineList* SgAsmDwarfLineList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfLineList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfLineList_clearMemoryPool ( );
void SgAsmDwarfLineList_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfLineList_initializeStorageClassArray( SgAsmDwarfLineListStorageClass *storageArray );
void SgAsmDwarfLineList_resetValidFreepointers( );
unsigned long SgAsmDwarfLineList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfCompilationUnitList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfCompilationUnitList* SgAsmDwarfCompilationUnitList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfCompilationUnitList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfCompilationUnitList* SgAsmDwarfCompilationUnitList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfCompilationUnitList* SgAsmDwarfCompilationUnitList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfCompilationUnitList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfCompilationUnitList_clearMemoryPool ( );
void SgAsmDwarfCompilationUnitList_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfCompilationUnitList_initializeStorageClassArray( SgAsmDwarfCompilationUnitListStorageClass *storageArray );
void SgAsmDwarfCompilationUnitList_resetValidFreepointers( );
unsigned long SgAsmDwarfCompilationUnitList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfConstruct_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfConstruct* SgAsmDwarfConstruct_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfConstruct_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfConstruct* SgAsmDwarfConstruct_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfConstruct* SgAsmDwarfConstruct_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfConstruct_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfConstruct_clearMemoryPool ( );
void SgAsmDwarfConstruct_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfConstruct_initializeStorageClassArray( SgAsmDwarfConstructStorageClass *storageArray );
void SgAsmDwarfConstruct_resetValidFreepointers( );
unsigned long SgAsmDwarfConstruct_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfArrayType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfArrayType* SgAsmDwarfArrayType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfArrayType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfArrayType* SgAsmDwarfArrayType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfArrayType* SgAsmDwarfArrayType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfArrayType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfArrayType_clearMemoryPool ( );
void SgAsmDwarfArrayType_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfArrayType_initializeStorageClassArray( SgAsmDwarfArrayTypeStorageClass *storageArray );
void SgAsmDwarfArrayType_resetValidFreepointers( );
unsigned long SgAsmDwarfArrayType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfClassType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfClassType* SgAsmDwarfClassType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfClassType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfClassType* SgAsmDwarfClassType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfClassType* SgAsmDwarfClassType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfClassType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfClassType_clearMemoryPool ( );
void SgAsmDwarfClassType_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfClassType_initializeStorageClassArray( SgAsmDwarfClassTypeStorageClass *storageArray );
void SgAsmDwarfClassType_resetValidFreepointers( );
unsigned long SgAsmDwarfClassType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfEntryPoint_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfEntryPoint* SgAsmDwarfEntryPoint_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfEntryPoint_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfEntryPoint* SgAsmDwarfEntryPoint_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfEntryPoint* SgAsmDwarfEntryPoint_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfEntryPoint_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfEntryPoint_clearMemoryPool ( );
void SgAsmDwarfEntryPoint_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfEntryPoint_initializeStorageClassArray( SgAsmDwarfEntryPointStorageClass *storageArray );
void SgAsmDwarfEntryPoint_resetValidFreepointers( );
unsigned long SgAsmDwarfEntryPoint_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfEnumerationType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfEnumerationType* SgAsmDwarfEnumerationType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfEnumerationType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfEnumerationType* SgAsmDwarfEnumerationType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfEnumerationType* SgAsmDwarfEnumerationType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfEnumerationType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfEnumerationType_clearMemoryPool ( );
void SgAsmDwarfEnumerationType_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfEnumerationType_initializeStorageClassArray( SgAsmDwarfEnumerationTypeStorageClass *storageArray );
void SgAsmDwarfEnumerationType_resetValidFreepointers( );
unsigned long SgAsmDwarfEnumerationType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfFormalParameter_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfFormalParameter* SgAsmDwarfFormalParameter_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfFormalParameter_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfFormalParameter* SgAsmDwarfFormalParameter_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfFormalParameter* SgAsmDwarfFormalParameter_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfFormalParameter_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfFormalParameter_clearMemoryPool ( );
void SgAsmDwarfFormalParameter_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfFormalParameter_initializeStorageClassArray( SgAsmDwarfFormalParameterStorageClass *storageArray );
void SgAsmDwarfFormalParameter_resetValidFreepointers( );
unsigned long SgAsmDwarfFormalParameter_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfImportedDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfImportedDeclaration* SgAsmDwarfImportedDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfImportedDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfImportedDeclaration* SgAsmDwarfImportedDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfImportedDeclaration* SgAsmDwarfImportedDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfImportedDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfImportedDeclaration_clearMemoryPool ( );
void SgAsmDwarfImportedDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfImportedDeclaration_initializeStorageClassArray( SgAsmDwarfImportedDeclarationStorageClass *storageArray );
void SgAsmDwarfImportedDeclaration_resetValidFreepointers( );
unsigned long SgAsmDwarfImportedDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfLabel_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfLabel* SgAsmDwarfLabel_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfLabel_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfLabel* SgAsmDwarfLabel_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfLabel* SgAsmDwarfLabel_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfLabel_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfLabel_clearMemoryPool ( );
void SgAsmDwarfLabel_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfLabel_initializeStorageClassArray( SgAsmDwarfLabelStorageClass *storageArray );
void SgAsmDwarfLabel_resetValidFreepointers( );
unsigned long SgAsmDwarfLabel_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfLexicalBlock_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfLexicalBlock* SgAsmDwarfLexicalBlock_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfLexicalBlock_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfLexicalBlock* SgAsmDwarfLexicalBlock_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfLexicalBlock* SgAsmDwarfLexicalBlock_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfLexicalBlock_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfLexicalBlock_clearMemoryPool ( );
void SgAsmDwarfLexicalBlock_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfLexicalBlock_initializeStorageClassArray( SgAsmDwarfLexicalBlockStorageClass *storageArray );
void SgAsmDwarfLexicalBlock_resetValidFreepointers( );
unsigned long SgAsmDwarfLexicalBlock_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfMember_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfMember* SgAsmDwarfMember_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfMember_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfMember* SgAsmDwarfMember_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfMember* SgAsmDwarfMember_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfMember_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfMember_clearMemoryPool ( );
void SgAsmDwarfMember_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfMember_initializeStorageClassArray( SgAsmDwarfMemberStorageClass *storageArray );
void SgAsmDwarfMember_resetValidFreepointers( );
unsigned long SgAsmDwarfMember_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfPointerType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfPointerType* SgAsmDwarfPointerType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfPointerType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfPointerType* SgAsmDwarfPointerType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfPointerType* SgAsmDwarfPointerType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfPointerType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfPointerType_clearMemoryPool ( );
void SgAsmDwarfPointerType_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfPointerType_initializeStorageClassArray( SgAsmDwarfPointerTypeStorageClass *storageArray );
void SgAsmDwarfPointerType_resetValidFreepointers( );
unsigned long SgAsmDwarfPointerType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfReferenceType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfReferenceType* SgAsmDwarfReferenceType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfReferenceType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfReferenceType* SgAsmDwarfReferenceType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfReferenceType* SgAsmDwarfReferenceType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfReferenceType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfReferenceType_clearMemoryPool ( );
void SgAsmDwarfReferenceType_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfReferenceType_initializeStorageClassArray( SgAsmDwarfReferenceTypeStorageClass *storageArray );
void SgAsmDwarfReferenceType_resetValidFreepointers( );
unsigned long SgAsmDwarfReferenceType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfCompilationUnit_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfCompilationUnit* SgAsmDwarfCompilationUnit_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfCompilationUnit_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfCompilationUnit* SgAsmDwarfCompilationUnit_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfCompilationUnit* SgAsmDwarfCompilationUnit_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfCompilationUnit_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfCompilationUnit_clearMemoryPool ( );
void SgAsmDwarfCompilationUnit_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfCompilationUnit_initializeStorageClassArray( SgAsmDwarfCompilationUnitStorageClass *storageArray );
void SgAsmDwarfCompilationUnit_resetValidFreepointers( );
unsigned long SgAsmDwarfCompilationUnit_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfStringType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfStringType* SgAsmDwarfStringType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfStringType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfStringType* SgAsmDwarfStringType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfStringType* SgAsmDwarfStringType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfStringType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfStringType_clearMemoryPool ( );
void SgAsmDwarfStringType_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfStringType_initializeStorageClassArray( SgAsmDwarfStringTypeStorageClass *storageArray );
void SgAsmDwarfStringType_resetValidFreepointers( );
unsigned long SgAsmDwarfStringType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfStructureType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfStructureType* SgAsmDwarfStructureType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfStructureType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfStructureType* SgAsmDwarfStructureType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfStructureType* SgAsmDwarfStructureType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfStructureType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfStructureType_clearMemoryPool ( );
void SgAsmDwarfStructureType_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfStructureType_initializeStorageClassArray( SgAsmDwarfStructureTypeStorageClass *storageArray );
void SgAsmDwarfStructureType_resetValidFreepointers( );
unsigned long SgAsmDwarfStructureType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfSubroutineType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfSubroutineType* SgAsmDwarfSubroutineType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfSubroutineType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfSubroutineType* SgAsmDwarfSubroutineType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfSubroutineType* SgAsmDwarfSubroutineType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfSubroutineType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfSubroutineType_clearMemoryPool ( );
void SgAsmDwarfSubroutineType_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfSubroutineType_initializeStorageClassArray( SgAsmDwarfSubroutineTypeStorageClass *storageArray );
void SgAsmDwarfSubroutineType_resetValidFreepointers( );
unsigned long SgAsmDwarfSubroutineType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfTypedef_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfTypedef* SgAsmDwarfTypedef_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfTypedef_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfTypedef* SgAsmDwarfTypedef_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfTypedef* SgAsmDwarfTypedef_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfTypedef_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfTypedef_clearMemoryPool ( );
void SgAsmDwarfTypedef_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfTypedef_initializeStorageClassArray( SgAsmDwarfTypedefStorageClass *storageArray );
void SgAsmDwarfTypedef_resetValidFreepointers( );
unsigned long SgAsmDwarfTypedef_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfUnionType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfUnionType* SgAsmDwarfUnionType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfUnionType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfUnionType* SgAsmDwarfUnionType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfUnionType* SgAsmDwarfUnionType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfUnionType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfUnionType_clearMemoryPool ( );
void SgAsmDwarfUnionType_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfUnionType_initializeStorageClassArray( SgAsmDwarfUnionTypeStorageClass *storageArray );
void SgAsmDwarfUnionType_resetValidFreepointers( );
unsigned long SgAsmDwarfUnionType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfUnspecifiedParameters_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfUnspecifiedParameters* SgAsmDwarfUnspecifiedParameters_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfUnspecifiedParameters_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfUnspecifiedParameters* SgAsmDwarfUnspecifiedParameters_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfUnspecifiedParameters* SgAsmDwarfUnspecifiedParameters_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfUnspecifiedParameters_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfUnspecifiedParameters_clearMemoryPool ( );
void SgAsmDwarfUnspecifiedParameters_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfUnspecifiedParameters_initializeStorageClassArray( SgAsmDwarfUnspecifiedParametersStorageClass *storageArray );
void SgAsmDwarfUnspecifiedParameters_resetValidFreepointers( );
unsigned long SgAsmDwarfUnspecifiedParameters_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfVariant_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfVariant* SgAsmDwarfVariant_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfVariant_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfVariant* SgAsmDwarfVariant_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfVariant* SgAsmDwarfVariant_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfVariant_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfVariant_clearMemoryPool ( );
void SgAsmDwarfVariant_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfVariant_initializeStorageClassArray( SgAsmDwarfVariantStorageClass *storageArray );
void SgAsmDwarfVariant_resetValidFreepointers( );
unsigned long SgAsmDwarfVariant_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfCommonBlock_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfCommonBlock* SgAsmDwarfCommonBlock_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfCommonBlock_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfCommonBlock* SgAsmDwarfCommonBlock_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfCommonBlock* SgAsmDwarfCommonBlock_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfCommonBlock_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfCommonBlock_clearMemoryPool ( );
void SgAsmDwarfCommonBlock_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfCommonBlock_initializeStorageClassArray( SgAsmDwarfCommonBlockStorageClass *storageArray );
void SgAsmDwarfCommonBlock_resetValidFreepointers( );
unsigned long SgAsmDwarfCommonBlock_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfCommonInclusion_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfCommonInclusion* SgAsmDwarfCommonInclusion_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfCommonInclusion_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfCommonInclusion* SgAsmDwarfCommonInclusion_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfCommonInclusion* SgAsmDwarfCommonInclusion_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfCommonInclusion_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfCommonInclusion_clearMemoryPool ( );
void SgAsmDwarfCommonInclusion_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfCommonInclusion_initializeStorageClassArray( SgAsmDwarfCommonInclusionStorageClass *storageArray );
void SgAsmDwarfCommonInclusion_resetValidFreepointers( );
unsigned long SgAsmDwarfCommonInclusion_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfInheritance_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfInheritance* SgAsmDwarfInheritance_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfInheritance_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfInheritance* SgAsmDwarfInheritance_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfInheritance* SgAsmDwarfInheritance_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfInheritance_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfInheritance_clearMemoryPool ( );
void SgAsmDwarfInheritance_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfInheritance_initializeStorageClassArray( SgAsmDwarfInheritanceStorageClass *storageArray );
void SgAsmDwarfInheritance_resetValidFreepointers( );
unsigned long SgAsmDwarfInheritance_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfInlinedSubroutine_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfInlinedSubroutine* SgAsmDwarfInlinedSubroutine_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfInlinedSubroutine_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfInlinedSubroutine* SgAsmDwarfInlinedSubroutine_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfInlinedSubroutine* SgAsmDwarfInlinedSubroutine_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfInlinedSubroutine_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfInlinedSubroutine_clearMemoryPool ( );
void SgAsmDwarfInlinedSubroutine_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfInlinedSubroutine_initializeStorageClassArray( SgAsmDwarfInlinedSubroutineStorageClass *storageArray );
void SgAsmDwarfInlinedSubroutine_resetValidFreepointers( );
unsigned long SgAsmDwarfInlinedSubroutine_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfModule_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfModule* SgAsmDwarfModule_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfModule_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfModule* SgAsmDwarfModule_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfModule* SgAsmDwarfModule_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfModule_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfModule_clearMemoryPool ( );
void SgAsmDwarfModule_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfModule_initializeStorageClassArray( SgAsmDwarfModuleStorageClass *storageArray );
void SgAsmDwarfModule_resetValidFreepointers( );
unsigned long SgAsmDwarfModule_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfPtrToMemberType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfPtrToMemberType* SgAsmDwarfPtrToMemberType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfPtrToMemberType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfPtrToMemberType* SgAsmDwarfPtrToMemberType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfPtrToMemberType* SgAsmDwarfPtrToMemberType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfPtrToMemberType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfPtrToMemberType_clearMemoryPool ( );
void SgAsmDwarfPtrToMemberType_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfPtrToMemberType_initializeStorageClassArray( SgAsmDwarfPtrToMemberTypeStorageClass *storageArray );
void SgAsmDwarfPtrToMemberType_resetValidFreepointers( );
unsigned long SgAsmDwarfPtrToMemberType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfSetType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfSetType* SgAsmDwarfSetType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfSetType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfSetType* SgAsmDwarfSetType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfSetType* SgAsmDwarfSetType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfSetType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfSetType_clearMemoryPool ( );
void SgAsmDwarfSetType_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfSetType_initializeStorageClassArray( SgAsmDwarfSetTypeStorageClass *storageArray );
void SgAsmDwarfSetType_resetValidFreepointers( );
unsigned long SgAsmDwarfSetType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfSubrangeType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfSubrangeType* SgAsmDwarfSubrangeType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfSubrangeType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfSubrangeType* SgAsmDwarfSubrangeType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfSubrangeType* SgAsmDwarfSubrangeType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfSubrangeType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfSubrangeType_clearMemoryPool ( );
void SgAsmDwarfSubrangeType_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfSubrangeType_initializeStorageClassArray( SgAsmDwarfSubrangeTypeStorageClass *storageArray );
void SgAsmDwarfSubrangeType_resetValidFreepointers( );
unsigned long SgAsmDwarfSubrangeType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfWithStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfWithStmt* SgAsmDwarfWithStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfWithStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfWithStmt* SgAsmDwarfWithStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfWithStmt* SgAsmDwarfWithStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfWithStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfWithStmt_clearMemoryPool ( );
void SgAsmDwarfWithStmt_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfWithStmt_initializeStorageClassArray( SgAsmDwarfWithStmtStorageClass *storageArray );
void SgAsmDwarfWithStmt_resetValidFreepointers( );
unsigned long SgAsmDwarfWithStmt_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfAccessDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfAccessDeclaration* SgAsmDwarfAccessDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfAccessDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfAccessDeclaration* SgAsmDwarfAccessDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfAccessDeclaration* SgAsmDwarfAccessDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfAccessDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfAccessDeclaration_clearMemoryPool ( );
void SgAsmDwarfAccessDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfAccessDeclaration_initializeStorageClassArray( SgAsmDwarfAccessDeclarationStorageClass *storageArray );
void SgAsmDwarfAccessDeclaration_resetValidFreepointers( );
unsigned long SgAsmDwarfAccessDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfBaseType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfBaseType* SgAsmDwarfBaseType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfBaseType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfBaseType* SgAsmDwarfBaseType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfBaseType* SgAsmDwarfBaseType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfBaseType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfBaseType_clearMemoryPool ( );
void SgAsmDwarfBaseType_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfBaseType_initializeStorageClassArray( SgAsmDwarfBaseTypeStorageClass *storageArray );
void SgAsmDwarfBaseType_resetValidFreepointers( );
unsigned long SgAsmDwarfBaseType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfCatchBlock_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfCatchBlock* SgAsmDwarfCatchBlock_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfCatchBlock_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfCatchBlock* SgAsmDwarfCatchBlock_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfCatchBlock* SgAsmDwarfCatchBlock_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfCatchBlock_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfCatchBlock_clearMemoryPool ( );
void SgAsmDwarfCatchBlock_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfCatchBlock_initializeStorageClassArray( SgAsmDwarfCatchBlockStorageClass *storageArray );
void SgAsmDwarfCatchBlock_resetValidFreepointers( );
unsigned long SgAsmDwarfCatchBlock_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfConstType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfConstType* SgAsmDwarfConstType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfConstType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfConstType* SgAsmDwarfConstType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfConstType* SgAsmDwarfConstType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfConstType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfConstType_clearMemoryPool ( );
void SgAsmDwarfConstType_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfConstType_initializeStorageClassArray( SgAsmDwarfConstTypeStorageClass *storageArray );
void SgAsmDwarfConstType_resetValidFreepointers( );
unsigned long SgAsmDwarfConstType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfConstant_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfConstant* SgAsmDwarfConstant_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfConstant_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfConstant* SgAsmDwarfConstant_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfConstant* SgAsmDwarfConstant_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfConstant_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfConstant_clearMemoryPool ( );
void SgAsmDwarfConstant_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfConstant_initializeStorageClassArray( SgAsmDwarfConstantStorageClass *storageArray );
void SgAsmDwarfConstant_resetValidFreepointers( );
unsigned long SgAsmDwarfConstant_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfEnumerator_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfEnumerator* SgAsmDwarfEnumerator_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfEnumerator_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfEnumerator* SgAsmDwarfEnumerator_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfEnumerator* SgAsmDwarfEnumerator_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfEnumerator_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfEnumerator_clearMemoryPool ( );
void SgAsmDwarfEnumerator_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfEnumerator_initializeStorageClassArray( SgAsmDwarfEnumeratorStorageClass *storageArray );
void SgAsmDwarfEnumerator_resetValidFreepointers( );
unsigned long SgAsmDwarfEnumerator_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfFileType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfFileType* SgAsmDwarfFileType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfFileType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfFileType* SgAsmDwarfFileType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfFileType* SgAsmDwarfFileType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfFileType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfFileType_clearMemoryPool ( );
void SgAsmDwarfFileType_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfFileType_initializeStorageClassArray( SgAsmDwarfFileTypeStorageClass *storageArray );
void SgAsmDwarfFileType_resetValidFreepointers( );
unsigned long SgAsmDwarfFileType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfFriend_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfFriend* SgAsmDwarfFriend_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfFriend_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfFriend* SgAsmDwarfFriend_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfFriend* SgAsmDwarfFriend_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfFriend_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfFriend_clearMemoryPool ( );
void SgAsmDwarfFriend_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfFriend_initializeStorageClassArray( SgAsmDwarfFriendStorageClass *storageArray );
void SgAsmDwarfFriend_resetValidFreepointers( );
unsigned long SgAsmDwarfFriend_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfNamelist_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfNamelist* SgAsmDwarfNamelist_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfNamelist_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfNamelist* SgAsmDwarfNamelist_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfNamelist* SgAsmDwarfNamelist_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfNamelist_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfNamelist_clearMemoryPool ( );
void SgAsmDwarfNamelist_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfNamelist_initializeStorageClassArray( SgAsmDwarfNamelistStorageClass *storageArray );
void SgAsmDwarfNamelist_resetValidFreepointers( );
unsigned long SgAsmDwarfNamelist_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfNamelistItem_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfNamelistItem* SgAsmDwarfNamelistItem_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfNamelistItem_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfNamelistItem* SgAsmDwarfNamelistItem_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfNamelistItem* SgAsmDwarfNamelistItem_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfNamelistItem_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfNamelistItem_clearMemoryPool ( );
void SgAsmDwarfNamelistItem_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfNamelistItem_initializeStorageClassArray( SgAsmDwarfNamelistItemStorageClass *storageArray );
void SgAsmDwarfNamelistItem_resetValidFreepointers( );
unsigned long SgAsmDwarfNamelistItem_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfPackedType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfPackedType* SgAsmDwarfPackedType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfPackedType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfPackedType* SgAsmDwarfPackedType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfPackedType* SgAsmDwarfPackedType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfPackedType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfPackedType_clearMemoryPool ( );
void SgAsmDwarfPackedType_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfPackedType_initializeStorageClassArray( SgAsmDwarfPackedTypeStorageClass *storageArray );
void SgAsmDwarfPackedType_resetValidFreepointers( );
unsigned long SgAsmDwarfPackedType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfSubprogram_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfSubprogram* SgAsmDwarfSubprogram_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfSubprogram_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfSubprogram* SgAsmDwarfSubprogram_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfSubprogram* SgAsmDwarfSubprogram_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfSubprogram_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfSubprogram_clearMemoryPool ( );
void SgAsmDwarfSubprogram_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfSubprogram_initializeStorageClassArray( SgAsmDwarfSubprogramStorageClass *storageArray );
void SgAsmDwarfSubprogram_resetValidFreepointers( );
unsigned long SgAsmDwarfSubprogram_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfTemplateTypeParameter_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfTemplateTypeParameter* SgAsmDwarfTemplateTypeParameter_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfTemplateTypeParameter_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfTemplateTypeParameter* SgAsmDwarfTemplateTypeParameter_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfTemplateTypeParameter* SgAsmDwarfTemplateTypeParameter_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfTemplateTypeParameter_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfTemplateTypeParameter_clearMemoryPool ( );
void SgAsmDwarfTemplateTypeParameter_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfTemplateTypeParameter_initializeStorageClassArray( SgAsmDwarfTemplateTypeParameterStorageClass *storageArray );
void SgAsmDwarfTemplateTypeParameter_resetValidFreepointers( );
unsigned long SgAsmDwarfTemplateTypeParameter_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfTemplateValueParameter_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfTemplateValueParameter* SgAsmDwarfTemplateValueParameter_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfTemplateValueParameter_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfTemplateValueParameter* SgAsmDwarfTemplateValueParameter_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfTemplateValueParameter* SgAsmDwarfTemplateValueParameter_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfTemplateValueParameter_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfTemplateValueParameter_clearMemoryPool ( );
void SgAsmDwarfTemplateValueParameter_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfTemplateValueParameter_initializeStorageClassArray( SgAsmDwarfTemplateValueParameterStorageClass *storageArray );
void SgAsmDwarfTemplateValueParameter_resetValidFreepointers( );
unsigned long SgAsmDwarfTemplateValueParameter_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfThrownType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfThrownType* SgAsmDwarfThrownType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfThrownType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfThrownType* SgAsmDwarfThrownType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfThrownType* SgAsmDwarfThrownType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfThrownType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfThrownType_clearMemoryPool ( );
void SgAsmDwarfThrownType_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfThrownType_initializeStorageClassArray( SgAsmDwarfThrownTypeStorageClass *storageArray );
void SgAsmDwarfThrownType_resetValidFreepointers( );
unsigned long SgAsmDwarfThrownType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfTryBlock_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfTryBlock* SgAsmDwarfTryBlock_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfTryBlock_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfTryBlock* SgAsmDwarfTryBlock_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfTryBlock* SgAsmDwarfTryBlock_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfTryBlock_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfTryBlock_clearMemoryPool ( );
void SgAsmDwarfTryBlock_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfTryBlock_initializeStorageClassArray( SgAsmDwarfTryBlockStorageClass *storageArray );
void SgAsmDwarfTryBlock_resetValidFreepointers( );
unsigned long SgAsmDwarfTryBlock_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfVariantPart_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfVariantPart* SgAsmDwarfVariantPart_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfVariantPart_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfVariantPart* SgAsmDwarfVariantPart_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfVariantPart* SgAsmDwarfVariantPart_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfVariantPart_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfVariantPart_clearMemoryPool ( );
void SgAsmDwarfVariantPart_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfVariantPart_initializeStorageClassArray( SgAsmDwarfVariantPartStorageClass *storageArray );
void SgAsmDwarfVariantPart_resetValidFreepointers( );
unsigned long SgAsmDwarfVariantPart_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfVariable_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfVariable* SgAsmDwarfVariable_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfVariable_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfVariable* SgAsmDwarfVariable_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfVariable* SgAsmDwarfVariable_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfVariable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfVariable_clearMemoryPool ( );
void SgAsmDwarfVariable_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfVariable_initializeStorageClassArray( SgAsmDwarfVariableStorageClass *storageArray );
void SgAsmDwarfVariable_resetValidFreepointers( );
unsigned long SgAsmDwarfVariable_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfVolatileType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfVolatileType* SgAsmDwarfVolatileType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfVolatileType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfVolatileType* SgAsmDwarfVolatileType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfVolatileType* SgAsmDwarfVolatileType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfVolatileType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfVolatileType_clearMemoryPool ( );
void SgAsmDwarfVolatileType_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfVolatileType_initializeStorageClassArray( SgAsmDwarfVolatileTypeStorageClass *storageArray );
void SgAsmDwarfVolatileType_resetValidFreepointers( );
unsigned long SgAsmDwarfVolatileType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfDwarfProcedure_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfDwarfProcedure* SgAsmDwarfDwarfProcedure_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfDwarfProcedure_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfDwarfProcedure* SgAsmDwarfDwarfProcedure_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfDwarfProcedure* SgAsmDwarfDwarfProcedure_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfDwarfProcedure_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfDwarfProcedure_clearMemoryPool ( );
void SgAsmDwarfDwarfProcedure_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfDwarfProcedure_initializeStorageClassArray( SgAsmDwarfDwarfProcedureStorageClass *storageArray );
void SgAsmDwarfDwarfProcedure_resetValidFreepointers( );
unsigned long SgAsmDwarfDwarfProcedure_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfRestrictType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfRestrictType* SgAsmDwarfRestrictType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfRestrictType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfRestrictType* SgAsmDwarfRestrictType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfRestrictType* SgAsmDwarfRestrictType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfRestrictType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfRestrictType_clearMemoryPool ( );
void SgAsmDwarfRestrictType_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfRestrictType_initializeStorageClassArray( SgAsmDwarfRestrictTypeStorageClass *storageArray );
void SgAsmDwarfRestrictType_resetValidFreepointers( );
unsigned long SgAsmDwarfRestrictType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfInterfaceType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfInterfaceType* SgAsmDwarfInterfaceType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfInterfaceType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfInterfaceType* SgAsmDwarfInterfaceType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfInterfaceType* SgAsmDwarfInterfaceType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfInterfaceType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfInterfaceType_clearMemoryPool ( );
void SgAsmDwarfInterfaceType_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfInterfaceType_initializeStorageClassArray( SgAsmDwarfInterfaceTypeStorageClass *storageArray );
void SgAsmDwarfInterfaceType_resetValidFreepointers( );
unsigned long SgAsmDwarfInterfaceType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfNamespace_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfNamespace* SgAsmDwarfNamespace_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfNamespace_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfNamespace* SgAsmDwarfNamespace_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfNamespace* SgAsmDwarfNamespace_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfNamespace_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfNamespace_clearMemoryPool ( );
void SgAsmDwarfNamespace_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfNamespace_initializeStorageClassArray( SgAsmDwarfNamespaceStorageClass *storageArray );
void SgAsmDwarfNamespace_resetValidFreepointers( );
unsigned long SgAsmDwarfNamespace_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfImportedModule_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfImportedModule* SgAsmDwarfImportedModule_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfImportedModule_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfImportedModule* SgAsmDwarfImportedModule_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfImportedModule* SgAsmDwarfImportedModule_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfImportedModule_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfImportedModule_clearMemoryPool ( );
void SgAsmDwarfImportedModule_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfImportedModule_initializeStorageClassArray( SgAsmDwarfImportedModuleStorageClass *storageArray );
void SgAsmDwarfImportedModule_resetValidFreepointers( );
unsigned long SgAsmDwarfImportedModule_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfUnspecifiedType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfUnspecifiedType* SgAsmDwarfUnspecifiedType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfUnspecifiedType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfUnspecifiedType* SgAsmDwarfUnspecifiedType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfUnspecifiedType* SgAsmDwarfUnspecifiedType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfUnspecifiedType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfUnspecifiedType_clearMemoryPool ( );
void SgAsmDwarfUnspecifiedType_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfUnspecifiedType_initializeStorageClassArray( SgAsmDwarfUnspecifiedTypeStorageClass *storageArray );
void SgAsmDwarfUnspecifiedType_resetValidFreepointers( );
unsigned long SgAsmDwarfUnspecifiedType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfPartialUnit_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfPartialUnit* SgAsmDwarfPartialUnit_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfPartialUnit_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfPartialUnit* SgAsmDwarfPartialUnit_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfPartialUnit* SgAsmDwarfPartialUnit_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfPartialUnit_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfPartialUnit_clearMemoryPool ( );
void SgAsmDwarfPartialUnit_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfPartialUnit_initializeStorageClassArray( SgAsmDwarfPartialUnitStorageClass *storageArray );
void SgAsmDwarfPartialUnit_resetValidFreepointers( );
unsigned long SgAsmDwarfPartialUnit_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfImportedUnit_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfImportedUnit* SgAsmDwarfImportedUnit_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfImportedUnit_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfImportedUnit* SgAsmDwarfImportedUnit_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfImportedUnit* SgAsmDwarfImportedUnit_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfImportedUnit_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfImportedUnit_clearMemoryPool ( );
void SgAsmDwarfImportedUnit_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfImportedUnit_initializeStorageClassArray( SgAsmDwarfImportedUnitStorageClass *storageArray );
void SgAsmDwarfImportedUnit_resetValidFreepointers( );
unsigned long SgAsmDwarfImportedUnit_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfMutableType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfMutableType* SgAsmDwarfMutableType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfMutableType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfMutableType* SgAsmDwarfMutableType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfMutableType* SgAsmDwarfMutableType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfMutableType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfMutableType_clearMemoryPool ( );
void SgAsmDwarfMutableType_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfMutableType_initializeStorageClassArray( SgAsmDwarfMutableTypeStorageClass *storageArray );
void SgAsmDwarfMutableType_resetValidFreepointers( );
unsigned long SgAsmDwarfMutableType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfCondition_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfCondition* SgAsmDwarfCondition_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfCondition_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfCondition* SgAsmDwarfCondition_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfCondition* SgAsmDwarfCondition_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfCondition_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfCondition_clearMemoryPool ( );
void SgAsmDwarfCondition_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfCondition_initializeStorageClassArray( SgAsmDwarfConditionStorageClass *storageArray );
void SgAsmDwarfCondition_resetValidFreepointers( );
unsigned long SgAsmDwarfCondition_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfSharedType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfSharedType* SgAsmDwarfSharedType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfSharedType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfSharedType* SgAsmDwarfSharedType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfSharedType* SgAsmDwarfSharedType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfSharedType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfSharedType_clearMemoryPool ( );
void SgAsmDwarfSharedType_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfSharedType_initializeStorageClassArray( SgAsmDwarfSharedTypeStorageClass *storageArray );
void SgAsmDwarfSharedType_resetValidFreepointers( );
unsigned long SgAsmDwarfSharedType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfFormatLabel_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfFormatLabel* SgAsmDwarfFormatLabel_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfFormatLabel_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfFormatLabel* SgAsmDwarfFormatLabel_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfFormatLabel* SgAsmDwarfFormatLabel_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfFormatLabel_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfFormatLabel_clearMemoryPool ( );
void SgAsmDwarfFormatLabel_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfFormatLabel_initializeStorageClassArray( SgAsmDwarfFormatLabelStorageClass *storageArray );
void SgAsmDwarfFormatLabel_resetValidFreepointers( );
unsigned long SgAsmDwarfFormatLabel_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfFunctionTemplate_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfFunctionTemplate* SgAsmDwarfFunctionTemplate_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfFunctionTemplate_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfFunctionTemplate* SgAsmDwarfFunctionTemplate_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfFunctionTemplate* SgAsmDwarfFunctionTemplate_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfFunctionTemplate_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfFunctionTemplate_clearMemoryPool ( );
void SgAsmDwarfFunctionTemplate_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfFunctionTemplate_initializeStorageClassArray( SgAsmDwarfFunctionTemplateStorageClass *storageArray );
void SgAsmDwarfFunctionTemplate_resetValidFreepointers( );
unsigned long SgAsmDwarfFunctionTemplate_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfClassTemplate_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfClassTemplate* SgAsmDwarfClassTemplate_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfClassTemplate_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfClassTemplate* SgAsmDwarfClassTemplate_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfClassTemplate* SgAsmDwarfClassTemplate_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfClassTemplate_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfClassTemplate_clearMemoryPool ( );
void SgAsmDwarfClassTemplate_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfClassTemplate_initializeStorageClassArray( SgAsmDwarfClassTemplateStorageClass *storageArray );
void SgAsmDwarfClassTemplate_resetValidFreepointers( );
unsigned long SgAsmDwarfClassTemplate_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfUpcSharedType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfUpcSharedType* SgAsmDwarfUpcSharedType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfUpcSharedType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfUpcSharedType* SgAsmDwarfUpcSharedType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfUpcSharedType* SgAsmDwarfUpcSharedType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfUpcSharedType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfUpcSharedType_clearMemoryPool ( );
void SgAsmDwarfUpcSharedType_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfUpcSharedType_initializeStorageClassArray( SgAsmDwarfUpcSharedTypeStorageClass *storageArray );
void SgAsmDwarfUpcSharedType_resetValidFreepointers( );
unsigned long SgAsmDwarfUpcSharedType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfUpcStrictType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfUpcStrictType* SgAsmDwarfUpcStrictType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfUpcStrictType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfUpcStrictType* SgAsmDwarfUpcStrictType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfUpcStrictType* SgAsmDwarfUpcStrictType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfUpcStrictType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfUpcStrictType_clearMemoryPool ( );
void SgAsmDwarfUpcStrictType_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfUpcStrictType_initializeStorageClassArray( SgAsmDwarfUpcStrictTypeStorageClass *storageArray );
void SgAsmDwarfUpcStrictType_resetValidFreepointers( );
unsigned long SgAsmDwarfUpcStrictType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfUpcRelaxedType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfUpcRelaxedType* SgAsmDwarfUpcRelaxedType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfUpcRelaxedType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfUpcRelaxedType* SgAsmDwarfUpcRelaxedType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfUpcRelaxedType* SgAsmDwarfUpcRelaxedType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfUpcRelaxedType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfUpcRelaxedType_clearMemoryPool ( );
void SgAsmDwarfUpcRelaxedType_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfUpcRelaxedType_initializeStorageClassArray( SgAsmDwarfUpcRelaxedTypeStorageClass *storageArray );
void SgAsmDwarfUpcRelaxedType_resetValidFreepointers( );
unsigned long SgAsmDwarfUpcRelaxedType_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfUnknownConstruct_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfUnknownConstruct* SgAsmDwarfUnknownConstruct_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfUnknownConstruct_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfUnknownConstruct* SgAsmDwarfUnknownConstruct_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfUnknownConstruct* SgAsmDwarfUnknownConstruct_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfUnknownConstruct_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfUnknownConstruct_clearMemoryPool ( );
void SgAsmDwarfUnknownConstruct_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfUnknownConstruct_initializeStorageClassArray( SgAsmDwarfUnknownConstructStorageClass *storageArray );
void SgAsmDwarfUnknownConstruct_resetValidFreepointers( );
unsigned long SgAsmDwarfUnknownConstruct_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmDwarfConstructList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmDwarfConstructList* SgAsmDwarfConstructList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmDwarfConstructList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmDwarfConstructList* SgAsmDwarfConstructList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmDwarfConstructList* SgAsmDwarfConstructList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmDwarfConstructList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmDwarfConstructList_clearMemoryPool ( );
void SgAsmDwarfConstructList_extendMemoryPoolForFileIO ( );
unsigned long SgAsmDwarfConstructList_initializeStorageClassArray( SgAsmDwarfConstructListStorageClass *storageArray );
void SgAsmDwarfConstructList_resetValidFreepointers( );
unsigned long SgAsmDwarfConstructList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmPEImportItem_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmPEImportItem* SgAsmPEImportItem_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmPEImportItem_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmPEImportItem* SgAsmPEImportItem_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmPEImportItem* SgAsmPEImportItem_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmPEImportItem_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmPEImportItem_clearMemoryPool ( );
void SgAsmPEImportItem_extendMemoryPoolForFileIO ( );
unsigned long SgAsmPEImportItem_initializeStorageClassArray( SgAsmPEImportItemStorageClass *storageArray );
void SgAsmPEImportItem_resetValidFreepointers( );
unsigned long SgAsmPEImportItem_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmPEImportItemList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmPEImportItemList* SgAsmPEImportItemList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmPEImportItemList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmPEImportItemList* SgAsmPEImportItemList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmPEImportItemList* SgAsmPEImportItemList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmPEImportItemList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmPEImportItemList_clearMemoryPool ( );
void SgAsmPEImportItemList_extendMemoryPoolForFileIO ( );
unsigned long SgAsmPEImportItemList_initializeStorageClassArray( SgAsmPEImportItemListStorageClass *storageArray );
void SgAsmPEImportItemList_resetValidFreepointers( );
unsigned long SgAsmPEImportItemList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmInterpretationList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmInterpretationList* SgAsmInterpretationList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmInterpretationList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmInterpretationList* SgAsmInterpretationList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmInterpretationList* SgAsmInterpretationList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmInterpretationList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmInterpretationList_clearMemoryPool ( );
void SgAsmInterpretationList_extendMemoryPoolForFileIO ( );
unsigned long SgAsmInterpretationList_initializeStorageClassArray( SgAsmInterpretationListStorageClass *storageArray );
void SgAsmInterpretationList_resetValidFreepointers( );
unsigned long SgAsmInterpretationList_getNumberOfLastValidPointer();


/* #line 1 "/home/demo/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmGenericFileList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmGenericFileList* SgAsmGenericFileList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmGenericFileList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmGenericFileList* SgAsmGenericFileList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmGenericFileList* SgAsmGenericFileList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmGenericFileList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmGenericFileList_clearMemoryPool ( );
void SgAsmGenericFileList_extendMemoryPoolForFileIO ( );
unsigned long SgAsmGenericFileList_initializeStorageClassArray( SgAsmGenericFileListStorageClass *storageArray );
void SgAsmGenericFileList_resetValidFreepointers( );
unsigned long SgAsmGenericFileList_getNumberOfLastValidPointer();



